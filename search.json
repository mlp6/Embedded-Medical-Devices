[
  {
    "objectID": "software-install-tutorials.html",
    "href": "software-install-tutorials.html",
    "title": "Software Installation and Tutorials",
    "section": "",
    "text": "Please follow the instructions on this dedicated git page to:\n\nInstall git\nConfigure git\nSetup an SSH key\nProvide links to git tutorials to remind you how to use git version control",
    "crumbs": [
      "Course Information",
      "Software Installation & Tutorials"
    ]
  },
  {
    "objectID": "software-install-tutorials.html#git-version-control",
    "href": "software-install-tutorials.html#git-version-control",
    "title": "Software Installation and Tutorials",
    "section": "",
    "text": "Please follow the instructions on this dedicated git page to:\n\nInstall git\nConfigure git\nSetup an SSH key\nProvide links to git tutorials to remind you how to use git version control",
    "crumbs": [
      "Course Information",
      "Software Installation & Tutorials"
    ]
  },
  {
    "objectID": "software-install-tutorials.html#visual-studio-code-ide",
    "href": "software-install-tutorials.html#visual-studio-code-ide",
    "title": "Software Installation and Tutorials",
    "section": "Visual Studio Code (IDE)",
    "text": "Visual Studio Code (IDE)\nWe will be using Visual Studio Code as the IDE for all projects in this class. In addition to installing the base program, please install the following Extensions:\n\nnRF Connect for VS Code (Extension Pack)\nGitLens (help with git operations / visualization)\nC/C++ (not the extension pack, since it include CMake Tools that has some incompatibilities with the Zephyr build tools)\nCmake\nState diagram software (see below)\nGitHub CoPilot Chat AI coding assistant (optional, but highly recommended)\n\n\n\n\n\n\n\nTip\n\n\n\nYou can get “Pro” status for GitHub CoPilot by signing up for a free GitHub Education Student account. You will need a document to verify your student status that includes your dates of enrollment, which your DukeCard does not contain. Instead, you can get an Enrollment Verification document through DukeHub (Academics Tab) and convert the downloaded PDF to a JPG or PNG file to upload to GitHub.",
    "crumbs": [
      "Course Information",
      "Software Installation & Tutorials"
    ]
  },
  {
    "objectID": "software-install-tutorials.html#state-diagram-software",
    "href": "software-install-tutorials.html#state-diagram-software",
    "title": "Software Installation and Tutorials",
    "section": "State Diagram Software",
    "text": "State Diagram Software\nWe will be generating state diagrams all semester, which can be done with a variety of different software packages, described here. Please be sure to have one of the described software packages ready for you to prepare state diagrams this semester.",
    "crumbs": [
      "Course Information",
      "Software Installation & Tutorials"
    ]
  },
  {
    "objectID": "software-install-tutorials.html#zephyr-sdk-nrf-connect-nordic-dev-academy",
    "href": "software-install-tutorials.html#zephyr-sdk-nrf-connect-nordic-dev-academy",
    "title": "Software Installation and Tutorials",
    "section": "Zephyr SDK / nRF Connect / Nordic Dev Academy",
    "text": "Zephyr SDK / nRF Connect / Nordic Dev Academy\n\nSign up for an account on the Nordic Semiconductor DevAcademy\nPlease complete the following tutorial to get your environment setup for using the Nordic nRF Connect SDK: Lesson 1 - nRF Connect SDK Introduction\n\nThis will run you through the process of:\n\nInstalling the nRF Connect for VS Code extension pack.\nInstalling all of the associated nRF Connect tools for your laptop, including the nRF Connect SDK and associated toolchain.\n\n\n\n\n\n\n\nTip\n\n\n\nBe sure to use the nRF Connect SDK v3.2.1 for this class. The starter code provided throughout the semester will be based on this version of the SDK.\n\n\n\nOnce you have the hardware you need to order described below, flash the zephyr/samples/basic/blinky to your nRF52833DK.\n\n\n\n\n\n\n\nTip\n\n\n\nMake sure you can successfully do this, as it will test your USB cable connection, USB serial port device permissions and your build/flash environment.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nYou will be doing all of the lessons in this Nordic Dev Academy fundamentals course and earning the online certification by the end of the semester will count towards your final grade.",
    "crumbs": [
      "Course Information",
      "Software Installation & Tutorials"
    ]
  },
  {
    "objectID": "software-install-tutorials.html#hardware-to-buy",
    "href": "software-install-tutorials.html#hardware-to-buy",
    "title": "Software Installation and Tutorials",
    "section": "Hardware to Buy",
    "text": "Hardware to Buy\n\nOrder a nRF52833DK.\nMake sure you have the appropriate USB cable to flash the device from your laptop. This may require an adaptor for some laptops.\n\n\n\n\n\n\n\nImportant\n\n\n\nMake sure that your USB cable supports data transfer and is not just a charging cable.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nWe will not have USB cables and adapters available in the lab.\n\n\n\nOrder a MCP9808 High Accuracy I2C Temperature Sensor Breakout Board. (Link is to Adafruit, but you can get it from other vendors as well.)",
    "crumbs": [
      "Course Information",
      "Software Installation & Tutorials"
    ]
  },
  {
    "objectID": "software-install-tutorials.html#technical-reports-jupyter-notebooks",
    "href": "software-install-tutorials.html#technical-reports-jupyter-notebooks",
    "title": "Software Installation and Tutorials",
    "section": "Technical Reports: Jupyter Notebooks",
    "text": "Technical Reports: Jupyter Notebooks\nLab exercises will require data analysis to be performed in Jupyter notebooks. Please review the Technical Report Preparation page to make sure that you have all of the necessary tools to edit Jupyter notebooks and access to the necessary Python packages.",
    "crumbs": [
      "Course Information",
      "Software Installation & Tutorials"
    ]
  },
  {
    "objectID": "software-install-tutorials.html#what-to-submit",
    "href": "software-install-tutorials.html#what-to-submit",
    "title": "Software Installation and Tutorials",
    "section": "What to Submit",
    "text": "What to Submit\nComplete the online Gradescope “quiz” indicating completion of each of the main tasks above.",
    "crumbs": [
      "Course Information",
      "Software Installation & Tutorials"
    ]
  },
  {
    "objectID": "slides/zephyr-adc.html",
    "href": "slides/zephyr-adc.html",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "",
    "text": "The nRF52833 uses a Sucessive Approximation ADC (SAADC).\nThe SAADC is a differential ADC.\nThat one SADDC is multiplexed to 8 channels (GPIO pins).",
    "crumbs": [
      "Learning Modules",
      "Analog-to-Digital Conversion (ADC)"
    ]
  },
  {
    "objectID": "slides/zephyr-adc.html#introduction",
    "href": "slides/zephyr-adc.html#introduction",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "",
    "text": "The nRF52833 uses a Sucessive Approximation ADC (SAADC).\nThe SAADC is a differential ADC.\nThat one SADDC is multiplexed to 8 channels (GPIO pins).",
    "crumbs": [
      "Learning Modules",
      "Analog-to-Digital Conversion (ADC)"
    ]
  },
  {
    "objectID": "slides/zephyr-adc.html#how-does-an-saadc-work",
    "href": "slides/zephyr-adc.html#how-does-an-saadc-work",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "How does an SAADC work?",
    "text": "How does an SAADC work?\n\nNordic DevAcademy: SAADC",
    "crumbs": [
      "Learning Modules",
      "Analog-to-Digital Conversion (ADC)"
    ]
  },
  {
    "objectID": "slides/zephyr-adc.html#prj.conf",
    "href": "slides/zephyr-adc.html#prj.conf",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "prj.conf",
    "text": "prj.conf\nCONFIG_ADC=y",
    "crumbs": [
      "Learning Modules",
      "Analog-to-Digital Conversion (ADC)"
    ]
  },
  {
    "objectID": "slides/zephyr-adc.html#devicetree-overlay",
    "href": "slides/zephyr-adc.html#devicetree-overlay",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Devicetree Overlay",
    "text": "Devicetree Overlay\n    // This is the root level of the DT\n    / {\n        zephyr,user {\n            io-channels = &lt;&adc 0&gt;; // need to \"activate\" these channels for IO usage\n        };\n        aliases {\n            vadc = &vadc;\n        }\n    }\n\n    // This is modifying the existing ADC node in the DT\n    &adc {\n        #address-cells = &lt;1&gt;;\n        #size-cells = &lt;0&gt;;\n\n        vadc: channel@0 {\n            reg = &lt;0&gt;;  // channel number\n            zephyr,reference = \"ADC_REF_INTERNAL\";  // voltage ref for SA (0.6 V)\n            zephyr,gain = \"ADC_GAIN_1_5\"; // gain factor to scale ref voltage (1/gain)\n            zephyr,acquisition-time = &lt;ADC_ACQ_TIME_DEFAULT&gt;;\n            zephyr,input-positive = &lt;NRF_SAADC_AIN0&gt;; // P0.02\n            zephyr,resolution = &lt;12&gt;;  // bit depth\n        };\n        status = \"okay\"; // enable the ADC\n    };",
    "crumbs": [
      "Learning Modules",
      "Analog-to-Digital Conversion (ADC)"
    ]
  },
  {
    "objectID": "slides/zephyr-adc.html#how-digital-output-is-calculated",
    "href": "slides/zephyr-adc.html#how-digital-output-is-calculated",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "How Digital Output is Calculated",
    "text": "How Digital Output is Calculated\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nRESULT is stored as 16-bit 2’s complement values.",
    "crumbs": [
      "Learning Modules",
      "Analog-to-Digital Conversion (ADC)"
    ]
  },
  {
    "objectID": "slides/zephyr-adc.html#reference-voltage",
    "href": "slides/zephyr-adc.html#reference-voltage",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Reference Voltage",
    "text": "Reference Voltage\n\nOnly ADC_REF_INTERNAL (0.6 V) and ADC_REF_VDD_1_4 are valid on the nRF52833.\nWhen using VDD (3.0 V) as a reference, you need to also specify the nominal reference voltage in the Devicetree: e.g., zephyr,vref-mv = &lt;750&gt;; (3.0 V / 4)\nADC_REF_INTERNAL is based on a diode threshold voltage and is more stable.\nADC_REF_VDD_1_4 can drift with fluctuations in VDD (which can be a good thing).",
    "crumbs": [
      "Learning Modules",
      "Analog-to-Digital Conversion (ADC)"
    ]
  },
  {
    "objectID": "slides/zephyr-adc.html#main.c",
    "href": "slides/zephyr-adc.html#main.c",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "main.c",
    "text": "main.c\n/* Load the ADC library that you ennabled in prj.conf */\n#include &lt;zephyr/drivers/adc.h&gt; \n\n/* Define some macros to use some Zephyr macros to help read the DT\nconfiguration based on the ADC channel alias (I have no idea why this\nmacro is not available in adc.h) */\n#define ADC_DT_SPEC_GET_BY_ALIAS(adc_alias)                    \\\n{                                                            \\\n    .dev = DEVICE_DT_GET(DT_PARENT(DT_ALIAS(adc_alias))),      \\\n    .channel_id = DT_REG_ADDR(DT_ALIAS(adc_alias)),            \\\n    ADC_CHANNEL_CFG_FROM_DT_NODE(DT_ALIAS(adc_alias))          \\\n}                                                            \\\n\n/* Intialize the ADC struct to store all the DT parameters */\nstatic const struct adc_dt_spec adc_vadc = ADC_DT_SPEC_GET_BY_ALIAS(vadc);\n\n/* Check that the ADC interface is ready */\nif (!device_is_ready(adc_vadc.dev)) {\n    LOG_ERR(\"ADC controller device(s) not ready\");\n    return -1;\n}\n\n/* Configure the ADC channel */\nerr = adc_channel_setup_dt(&adc_vadc);\nif (err &lt; 0) {\n    LOG_ERR(\"Could not setup ADC channel (%d)\", err);\n    return err;\n}",
    "crumbs": [
      "Learning Modules",
      "Analog-to-Digital Conversion (ADC)"
    ]
  },
  {
    "objectID": "slides/zephyr-adc.html#reading-data-from-the-adc-buffer",
    "href": "slides/zephyr-adc.html#reading-data-from-the-adc-buffer",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Reading Data from the ADC Buffer",
    "text": "Reading Data from the ADC Buffer\n\nData are stored in a DMA buffer (separate from any CPU activity)\nThe kernel must copy the data from the DMA buffer to a kernel-accessible buffer.\nAn adc_sequence struct is used to store the buffer and buffer size.\n\n// Note that the buffer must be int16_t (16-bit integer) to store the ADC data\nint16_t buf;\n\nstruct adc_sequence sequence = {\n    .buffer = &buf,\n    .buffer_size = sizeof(buf), // bytes\n};\n\nReading the ADC buffer requires:\n\nInitializing the ADC to make a measurement (each time you need to make a measurement).\nRead the resultant data and store it in the buffer (in the adc_sequence struct).\n\nLOG_INF(\"Measuring %s (channel %d)... \", adc_vadc.dev-&gt;name, adc_vadc.channel_id);\n\n(void)adc_sequence_init_dt(&adc_vadc, &sequence);\n\nint ret;\nret = adc_read(adc_vadc.dev, &sequence);\nif (ret &lt; 0) {\n    LOG_ERR(\"Could not read (%d)\", ret);\n} else {\n    LOG_DBG(\"Raw ADC Buffer: %d\", buf);\n}",
    "crumbs": [
      "Learning Modules",
      "Analog-to-Digital Conversion (ADC)"
    ]
  },
  {
    "objectID": "slides/zephyr-adc.html#converting-the-adc-buffer-to-millivolts",
    "href": "slides/zephyr-adc.html#converting-the-adc-buffer-to-millivolts",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Converting the ADC Buffer to Millivolts",
    "text": "Converting the ADC Buffer to Millivolts\n\nThe ADC buffer yields a 16-bit integer, but the ADC was set to 12-bits in the DT.\nConverting the ADC buffer data to actual voltages requires scaling the ADC buffer data by the reference voltage and the gain factor.\n\nint32_t val_mv;  //note that adc_raw_to_millivolts_dt() takes a int32_t* to modify the value in place\nval_mv = buf;  // val_mv is now the raw ADC value\nret = adc_raw_to_millivolts_dt(&adc_vadc, &val_mv); // remember that the vadc struct containts all the DT parameters\n// val_mv now contains the ADC value in millivolts\n// add in some error checking\nif (ret &lt; 0) {\n    LOG_ERR(\"Buffer cannot be converted to mV; returning raw buffer value.\");\n} else {\n    LOG_INF(\"ADC Value (mV): %d\", val_mv);\n}",
    "crumbs": [
      "Learning Modules",
      "Analog-to-Digital Conversion (ADC)"
    ]
  },
  {
    "objectID": "slides/zephyr-adc.html#reading-multiple-samples-at-specified-intervals",
    "href": "slides/zephyr-adc.html#reading-multiple-samples-at-specified-intervals",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Reading Multiple Samples at Specified Intervals",
    "text": "Reading Multiple Samples at Specified Intervals\n\nADC sequence can be configured to perform multiple measurements (extra_samplings) in a single sequence.\n\nThe buffering of multiple data points per acquisition can be useful for sampling data at a fixed sampling rate without hitting the kernel too often with a kernel-based timer.\n\nThe ADC can be configured to execute a callback function after each sample is collected.\nTo enable the extra samples, you need to add an optional adc_sequence_options struct to the adc_sequence struct. The adc_sequence_options struct contains the members shown below.\n\n\n\n\n\n\n\n\nCaution\n\n\n\nBe careful in how you calculate the buffer size for your array, depending on the scope of the array.\n\n\nstruct adc_sequence_options options = {\n        .extra_samplings = BUFFER_ARRAY_LEN - 1,  // -1 b/c first sample is already in the buffer\n        .interval_us = 100,  // 100 us between samples\n        // .callback = NULL,  // called after each sample is collected\n};\n\nstruct adc_sequence sequence = {\n        .options = &options,  // add the options to the sequence\n        .buffer = &buf,  // buf is now a pointer to the first index of an array\n        .buffer_size = sizeof(buf),  // need to specify the size of the buffer array in bytes\n\n        /*  If the buffer is not global or local in scope, the buffer (array) name will just be a pointer to \n            the first element of the array!  The buffer_size will need to be calculated as the product of the \n            size (in bytes) of this first index and the length of the array (number of indices in the array)\n\n        .buffer_size = BUFFER_ARRAY_LEN * sizeof(buf),  // non-global/local array scope\n        */\n\n};",
    "crumbs": [
      "Learning Modules",
      "Analog-to-Digital Conversion (ADC)"
    ]
  },
  {
    "objectID": "slides/zephyr-adc.html#adc-acquisition-time",
    "href": "slides/zephyr-adc.html#adc-acquisition-time",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "ADC Acquisition Time",
    "text": "ADC Acquisition Time\n\nAcquisition time for a single sample is specified in the DT ADC node:\n\nzephyr,acquisition-time = &lt;ADC_ACQ_TIME(ADC_ACQ_TIME_MICROSECONDS, 40)&gt;; \n\nThere are only a discrete number of valid acquisition times (TACQ):\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe acquisition time is not absolutely accurate and can dependent on many system factors, especially when dependent on the kernel counters.\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf you do not specify a sampling interval (interval_us) in the adc_sequence_options struct, the ADC will sample sequencial samples at the acquisition time.",
    "crumbs": [
      "Learning Modules",
      "Analog-to-Digital Conversion (ADC)"
    ]
  },
  {
    "objectID": "slides/zephyr-adc.html#asynchronous-adc",
    "href": "slides/zephyr-adc.html#asynchronous-adc",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Asynchronous ADC",
    "text": "Asynchronous ADC\n\nadc_read() is blocking, meaning that your kernel thread will wait for the ADC to complete before continuing.\n\nTimers and interrupts can be used to perform other tasks while the ADC is running.\nInterrupting threads can come at the expense of the acquisition time accuracy of the ADC.\n\nIf you want to perform other tasks while the ADC is running, you can use the asynchronous ADC API.\n\nThis functionality needs to be enabled in the prj.conf file: CONFIG_ADC_ASYNC=y.\nadc_read_async() is the asynchronous version of adc_read().\n\nThe return code for adc_read_async() is immediate and indicates whether the ADC sequence was started successfully. (It is not the returned enumerations from the callback function described on the next slide.)",
    "crumbs": [
      "Learning Modules",
      "Analog-to-Digital Conversion (ADC)"
    ]
  },
  {
    "objectID": "slides/zephyr-adc.html#asynchronous-adc-callback",
    "href": "slides/zephyr-adc.html#asynchronous-adc-callback",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Asynchronous ADC Callback",
    "text": "Asynchronous ADC Callback\n\nUse a adc_sequence_callback function to handle the ADC data after each sample is read.\nThere are defined ADC action enumerations that can be returned by the callback to signal to the async read function how to handle progression through the sequence:\n\nADC_ACTION_CONTINUE: The sequence should be continued normally.\nADC_ACTION_REPEAT: New samples or sample should be read from the ADC and written in the same place as the recent ones.\nADC_ACTION_FINISH: The sequence should be terminated.\n\nThese enumerated values should be returned by the callback function to signal how to proceed.\n\n\nAsync ADC k_poll Signal\n\nThe asynchronous ADC API uses a k_poll signal to notify the kernel thread when the ADC sequence is complete.\nThe signal must be initialized and passed to the adc_read_async() function.\n\nstruct k_poll_signal adc_signal;\nstruct k_poll_event  evt = K_POLL_EVENT_INITIALIZER(\n                                K_POLL_TYPE_SIGNAL,\n                                K_POLL_MODE_NOTIFY_ONLY,\n                                &adc_signal);\nk_poll_signal_init(&adc_signal);    \n\nadc_read_async(adc_dev, &sequence, &adc_signal);\nYou can then wait/test for the k_poll event to be signaled in your thread:\nk_poll(&evt, 1, K_FOREVER);  // wait forever for the event\nif (evt.state == K_POLL_STATE_SIGNALED) {\n    // ADC sequence is complete; process data\n}\nk_poll_signal_reset(&adc_signal);  // reset the signal for next use\n\n\n\n\n\n\nNote\n\n\n\nNote that k_poll events/signals are similar to kernel events, but tend to be used for more specific use-cases (e.g., one thread waiting on a signal from another thread or peripheral).\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhat happens if you call adc_read_async() again before the previous sequence is complete?",
    "crumbs": [
      "Learning Modules",
      "Analog-to-Digital Conversion (ADC)"
    ]
  },
  {
    "objectID": "slides/zephyr-adc.html#logging-arrays",
    "href": "slides/zephyr-adc.html#logging-arrays",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Logging Arrays",
    "text": "Logging Arrays\n\nLogging the values in an array to the serial terminal can be done using the LOG_HEXDUMP_INF() function. This function takes a pointer to the array, the size of the array, and the number of bytes to display per line. The function will display the array in hexadecimal format.\n\n\n\n\n\n\n\nNote\n\n\n\nRemember that these HEX values are storing data in twos complement.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe logging module can also require non-trivial amounts of memory. Immediate / deferred / optimized logging configurations can significantly impact the stack usage.",
    "crumbs": [
      "Learning Modules",
      "Analog-to-Digital Conversion (ADC)"
    ]
  },
  {
    "objectID": "slides/zephyr-adc.html#resources",
    "href": "slides/zephyr-adc.html#resources",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Resources",
    "text": "Resources\n\nNordic DevAcademy: ADC\nZephyr Docs: ADC\nnRF52 ADC Examples",
    "crumbs": [
      "Learning Modules",
      "Analog-to-Digital Conversion (ADC)"
    ]
  },
  {
    "objectID": "slides/zephyr-adc-slides.html#introduction",
    "href": "slides/zephyr-adc-slides.html#introduction",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Introduction",
    "text": "Introduction\n\nThe nRF52833 uses a Sucessive Approximation ADC (SAADC).\nThe SAADC is a differential ADC.\nThat one SADDC is multiplexed to 8 channels (GPIO pins)."
  },
  {
    "objectID": "slides/zephyr-adc-slides.html#how-does-an-saadc-work",
    "href": "slides/zephyr-adc-slides.html#how-does-an-saadc-work",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "How does an SAADC work?",
    "text": "How does an SAADC work?\n\nNordic DevAcademy: SAADC"
  },
  {
    "objectID": "slides/zephyr-adc-slides.html#prj.conf",
    "href": "slides/zephyr-adc-slides.html#prj.conf",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "prj.conf",
    "text": "prj.conf\nCONFIG_ADC=y"
  },
  {
    "objectID": "slides/zephyr-adc-slides.html#devicetree-overlay",
    "href": "slides/zephyr-adc-slides.html#devicetree-overlay",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Devicetree Overlay",
    "text": "Devicetree Overlay\n    // This is the root level of the DT\n    / {\n        zephyr,user {\n            io-channels = &lt;&adc 0&gt;; // need to \"activate\" these channels for IO usage\n        };\n        aliases {\n            vadc = &vadc;\n        }\n    }\n\n    // This is modifying the existing ADC node in the DT\n    &adc {\n        #address-cells = &lt;1&gt;;\n        #size-cells = &lt;0&gt;;\n\n        vadc: channel@0 {\n            reg = &lt;0&gt;;  // channel number\n            zephyr,reference = \"ADC_REF_INTERNAL\";  // voltage ref for SA (0.6 V)\n            zephyr,gain = \"ADC_GAIN_1_5\"; // gain factor to scale ref voltage (1/gain)\n            zephyr,acquisition-time = &lt;ADC_ACQ_TIME_DEFAULT&gt;;\n            zephyr,input-positive = &lt;NRF_SAADC_AIN0&gt;; // P0.02\n            zephyr,resolution = &lt;12&gt;;  // bit depth\n        };\n        status = \"okay\"; // enable the ADC\n    };"
  },
  {
    "objectID": "slides/zephyr-adc-slides.html#how-digital-output-is-calculated",
    "href": "slides/zephyr-adc-slides.html#how-digital-output-is-calculated",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "How Digital Output is Calculated",
    "text": "How Digital Output is Calculated\n\n\n\n\n\n\n\nNote\n\n\nRESULT is stored as 16-bit 2’s complement values."
  },
  {
    "objectID": "slides/zephyr-adc-slides.html#reference-voltage",
    "href": "slides/zephyr-adc-slides.html#reference-voltage",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Reference Voltage",
    "text": "Reference Voltage\n\nOnly ADC_REF_INTERNAL (0.6 V) and ADC_REF_VDD_1_4 are valid on the nRF52833.\nWhen using VDD (3.0 V) as a reference, you need to also specify the nominal reference voltage in the Devicetree: e.g., zephyr,vref-mv = &lt;750&gt;; (3.0 V / 4)\nADC_REF_INTERNAL is based on a diode threshold voltage and is more stable.\nADC_REF_VDD_1_4 can drift with fluctuations in VDD (which can be a good thing)."
  },
  {
    "objectID": "slides/zephyr-adc-slides.html#main.c",
    "href": "slides/zephyr-adc-slides.html#main.c",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "main.c",
    "text": "main.c\n/* Load the ADC library that you ennabled in prj.conf */\n#include &lt;zephyr/drivers/adc.h&gt; \n\n/* Define some macros to use some Zephyr macros to help read the DT\nconfiguration based on the ADC channel alias (I have no idea why this\nmacro is not available in adc.h) */\n#define ADC_DT_SPEC_GET_BY_ALIAS(adc_alias)                    \\\n{                                                            \\\n    .dev = DEVICE_DT_GET(DT_PARENT(DT_ALIAS(adc_alias))),      \\\n    .channel_id = DT_REG_ADDR(DT_ALIAS(adc_alias)),            \\\n    ADC_CHANNEL_CFG_FROM_DT_NODE(DT_ALIAS(adc_alias))          \\\n}                                                            \\\n\n/* Intialize the ADC struct to store all the DT parameters */\nstatic const struct adc_dt_spec adc_vadc = ADC_DT_SPEC_GET_BY_ALIAS(vadc);\n\n/* Check that the ADC interface is ready */\nif (!device_is_ready(adc_vadc.dev)) {\n    LOG_ERR(\"ADC controller device(s) not ready\");\n    return -1;\n}\n\n/* Configure the ADC channel */\nerr = adc_channel_setup_dt(&adc_vadc);\nif (err &lt; 0) {\n    LOG_ERR(\"Could not setup ADC channel (%d)\", err);\n    return err;\n}"
  },
  {
    "objectID": "slides/zephyr-adc-slides.html#reading-data-from-the-adc-buffer",
    "href": "slides/zephyr-adc-slides.html#reading-data-from-the-adc-buffer",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Reading Data from the ADC Buffer",
    "text": "Reading Data from the ADC Buffer\n\nData are stored in a DMA buffer (separate from any CPU activity)\nThe kernel must copy the data from the DMA buffer to a kernel-accessible buffer.\nAn adc_sequence struct is used to store the buffer and buffer size.\n\n// Note that the buffer must be int16_t (16-bit integer) to store the ADC data\nint16_t buf;\n\nstruct adc_sequence sequence = {\n    .buffer = &buf,\n    .buffer_size = sizeof(buf), // bytes\n};"
  },
  {
    "objectID": "slides/zephyr-adc-slides.html#converting-the-adc-buffer-to-millivolts",
    "href": "slides/zephyr-adc-slides.html#converting-the-adc-buffer-to-millivolts",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Converting the ADC Buffer to Millivolts",
    "text": "Converting the ADC Buffer to Millivolts\n\nThe ADC buffer yields a 16-bit integer, but the ADC was set to 12-bits in the DT.\nConverting the ADC buffer data to actual voltages requires scaling the ADC buffer data by the reference voltage and the gain factor.\n\nint32_t val_mv;  //note that adc_raw_to_millivolts_dt() takes a int32_t* to modify the value in place\nval_mv = buf;  // val_mv is now the raw ADC value\nret = adc_raw_to_millivolts_dt(&adc_vadc, &val_mv); // remember that the vadc struct containts all the DT parameters\n// val_mv now contains the ADC value in millivolts\n// add in some error checking\nif (ret &lt; 0) {\n    LOG_ERR(\"Buffer cannot be converted to mV; returning raw buffer value.\");\n} else {\n    LOG_INF(\"ADC Value (mV): %d\", val_mv);\n}"
  },
  {
    "objectID": "slides/zephyr-adc-slides.html#reading-multiple-samples-at-specified-intervals",
    "href": "slides/zephyr-adc-slides.html#reading-multiple-samples-at-specified-intervals",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Reading Multiple Samples at Specified Intervals",
    "text": "Reading Multiple Samples at Specified Intervals\n\nADC sequence can be configured to perform multiple measurements (extra_samplings) in a single sequence.\n\nThe buffering of multiple data points per acquisition can be useful for sampling data at a fixed sampling rate without hitting the kernel too often with a kernel-based timer.\n\nThe ADC can be configured to execute a callback function after each sample is collected.\nTo enable the extra samples, you need to add an optional adc_sequence_options struct to the adc_sequence struct. The adc_sequence_options struct contains the members shown below."
  },
  {
    "objectID": "slides/zephyr-adc-slides.html#adc-acquisition-time",
    "href": "slides/zephyr-adc-slides.html#adc-acquisition-time",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "ADC Acquisition Time",
    "text": "ADC Acquisition Time\n\nAcquisition time for a single sample is specified in the DT ADC node:\n\nzephyr,acquisition-time = &lt;ADC_ACQ_TIME(ADC_ACQ_TIME_MICROSECONDS, 40)&gt;; \n\nThere are only a discrete number of valid acquisition times (TACQ):\n\n\n\n\n\n\n\n\nWarning\n\n\nThe acquisition time is not absolutely accurate and can dependent on many system factors, especially when dependent on the kernel counters.\n\n\n\n\n\n\n\n\n\nNote\n\n\nIf you do not specify a sampling interval (interval_us) in the adc_sequence_options struct, the ADC will sample sequencial samples at the acquisition time."
  },
  {
    "objectID": "slides/zephyr-adc-slides.html#asynchronous-adc",
    "href": "slides/zephyr-adc-slides.html#asynchronous-adc",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Asynchronous ADC",
    "text": "Asynchronous ADC\n\nadc_read() is blocking, meaning that your kernel thread will wait for the ADC to complete before continuing.\n\nTimers and interrupts can be used to perform other tasks while the ADC is running.\nInterrupting threads can come at the expense of the acquisition time accuracy of the ADC.\n\nIf you want to perform other tasks while the ADC is running, you can use the asynchronous ADC API.\n\nThis functionality needs to be enabled in the prj.conf file: CONFIG_ADC_ASYNC=y.\nadc_read_async() is the asynchronous version of adc_read().\n\nThe return code for adc_read_async() is immediate and indicates whether the ADC sequence was started successfully. (It is not the returned enumerations from the callback function described on the next slide.)"
  },
  {
    "objectID": "slides/zephyr-adc-slides.html#asynchronous-adc-callback",
    "href": "slides/zephyr-adc-slides.html#asynchronous-adc-callback",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Asynchronous ADC Callback",
    "text": "Asynchronous ADC Callback\n\nUse a adc_sequence_callback function to handle the ADC data after each sample is read.\nThere are defined ADC action enumerations that can be returned by the callback to signal to the async read function how to handle progression through the sequence:\n\nADC_ACTION_CONTINUE: The sequence should be continued normally.\nADC_ACTION_REPEAT: New samples or sample should be read from the ADC and written in the same place as the recent ones.\nADC_ACTION_FINISH: The sequence should be terminated.\n\nThese enumerated values should be returned by the callback function to signal how to proceed.\n\nAsync ADC k_poll Signal\n\nThe asynchronous ADC API uses a k_poll signal to notify the kernel thread when the ADC sequence is complete.\nThe signal must be initialized and passed to the adc_read_async() function.\n\nstruct k_poll_signal adc_signal;\nstruct k_poll_event  evt = K_POLL_EVENT_INITIALIZER(\n                                K_POLL_TYPE_SIGNAL,\n                                K_POLL_MODE_NOTIFY_ONLY,\n                                &adc_signal);\nk_poll_signal_init(&adc_signal);    \n\nadc_read_async(adc_dev, &sequence, &adc_signal);\nYou can then wait/test for the k_poll event to be signaled in your thread:\nk_poll(&evt, 1, K_FOREVER);  // wait forever for the event\nif (evt.state == K_POLL_STATE_SIGNALED) {\n    // ADC sequence is complete; process data\n}\nk_poll_signal_reset(&adc_signal);  // reset the signal for next use\n\n\n\n\n\n\nNote\n\n\nNote that k_poll events/signals are similar to kernel events, but tend to be used for more specific use-cases (e.g., one thread waiting on a signal from another thread or peripheral).\n\n\n\n\n\n\n\n\n\nTip\n\n\nWhat happens if you call adc_read_async() again before the previous sequence is complete?"
  },
  {
    "objectID": "slides/zephyr-adc-slides.html#logging-arrays",
    "href": "slides/zephyr-adc-slides.html#logging-arrays",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Logging Arrays",
    "text": "Logging Arrays\n\nLogging the values in an array to the serial terminal can be done using the LOG_HEXDUMP_INF() function. This function takes a pointer to the array, the size of the array, and the number of bytes to display per line. The function will display the array in hexadecimal format.\n\n\n\n\n\n\n\nNote\n\n\nRemember that these HEX values are storing data in twos complement.\n\n\n\n\n\n\n\n\n\nWarning\n\n\nThe logging module can also require non-trivial amounts of memory. Immediate / deferred / optimized logging configurations can significantly impact the stack usage."
  },
  {
    "objectID": "slides/zephyr-adc-slides.html#resources",
    "href": "slides/zephyr-adc-slides.html#resources",
    "title": "Zephyr: Analog-to-Digital Conversion",
    "section": "Resources",
    "text": "Resources\n\nNordic DevAcademy: ADC\nZephyr Docs: ADC\nnRF52 ADC Examples"
  },
  {
    "objectID": "slides/zephyr-threads-events.html",
    "href": "slides/zephyr-threads-events.html",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "",
    "text": "Threads are the basic unit of execution in Zephyr.\nThreads are scheduled by the kernel.\nThreads can be in one of three states:\n\nReady: The thread is ready to run.\nRunning: The thread is currently running.\nBlocked: The thread is waiting for an event to occur.",
    "crumbs": [
      "Learning Modules",
      "Threads and Kernel Events"
    ]
  },
  {
    "objectID": "slides/zephyr-threads-events.html#threads",
    "href": "slides/zephyr-threads-events.html#threads",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "",
    "text": "Threads are the basic unit of execution in Zephyr.\nThreads are scheduled by the kernel.\nThreads can be in one of three states:\n\nReady: The thread is ready to run.\nRunning: The thread is currently running.\nBlocked: The thread is waiting for an event to occur.",
    "crumbs": [
      "Learning Modules",
      "Threads and Kernel Events"
    ]
  },
  {
    "objectID": "slides/zephyr-threads-events.html#weve-already-used-threads",
    "href": "slides/zephyr-threads-events.html#weve-already-used-threads",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "We’ve Already Used Threads",
    "text": "We’ve Already Used Threads\n\nMain thread\nKernel timer threads\n\nBut we can define our own threads for a variety of purposes!\n\nWait for a task to complete, then do something else.\nExample: Wait for data to save to an SD card, then do something else, but don’t want the kernel to wait.",
    "crumbs": [
      "Learning Modules",
      "Threads and Kernel Events"
    ]
  },
  {
    "objectID": "slides/zephyr-threads-events.html#example-use-case-heartbeat-led-toggle-at-25-duty-cycle",
    "href": "slides/zephyr-threads-events.html#example-use-case-heartbeat-led-toggle-at-25-duty-cycle",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "Example Use Case: Heartbeat LED Toggle at 25% Duty Cycle",
    "text": "Example Use Case: Heartbeat LED Toggle at 25% Duty Cycle\n\nThis is not as easy to implement with a single kernel timer.\nBut we can use a thread to toggle the LED at 25% duty cycle and not hit the kernel to do so:\n\n/* 1024 byte stack, handler, NULL, NULL, NULL, priority 5, no time slice, no delay */\nK_THREAD_DEFINE(heartbeat_thread_id, 1024, heartbeat_thread, NULL, NULL, NULL, 5, 0, 0);\n\nextern void heartbeat_thread(void *, void *, void *) {\n\n    while (1) {\n        k_msleep(250);  // scheduler can run other tasks now\n        gpio_pin_toggle_dt(&heartbeat_led);\n        k_msleep(750); // scheduler can run other tasks now\n        gpio_pin_toggle_dt(&heartbeat_led);\n    } \n\n}",
    "crumbs": [
      "Learning Modules",
      "Threads and Kernel Events"
    ]
  },
  {
    "objectID": "slides/zephyr-threads-events.html#how-to-suspendresume-threads",
    "href": "slides/zephyr-threads-events.html#how-to-suspendresume-threads",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "How to Suspend/Resume Threads",
    "text": "How to Suspend/Resume Threads\nk_thread_suspend(heartbeat_thread_id);\nk_thread_resume(heartbeat_thread_id);",
    "crumbs": [
      "Learning Modules",
      "Threads and Kernel Events"
    ]
  },
  {
    "objectID": "slides/zephyr-threads-events.html#threads-vs.-timers",
    "href": "slides/zephyr-threads-events.html#threads-vs.-timers",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "Threads vs. Timers",
    "text": "Threads vs. Timers\n\nThe thread can have blocking calls (e.g., k_msleep) without blocking other threads.\nThe scheduler can run other threads while this thread is sleeping (or yields).\nThe scheduler can preempt the thread at any time with higher priority tasks (e.g., ISR callbacks, higher-priority threads).\nNo need for a separate handler function.\nMore difficult to start/stop/reset than a timer.\nNeed explicitly allocated stack space.\nDifficult to coordinate high-accuracy timing with other tasks/threads.",
    "crumbs": [
      "Learning Modules",
      "Threads and Kernel Events"
    ]
  },
  {
    "objectID": "slides/zephyr-threads-events.html#kernel-events",
    "href": "slides/zephyr-threads-events.html#kernel-events",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "Kernel Events",
    "text": "Kernel Events\n\nKernel events can be used to indicate that “something” has happened, which may dictate the function of the state machine.\n\nButton press\nSensor crossing a threshold\nTimer expiring\n\nEnabled in prj.conf with CONFIG_EVENTS=y.",
    "crumbs": [
      "Learning Modules",
      "Threads and Kernel Events"
    ]
  },
  {
    "objectID": "slides/zephyr-threads-events.html#kernel-event-bit-arrays",
    "href": "slides/zephyr-threads-events.html#kernel-event-bit-arrays",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "Kernel Event Bit Arrays",
    "text": "Kernel Event Bit Arrays\n\nKernel events are stored in a bit array (an array, where each bit (0/1) indicates (False/True) if an event has occured).\nWhen an event occurs, it is posted (k_event_post).\nA state machine can wait (k_event_wait) for an event (or events) to occur.\nEvents can be cleared (k_event_clear) after they are processed.",
    "crumbs": [
      "Learning Modules",
      "Threads and Kernel Events"
    ]
  },
  {
    "objectID": "slides/zephyr-threads-events.html#why-kernel-events-over-boolean-variables",
    "href": "slides/zephyr-threads-events.html#why-kernel-events-over-boolean-variables",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "Why Kernel Events over Boolean Variables?",
    "text": "Why Kernel Events over Boolean Variables?\n\nConsume less memory.\nEasier to pass between threads / functions.\nCan wait for multiple events to occur without having to conditionally test for them.",
    "crumbs": [
      "Learning Modules",
      "Threads and Kernel Events"
    ]
  },
  {
    "objectID": "slides/zephyr-threads-events.html#how-to-define-kernel-events",
    "href": "slides/zephyr-threads-events.html#how-to-define-kernel-events",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "How to Define Kernel Events",
    "text": "How to Define Kernel Events\n\nKernel events are defined in a k_event structure.\n\nK_EVENT_DEFINE(temp_events);\n\n#define TEMP_TOO_HIGH_EVENT BIT(0)\n#define TEMP_TOO_LOW_EVENT BIT(1)\n\n// somewhere in your code, you can post an event\n\nk_event_post(&temp_events, TEMP_TOO_HIGH_EVENT);",
    "crumbs": [
      "Learning Modules",
      "Threads and Kernel Events"
    ]
  },
  {
    "objectID": "slides/zephyr-threads-events.html#waiting-for-events",
    "href": "slides/zephyr-threads-events.html#waiting-for-events",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "Waiting for Events",
    "text": "Waiting for Events\n\nWith kernel events, we can now implement a thread that waits for an event to occur and then changes the state of the state machine.\nThreads are started when your firmware is initialized; it does not need to be “called” (like a function).\n\n/* 1024 byte stack, handler, NULL, NULL, NULL, priority 5, no time slice, no delay */\nK_THREAD_DEFINE(temp_too_high_thread_id, 1024, temp_too_high_thread, NULL, NULL, NULL, 5, 0, 0);\n\nextern void temp_too_high_thread(void *, void *, void *) {\n\n    // need to loop to keep the thread running after the first error occurs\n    while (1) {\n        \n        /* &temp_events is a pointer to an event bit array\n           0xF is an example of a bit mask of events in the array to wait for - any, not all\n           true clears all of the events that may have previously been posted before waiting\n           K_FOREVER means wait indefinitely (this could be a finite period of time instead) \n        */\n        uint32_t events = k_event_wait(&temp_events, 0xF, true, K_FOREVER);\n        // can also define the bit mask as a logical operation of the individual bits\n        // uint32_t events = k_event_wait(&temp_events, TEMP_TOO_HIGH_EVENT | TEMP_TOO_LOW EVENT, true, K_FOREVER);\n        // events is an int representation of the  bit mask of the events that were posted\n\n        // if you want to wait for **ALL** events in the mask, use\n        // k_event_wait_all() instead of k_event_wait()\n\n        LOG_INF(\"Temperature Event Posted: %d\", events); // bit array mask output as an int\n\n        shut_down_system(); // do something in response to the temperature event, like change states\n    }\n}",
    "crumbs": [
      "Learning Modules",
      "Threads and Kernel Events"
    ]
  },
  {
    "objectID": "slides/zephyr-threads-events.html#resources",
    "href": "slides/zephyr-threads-events.html#resources",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "Resources",
    "text": "Resources\n\nNordic DevAcademy: Zephyr RTOS Advanced\nZephyr Documentation: Events",
    "crumbs": [
      "Learning Modules",
      "Threads and Kernel Events"
    ]
  },
  {
    "objectID": "slides/zephyr-threads-events-slides.html#threads",
    "href": "slides/zephyr-threads-events-slides.html#threads",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "Threads",
    "text": "Threads\n\nThreads are the basic unit of execution in Zephyr.\nThreads are scheduled by the kernel.\nThreads can be in one of three states:\n\nReady: The thread is ready to run.\nRunning: The thread is currently running.\nBlocked: The thread is waiting for an event to occur."
  },
  {
    "objectID": "slides/zephyr-threads-events-slides.html#weve-already-used-threads",
    "href": "slides/zephyr-threads-events-slides.html#weve-already-used-threads",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "We’ve Already Used Threads",
    "text": "We’ve Already Used Threads\n\nMain thread\nKernel timer threads\n\nBut we can define our own threads for a variety of purposes!\n\nWait for a task to complete, then do something else.\nExample: Wait for data to save to an SD card, then do something else, but don’t want the kernel to wait."
  },
  {
    "objectID": "slides/zephyr-threads-events-slides.html#example-use-case-heartbeat-led-toggle-at-25-duty-cycle",
    "href": "slides/zephyr-threads-events-slides.html#example-use-case-heartbeat-led-toggle-at-25-duty-cycle",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "Example Use Case: Heartbeat LED Toggle at 25% Duty Cycle",
    "text": "Example Use Case: Heartbeat LED Toggle at 25% Duty Cycle\n\nThis is not as easy to implement with a single kernel timer.\nBut we can use a thread to toggle the LED at 25% duty cycle and not hit the kernel to do so:\n\n/* 1024 byte stack, handler, NULL, NULL, NULL, priority 5, no time slice, no delay */\nK_THREAD_DEFINE(heartbeat_thread_id, 1024, heartbeat_thread, NULL, NULL, NULL, 5, 0, 0);\n\nextern void heartbeat_thread(void *, void *, void *) {\n\n    while (1) {\n        k_msleep(250);  // scheduler can run other tasks now\n        gpio_pin_toggle_dt(&heartbeat_led);\n        k_msleep(750); // scheduler can run other tasks now\n        gpio_pin_toggle_dt(&heartbeat_led);\n    } \n\n}"
  },
  {
    "objectID": "slides/zephyr-threads-events-slides.html#how-to-suspendresume-threads",
    "href": "slides/zephyr-threads-events-slides.html#how-to-suspendresume-threads",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "How to Suspend/Resume Threads",
    "text": "How to Suspend/Resume Threads\nk_thread_suspend(heartbeat_thread_id);\nk_thread_resume(heartbeat_thread_id);"
  },
  {
    "objectID": "slides/zephyr-threads-events-slides.html#threads-vs.-timers",
    "href": "slides/zephyr-threads-events-slides.html#threads-vs.-timers",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "Threads vs. Timers",
    "text": "Threads vs. Timers\n\nThe thread can have blocking calls (e.g., k_msleep) without blocking other threads.\nThe scheduler can run other threads while this thread is sleeping (or yields).\nThe scheduler can preempt the thread at any time with higher priority tasks (e.g., ISR callbacks, higher-priority threads).\nNo need for a separate handler function.\nMore difficult to start/stop/reset than a timer.\nNeed explicitly allocated stack space.\nDifficult to coordinate high-accuracy timing with other tasks/threads."
  },
  {
    "objectID": "slides/zephyr-threads-events-slides.html#kernel-events",
    "href": "slides/zephyr-threads-events-slides.html#kernel-events",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "Kernel Events",
    "text": "Kernel Events\n\nKernel events can be used to indicate that “something” has happened, which may dictate the function of the state machine.\n\nButton press\nSensor crossing a threshold\nTimer expiring\n\nEnabled in prj.conf with CONFIG_EVENTS=y."
  },
  {
    "objectID": "slides/zephyr-threads-events-slides.html#kernel-event-bit-arrays",
    "href": "slides/zephyr-threads-events-slides.html#kernel-event-bit-arrays",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "Kernel Event Bit Arrays",
    "text": "Kernel Event Bit Arrays\n\nKernel events are stored in a bit array (an array, where each bit (0/1) indicates (False/True) if an event has occured).\nWhen an event occurs, it is posted (k_event_post).\nA state machine can wait (k_event_wait) for an event (or events) to occur.\nEvents can be cleared (k_event_clear) after they are processed."
  },
  {
    "objectID": "slides/zephyr-threads-events-slides.html#why-kernel-events-over-boolean-variables",
    "href": "slides/zephyr-threads-events-slides.html#why-kernel-events-over-boolean-variables",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "Why Kernel Events over Boolean Variables?",
    "text": "Why Kernel Events over Boolean Variables?\n\nConsume less memory.\nEasier to pass between threads / functions.\nCan wait for multiple events to occur without having to conditionally test for them."
  },
  {
    "objectID": "slides/zephyr-threads-events-slides.html#how-to-define-kernel-events",
    "href": "slides/zephyr-threads-events-slides.html#how-to-define-kernel-events",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "How to Define Kernel Events",
    "text": "How to Define Kernel Events\n\nKernel events are defined in a k_event structure.\n\nK_EVENT_DEFINE(temp_events);\n\n#define TEMP_TOO_HIGH_EVENT BIT(0)\n#define TEMP_TOO_LOW_EVENT BIT(1)\n\n// somewhere in your code, you can post an event\n\nk_event_post(&temp_events, TEMP_TOO_HIGH_EVENT);"
  },
  {
    "objectID": "slides/zephyr-threads-events-slides.html#waiting-for-events",
    "href": "slides/zephyr-threads-events-slides.html#waiting-for-events",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "Waiting for Events",
    "text": "Waiting for Events\n\nWith kernel events, we can now implement a thread that waits for an event to occur and then changes the state of the state machine.\nThreads are started when your firmware is initialized; it does not need to be “called” (like a function).\n\n/* 1024 byte stack, handler, NULL, NULL, NULL, priority 5, no time slice, no delay */\nK_THREAD_DEFINE(temp_too_high_thread_id, 1024, temp_too_high_thread, NULL, NULL, NULL, 5, 0, 0);\n\nextern void temp_too_high_thread(void *, void *, void *) {\n\n    // need to loop to keep the thread running after the first error occurs\n    while (1) {\n        \n        /* &temp_events is a pointer to an event bit array\n           0xF is an example of a bit mask of events in the array to wait for - any, not all\n           true clears all of the events that may have previously been posted before waiting\n           K_FOREVER means wait indefinitely (this could be a finite period of time instead) \n        */\n        uint32_t events = k_event_wait(&temp_events, 0xF, true, K_FOREVER);\n        // can also define the bit mask as a logical operation of the individual bits\n        // uint32_t events = k_event_wait(&temp_events, TEMP_TOO_HIGH_EVENT | TEMP_TOO_LOW EVENT, true, K_FOREVER);\n        // events is an int representation of the  bit mask of the events that were posted\n\n        // if you want to wait for **ALL** events in the mask, use\n        // k_event_wait_all() instead of k_event_wait()\n\n        LOG_INF(\"Temperature Event Posted: %d\", events); // bit array mask output as an int\n\n        shut_down_system(); // do something in response to the temperature event, like change states\n    }\n}"
  },
  {
    "objectID": "slides/zephyr-threads-events-slides.html#resources",
    "href": "slides/zephyr-threads-events-slides.html#resources",
    "title": "Zephyr: Threads and Kernel Events",
    "section": "Resources",
    "text": "Resources\n\nNordic DevAcademy: Zephyr RTOS Advanced\nZephyr Documentation: Events"
  },
  {
    "objectID": "slides/zephyr-serial-communication.html",
    "href": "slides/zephyr-serial-communication.html",
    "title": "Zephyr: Serial Communication",
    "section": "",
    "text": "Send data one bit at a time, sequentially, over a single wire; in contrast to parallel communication, where multiple bits are sent as a whole, on multiple wires.\nCommon examples:\n\nRS-232\nUSB\nSATA/SCSI\nPS/2\nEthernet\nHDMI/DVI\nPCIe (not PCI!)\n\n\n\n\n\n\n\n\n\n\n\nParallel communication can communicate more bits / clock cycle, but serial links can be clocked much faster.\nNo clock skew between bits\nFewer cables / connections (cheaper)\nBetter isolation from noise / interference / crosstalk\n\n\n\n\nUART is an asynchronous serial communication protocol. It is a common peripheral on microcontrollers, and is used to communicate with other devices, such as sensors, over a serial link.\n\n\nStart bit is usually LOW, followed by 8 bits of data.\nA parity bit–conveying an even of odd data stream–can be used for error checking.\n\n\n\n\n\n\n\n\n\n\nRX senses the start bit and then stores the subsequent bits in a shift register (making a “word”).\nThe data baud rate between TX:RX needs to be established between the two devices. This is typically 9600 or 115200 bits/s.\n\n\n\n\n\n\n\n\n\n\nRTS (Request to Send)\nCTS (Clear to Send)\nUART ISRs are triggered by RTS and CTS events.\nHigh-priority event helps avoid missing data, but can cause starvation of other tasks.\nLow-priority event can cause data loss, but allows other tasks to run.\nMulti-threaded RTOS can be much more robust than a single-threaded super-loop system.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWidely-used 2-wire serial communication protocol.\nLimited to short distances.\nSCL: serial clock\nSDA: serial data\nCommon data communication rates: 100, 400, & 1000 kbps\nAccess data using simple read() and write() functions.\nMultiple devices, with unique addresses, can be connected to the same bus.\n\n\n\n\n\n\n\n\n\n\nPrimary/Secondary\nController/Peripheral\nController/Responder\nParent/Child\n\n\n\n\nNordic’s I2C implementation is called TWI (Two-Wire Interface).\n\n\n\n\nUART is a point-to-point protocol, while I2C is a multi-point protocol.\nUART is asynchronous (2-way communication, full duplex), while I2C is synchronous (half duplex, needs CLK).\nBoth are “slow”, but I2C is faster.\nUART is simpler to implement, but I2C is more robust.\n\n\n\n\n\n2-pin superset of I2C (backward compatible)\nLower power and space requirements\nHigher data rates\nDynamic address assignment\n“Hot” peripheral connection\n\n\n\n\n\n\nLike I2C, but allow for full duplex (concurrent send/receive of data).\nNeeds 4 wires:\n\nMOSI: master out, slave in\nMISO: master in, slave out\nSCLK: serial clock\nSS: slave select (LOW to select)\n\nSS instead of device address\n\n\n\n\n\nHigher data speeds than I2C (e.g., SD card)\nMore complicated connectivity scheme for multiple peripherals\n\n\n\n\n\nThe reading of data from sensors is so common that Zephyr provides a common API for accessing them.\nChannels: measurable quantities (e.g., temperature, humidity, acceleration, etc.)\n\n\n\n\n\nFetching data from a sensor is done using sensor_sample_fetch() function. Fetching stores the data in a buffer on the sensor.\nGetting data from the sensor is then done using sensor_sample_get(). Getting reads the data from the buffer and returns it to the user.\n\nA sensor can have multiple channels, and each channel can have multiple samples.\nSensor channels are specified using a sensor_channel enum: sensor_channel\n\nsensor_value struct of 2 ints\n\nint32_t val1: integer part of value\nint32_t val2: fractional part of value\n\n\n\n\n\n\nHelper functions exist to convert values (units, struct -&gt; float, etc.)\nsensor_value_to_float()",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#what-is-serial-communication",
    "href": "slides/zephyr-serial-communication.html#what-is-serial-communication",
    "title": "Zephyr: Serial Communication",
    "section": "",
    "text": "Send data one bit at a time, sequentially, over a single wire; in contrast to parallel communication, where multiple bits are sent as a whole, on multiple wires.\nCommon examples:\n\nRS-232\nUSB\nSATA/SCSI\nPS/2\nEthernet\nHDMI/DVI\nPCIe (not PCI!)",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#why-serial-over-parallel",
    "href": "slides/zephyr-serial-communication.html#why-serial-over-parallel",
    "title": "Zephyr: Serial Communication",
    "section": "",
    "text": "Parallel communication can communicate more bits / clock cycle, but serial links can be clocked much faster.\nNo clock skew between bits\nFewer cables / connections (cheaper)\nBetter isolation from noise / interference / crosstalk",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#universal-asynchronous-receivertransmitter-uart",
    "href": "slides/zephyr-serial-communication.html#universal-asynchronous-receivertransmitter-uart",
    "title": "Zephyr: Serial Communication",
    "section": "",
    "text": "UART is an asynchronous serial communication protocol. It is a common peripheral on microcontrollers, and is used to communicate with other devices, such as sensors, over a serial link.\n\n\nStart bit is usually LOW, followed by 8 bits of data.\nA parity bit–conveying an even of odd data stream–can be used for error checking.",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#txrx-without-flow-control",
    "href": "slides/zephyr-serial-communication.html#txrx-without-flow-control",
    "title": "Zephyr: Serial Communication",
    "section": "",
    "text": "RX senses the start bit and then stores the subsequent bits in a shift register (making a “word”).\nThe data baud rate between TX:RX needs to be established between the two devices. This is typically 9600 or 115200 bits/s.",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#txrx-with-flow-control",
    "href": "slides/zephyr-serial-communication.html#txrx-with-flow-control",
    "title": "Zephyr: Serial Communication",
    "section": "",
    "text": "RTS (Request to Send)\nCTS (Clear to Send)\nUART ISRs are triggered by RTS and CTS events.\nHigh-priority event helps avoid missing data, but can cause starvation of other tasks.\nLow-priority event can cause data loss, but allows other tasks to run.\nMulti-threaded RTOS can be much more robust than a single-threaded super-loop system.",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#inter-integrated-circuit-i2c",
    "href": "slides/zephyr-serial-communication.html#inter-integrated-circuit-i2c",
    "title": "Zephyr: Serial Communication",
    "section": "",
    "text": "Widely-used 2-wire serial communication protocol.\nLimited to short distances.\nSCL: serial clock\nSDA: serial data\nCommon data communication rates: 100, 400, & 1000 kbps\nAccess data using simple read() and write() functions.\nMultiple devices, with unique addresses, can be connected to the same bus.",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#alternative-masterslave-terminology",
    "href": "slides/zephyr-serial-communication.html#alternative-masterslave-terminology",
    "title": "Zephyr: Serial Communication",
    "section": "",
    "text": "Primary/Secondary\nController/Peripheral\nController/Responder\nParent/Child",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#nordic-twi-two-wire-interface",
    "href": "slides/zephyr-serial-communication.html#nordic-twi-two-wire-interface",
    "title": "Zephyr: Serial Communication",
    "section": "",
    "text": "Nordic’s I2C implementation is called TWI (Two-Wire Interface).",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#uart-vs.-i2c",
    "href": "slides/zephyr-serial-communication.html#uart-vs.-i2c",
    "title": "Zephyr: Serial Communication",
    "section": "",
    "text": "UART is a point-to-point protocol, while I2C is a multi-point protocol.\nUART is asynchronous (2-way communication, full duplex), while I2C is synchronous (half duplex, needs CLK).\nBoth are “slow”, but I2C is faster.\nUART is simpler to implement, but I2C is more robust.",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#sensewire-i3c",
    "href": "slides/zephyr-serial-communication.html#sensewire-i3c",
    "title": "Zephyr: Serial Communication",
    "section": "",
    "text": "2-pin superset of I2C (backward compatible)\nLower power and space requirements\nHigher data rates\nDynamic address assignment\n“Hot” peripheral connection",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#serial-passing-interface-spi",
    "href": "slides/zephyr-serial-communication.html#serial-passing-interface-spi",
    "title": "Zephyr: Serial Communication",
    "section": "",
    "text": "Like I2C, but allow for full duplex (concurrent send/receive of data).\nNeeds 4 wires:\n\nMOSI: master out, slave in\nMISO: master in, slave out\nSCLK: serial clock\nSS: slave select (LOW to select)\n\nSS instead of device address",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#i2c-vs.-spi",
    "href": "slides/zephyr-serial-communication.html#i2c-vs.-spi",
    "title": "Zephyr: Serial Communication",
    "section": "",
    "text": "Higher data speeds than I2C (e.g., SD card)\nMore complicated connectivity scheme for multiple peripherals",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#zephyr-sensors",
    "href": "slides/zephyr-serial-communication.html#zephyr-sensors",
    "title": "Zephyr: Serial Communication",
    "section": "",
    "text": "The reading of data from sensors is so common that Zephyr provides a common API for accessing them.\nChannels: measurable quantities (e.g., temperature, humidity, acceleration, etc.)",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#fetching-getting-data",
    "href": "slides/zephyr-serial-communication.html#fetching-getting-data",
    "title": "Zephyr: Serial Communication",
    "section": "",
    "text": "Fetching data from a sensor is done using sensor_sample_fetch() function. Fetching stores the data in a buffer on the sensor.\nGetting data from the sensor is then done using sensor_sample_get(). Getting reads the data from the buffer and returns it to the user.\n\nA sensor can have multiple channels, and each channel can have multiple samples.\nSensor channels are specified using a sensor_channel enum: sensor_channel\n\nsensor_value struct of 2 ints\n\nint32_t val1: integer part of value\nint32_t val2: fractional part of value",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#helper-functions",
    "href": "slides/zephyr-serial-communication.html#helper-functions",
    "title": "Zephyr: Serial Communication",
    "section": "",
    "text": "Helper functions exist to convert values (units, struct -&gt; float, etc.)\nsensor_value_to_float()",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#example-connection-of-mcp9808-temperature-sensor",
    "href": "slides/zephyr-serial-communication.html#example-connection-of-mcp9808-temperature-sensor",
    "title": "Zephyr: Serial Communication",
    "section": "Example Connection of MCP9808 Temperature Sensor",
    "text": "Example Connection of MCP9808 Temperature Sensor\n\n\n\n\n\n\n\nBreakout Board\nDK GPIO Pin\n\n\n\n\nSDA\nP0.26\n\n\nSCL\nP0.27\n\n\nVdd\nVDD\n\n\nGND\nGND\n\n\n\n\n\nMCP9808 Temperature Sensor\n\n\nprf.conf\nCONFIG_SENSOR=y\n\n\nnrf52833dk_nrf52833.overlay\n/* I2C Pin Mapping\nSCK: P0.27\nSDA: P0.26\n*/\n&i2c0 {\n    mcp9808@18{\n        compatible = \"jedec,jc-42.4-temp\";\n        reg = &lt;0x18&gt;;\n        status = \"okay\";\n    };\n\n};",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#main.c",
    "href": "slides/zephyr-serial-communication.html#main.c",
    "title": "Zephyr: Serial Communication",
    "section": "main.c",
    "text": "main.c\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/logging/log.h&gt;\n#include &lt;zephyr/drivers/sensor.h&gt;  // prf.conf -&gt; CONFIG_SENSOR=y\n#define MEASUREMENT_DELAY_MS 1000 \nLOG_MODULE_REGISTER(main, LOG_LEVEL_DBG);\n\nint read_temperature_sensor(const struct device *temp_sensor, float *temperature_degC);\n\n// the microchip,mcp9808 cannot be accessed in the DT by alias\n// instead, have to directly access the node name, with comma replaced by underscore\nconst struct device *const temp_sensor = DEVICE_DT_GET_ONE(jedec_jc_42_4_temp);\n\nstatic float temperature_degC;\n\nint main(void) {\n \n    int ret;\n \n    if (!device_is_ready(temp_sensor)) {\n        LOG_ERR(\"Temperature sensor %s is not ready\", temp_sensor-&gt;name);\n        return -1;\n    }\n    else {\n        LOG_INF(\"Temperature sensor %s is ready\", temp_sensor-&gt;name);\n    }\n    // read the temperature every MEASUREMENT_DELAY_MS\n    while (1) {\n        ret = read_temperature_sensor(temp_sensor, &temperature_degC);\n        if (ret != 0) {\n            LOG_ERR(\"There was a problem reading the temperature sensor (%d)\", ret);\n            return ret;\n        }\n        \n        // make sure CONFIG_CBPRINTF_FP_SUPPORT=y is set in `prf.conf` for float support\n        LOG_INF(\"Temperature: %f\", (double)temperature_degC);\n        k_msleep(MEASUREMENT_DELAY_MS);\n    }\n    return 0;\n}\nint read_temperature_sensor(const struct device *temp_sensor, float *temperature_degC) {\n    /*  Fetch-n-get temperature sensor data\n        INPUTS:\n            temp_sensor (const struct device *) - temperature sensor device\n            temperature_degC (float *) - pointer to store temperature in degrees Celsius\n        RETURNS:\n            0 - success\n            Otherwise, error code\n    */\n    struct sensor_value sensor_vals = {.val1 = 0, .val2 = 0};\n    int err = sensor_sample_fetch(temp_sensor);\n    if (err != 0) {\n        LOG_ERR(\"Temperature sensor fetch(): %d\", err);\n        return err;\n    }\n    else {\n        // sensor channels: https://docs.zephyrproject.org/latest/doxygen/html/group__sensor__interface.html#gaaa1b502bc029b10d7b23b0a25ef4e934\n\n        err = sensor_channel_get(temp_sensor, SENSOR_CHAN_AMBIENT_TEMP, &sensor_vals);\n        if (err != 0) {\n            LOG_ERR(\"Temperature sensor get(): %d\", err);\n            return err;\n        }\n    }\n        \n        // data returned in kPa\n        *temperature_degC = sensor_value_to_float(&sensor_vals);\n        LOG_INF(\"Temperature (deg C): %f\", (double)*temperature_degC);\n        return 0;\n}",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication.html#resources",
    "href": "slides/zephyr-serial-communication.html#resources",
    "title": "Zephyr: Serial Communication",
    "section": "Resources",
    "text": "Resources\n\nWikipedia: Serial Communication\nDevAcademy: UART\nDevAcademy: I2C\nAll About Circuits: Master / Slave Terminology Reexamind\nZephyr: Sensors\nGitHub: Zephyr MPR Sensor Sample",
    "crumbs": [
      "Learning Modules",
      "Serial Communication (UART, I2C, SPI)"
    ]
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#what-is-serial-communication",
    "href": "slides/zephyr-serial-communication-slides.html#what-is-serial-communication",
    "title": "Zephyr: Serial Communication",
    "section": "What is Serial Communication?",
    "text": "What is Serial Communication?\nSend data one bit at a time, sequentially, over a single wire; in contrast to parallel communication, where multiple bits are sent as a whole, on multiple wires.\nCommon examples:\n\nRS-232\nUSB\nSATA/SCSI\nPS/2\nEthernet\nHDMI/DVI\nPCIe (not PCI!)"
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#why-serial-over-parallel",
    "href": "slides/zephyr-serial-communication-slides.html#why-serial-over-parallel",
    "title": "Zephyr: Serial Communication",
    "section": "Why Serial over Parallel?",
    "text": "Why Serial over Parallel?\n\nParallel communication can communicate more bits / clock cycle, but serial links can be clocked much faster.\nNo clock skew between bits\nFewer cables / connections (cheaper)\nBetter isolation from noise / interference / crosstalk"
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#universal-asynchronous-receivertransmitter-uart",
    "href": "slides/zephyr-serial-communication-slides.html#universal-asynchronous-receivertransmitter-uart",
    "title": "Zephyr: Serial Communication",
    "section": "Universal Asynchronous Receiver/Transmitter (UART)",
    "text": "Universal Asynchronous Receiver/Transmitter (UART)\nUART is an asynchronous serial communication protocol. It is a common peripheral on microcontrollers, and is used to communicate with other devices, such as sensors, over a serial link.\n\n\nStart bit is usually LOW, followed by 8 bits of data.\nA parity bit–conveying an even of odd data stream–can be used for error checking."
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#txrx-without-flow-control",
    "href": "slides/zephyr-serial-communication-slides.html#txrx-without-flow-control",
    "title": "Zephyr: Serial Communication",
    "section": "Tx/Rx without Flow Control",
    "text": "Tx/Rx without Flow Control\n\n\nRX senses the start bit and then stores the subsequent bits in a shift register (making a “word”).\nThe data baud rate between TX:RX needs to be established between the two devices. This is typically 9600 or 115200 bits/s."
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#txrx-with-flow-control",
    "href": "slides/zephyr-serial-communication-slides.html#txrx-with-flow-control",
    "title": "Zephyr: Serial Communication",
    "section": "Tx/Rx with Flow Control",
    "text": "Tx/Rx with Flow Control\n\n\nRTS (Request to Send)\nCTS (Clear to Send)\nUART ISRs are triggered by RTS and CTS events.\nHigh-priority event helps avoid missing data, but can cause starvation of other tasks.\nLow-priority event can cause data loss, but allows other tasks to run.\nMulti-threaded RTOS can be much more robust than a single-threaded super-loop system."
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#uart-firmware-api-events",
    "href": "slides/zephyr-serial-communication-slides.html#uart-firmware-api-events",
    "title": "Zephyr: Serial Communication",
    "section": "UART Firmware API Events",
    "text": "UART Firmware API Events"
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#inter-integrated-circuit-i2c",
    "href": "slides/zephyr-serial-communication-slides.html#inter-integrated-circuit-i2c",
    "title": "Zephyr: Serial Communication",
    "section": "Inter-Integrated Circuit (I2C)",
    "text": "Inter-Integrated Circuit (I2C)\n\n\nWidely-used 2-wire serial communication protocol.\nLimited to short distances.\nSCL: serial clock\nSDA: serial data\nCommon data communication rates: 100, 400, & 1000 kbps\nAccess data using simple read() and write() functions.\nMultiple devices, with unique addresses, can be connected to the same bus."
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#alternative-masterslave-terminology",
    "href": "slides/zephyr-serial-communication-slides.html#alternative-masterslave-terminology",
    "title": "Zephyr: Serial Communication",
    "section": "Alternative Master/Slave Terminology",
    "text": "Alternative Master/Slave Terminology\n\n\nPrimary/Secondary\nController/Peripheral\nController/Responder\nParent/Child"
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#nordic-twi-two-wire-interface",
    "href": "slides/zephyr-serial-communication-slides.html#nordic-twi-two-wire-interface",
    "title": "Zephyr: Serial Communication",
    "section": "Nordic TWI (Two-Wire Interface)",
    "text": "Nordic TWI (Two-Wire Interface)\nNordic’s I2C implementation is called TWI (Two-Wire Interface)."
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#uart-vs.-i2c",
    "href": "slides/zephyr-serial-communication-slides.html#uart-vs.-i2c",
    "title": "Zephyr: Serial Communication",
    "section": "UART vs. I2C",
    "text": "UART vs. I2C\n\nUART is a point-to-point protocol, while I2C is a multi-point protocol.\nUART is asynchronous (2-way communication, full duplex), while I2C is synchronous (half duplex, needs CLK).\nBoth are “slow”, but I2C is faster.\nUART is simpler to implement, but I2C is more robust."
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#sensewire-i3c",
    "href": "slides/zephyr-serial-communication-slides.html#sensewire-i3c",
    "title": "Zephyr: Serial Communication",
    "section": "SenseWire (I3C)",
    "text": "SenseWire (I3C)\n\n2-pin superset of I2C (backward compatible)\nLower power and space requirements\nHigher data rates\nDynamic address assignment\n“Hot” peripheral connection"
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#serial-passing-interface-spi",
    "href": "slides/zephyr-serial-communication-slides.html#serial-passing-interface-spi",
    "title": "Zephyr: Serial Communication",
    "section": "Serial Passing Interface (SPI)",
    "text": "Serial Passing Interface (SPI)\n\n\nLike I2C, but allow for full duplex (concurrent send/receive of data).\nNeeds 4 wires:\n\nMOSI: master out, slave in\nMISO: master in, slave out\nSCLK: serial clock\nSS: slave select (LOW to select)\n\nSS instead of device address"
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#i2c-vs.-spi",
    "href": "slides/zephyr-serial-communication-slides.html#i2c-vs.-spi",
    "title": "Zephyr: Serial Communication",
    "section": "I2C vs. SPI",
    "text": "I2C vs. SPI\n\nHigher data speeds than I2C (e.g., SD card)\nMore complicated connectivity scheme for multiple peripherals"
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#zephyr-sensors",
    "href": "slides/zephyr-serial-communication-slides.html#zephyr-sensors",
    "title": "Zephyr: Serial Communication",
    "section": "Zephyr: Sensors",
    "text": "Zephyr: Sensors\n\nThe reading of data from sensors is so common that Zephyr provides a common API for accessing them.\nChannels: measurable quantities (e.g., temperature, humidity, acceleration, etc.)"
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#fetching-getting-data",
    "href": "slides/zephyr-serial-communication-slides.html#fetching-getting-data",
    "title": "Zephyr: Serial Communication",
    "section": "Fetching & Getting Data",
    "text": "Fetching & Getting Data\n\nFetching data from a sensor is done using sensor_sample_fetch() function. Fetching stores the data in a buffer on the sensor.\nGetting data from the sensor is then done using sensor_sample_get(). Getting reads the data from the buffer and returns it to the user.\n\nA sensor can have multiple channels, and each channel can have multiple samples.\nSensor channels are specified using a sensor_channel enum: sensor_channel\n\nsensor_value struct of 2 ints\n\nint32_t val1: integer part of value\nint32_t val2: fractional part of value"
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#helper-functions",
    "href": "slides/zephyr-serial-communication-slides.html#helper-functions",
    "title": "Zephyr: Serial Communication",
    "section": "Helper Functions",
    "text": "Helper Functions\n\nHelper functions exist to convert values (units, struct -&gt; float, etc.)\nsensor_value_to_float()"
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#example-connection-of-mcp9808-temperature-sensor",
    "href": "slides/zephyr-serial-communication-slides.html#example-connection-of-mcp9808-temperature-sensor",
    "title": "Zephyr: Serial Communication",
    "section": "Example Connection of MCP9808 Temperature Sensor",
    "text": "Example Connection of MCP9808 Temperature Sensor\n\n\n\n\n\n\n\nBreakout Board\nDK GPIO Pin\n\n\n\n\nSDA\nP0.26\n\n\nSCL\nP0.27\n\n\nVdd\nVDD\n\n\nGND\nGND\n\n\n\n\nMCP9808 Temperature Sensor"
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#main.c",
    "href": "slides/zephyr-serial-communication-slides.html#main.c",
    "title": "Zephyr: Serial Communication",
    "section": "main.c",
    "text": "main.c\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/logging/log.h&gt;\n#include &lt;zephyr/drivers/sensor.h&gt;  // prf.conf -&gt; CONFIG_SENSOR=y\n#define MEASUREMENT_DELAY_MS 1000 \nLOG_MODULE_REGISTER(main, LOG_LEVEL_DBG);\n\nint read_temperature_sensor(const struct device *temp_sensor, float *temperature_degC);\n\n// the microchip,mcp9808 cannot be accessed in the DT by alias\n// instead, have to directly access the node name, with comma replaced by underscore\nconst struct device *const temp_sensor = DEVICE_DT_GET_ONE(jedec_jc_42_4_temp);\n\nstatic float temperature_degC;\n\nint main(void) {\n \n    int ret;\n \n    if (!device_is_ready(temp_sensor)) {\n        LOG_ERR(\"Temperature sensor %s is not ready\", temp_sensor-&gt;name);\n        return -1;\n    }\n    else {\n        LOG_INF(\"Temperature sensor %s is ready\", temp_sensor-&gt;name);\n    }\n    // read the temperature every MEASUREMENT_DELAY_MS\n    while (1) {\n        ret = read_temperature_sensor(temp_sensor, &temperature_degC);\n        if (ret != 0) {\n            LOG_ERR(\"There was a problem reading the temperature sensor (%d)\", ret);\n            return ret;\n        }\n        \n        // make sure CONFIG_CBPRINTF_FP_SUPPORT=y is set in `prf.conf` for float support\n        LOG_INF(\"Temperature: %f\", (double)temperature_degC);\n        k_msleep(MEASUREMENT_DELAY_MS);\n    }\n    return 0;\n}\nint read_temperature_sensor(const struct device *temp_sensor, float *temperature_degC) {\n    /*  Fetch-n-get temperature sensor data\n        INPUTS:\n            temp_sensor (const struct device *) - temperature sensor device\n            temperature_degC (float *) - pointer to store temperature in degrees Celsius\n        RETURNS:\n            0 - success\n            Otherwise, error code\n    */\n    struct sensor_value sensor_vals = {.val1 = 0, .val2 = 0};\n    int err = sensor_sample_fetch(temp_sensor);\n    if (err != 0) {\n        LOG_ERR(\"Temperature sensor fetch(): %d\", err);\n        return err;\n    }\n    else {\n        // sensor channels: https://docs.zephyrproject.org/latest/doxygen/html/group__sensor__interface.html#gaaa1b502bc029b10d7b23b0a25ef4e934\n\n        err = sensor_channel_get(temp_sensor, SENSOR_CHAN_AMBIENT_TEMP, &sensor_vals);\n        if (err != 0) {\n            LOG_ERR(\"Temperature sensor get(): %d\", err);\n            return err;\n        }\n    }\n        \n        // data returned in kPa\n        *temperature_degC = sensor_value_to_float(&sensor_vals);\n        LOG_INF(\"Temperature (deg C): %f\", (double)*temperature_degC);\n        return 0;\n}"
  },
  {
    "objectID": "slides/zephyr-serial-communication-slides.html#resources",
    "href": "slides/zephyr-serial-communication-slides.html#resources",
    "title": "Zephyr: Serial Communication",
    "section": "Resources",
    "text": "Resources\n\nWikipedia: Serial Communication\nDevAcademy: UART\nDevAcademy: I2C\nAll About Circuits: Master / Slave Terminology Reexamind\nZephyr: Sensors\nGitHub: Zephyr MPR Sensor Sample"
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#timing-of-read-in-main",
    "href": "slides/zephyr-gpio-isr-callbacks.html#timing-of-read-in-main",
    "title": "GPIO / ISR / Callbacks",
    "section": "Timing of read() in main()",
    "text": "Timing of read() in main()\nvoid main() {\n    while (1) {\n        // do stuff\n        k_msleep(1000);\n        sw0_event = command_to_read_digital_pin();\n        if (sw0_event) {\n            // do stuff\n        }\n    }\n} \n\nWhat if you press the button while the code is “sleeping”?\nWhat if “do stuff” is time consuming / blocking?",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#the-phone-call-analogy",
    "href": "slides/zephyr-gpio-isr-callbacks.html#the-phone-call-analogy",
    "title": "GPIO / ISR / Callbacks",
    "section": "The phone call analogy…",
    "text": "The phone call analogy…\n\nTrying to read a button at a specific time is like only checking if you have an incoming phone call at a specific time interval (i.e., no ring).\nInstead, think of the ringing phone as an event trigger that you allow to happen “whenever”.",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#interrupts",
    "href": "slides/zephyr-gpio-isr-callbacks.html#interrupts",
    "title": "GPIO / ISR / Callbacks",
    "section": "Interrupts",
    "text": "Interrupts",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#what-do-you-do-when-the-phone-rings",
    "href": "slides/zephyr-gpio-isr-callbacks.html#what-do-you-do-when-the-phone-rings",
    "title": "GPIO / ISR / Callbacks",
    "section": "What do you do when the phone rings?",
    "text": "What do you do when the phone rings?\n\nYou might not be able to take a 2-hour phone call right when your phone rings, but you can:\n\nAcknowledge that you received the call (e.g., thumbs-up emoji text message)\nAdd an item to your “to do” list (i.e., “queue”) to call the person back when you have time\n\nWhat you do when the phone rings (the interrupt) is captured in a callback function.",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#isr---callback-function",
    "href": "slides/zephyr-gpio-isr-callbacks.html#isr---callback-function",
    "title": "GPIO / ISR / Callbacks",
    "section": "ISR -> Callback Function",
    "text": "ISR -&gt; Callback Function\n\nAn interrupt can be used to call a callback function (“callback” = a function executed in response to an interrupt or event).\nNeed to execute the callback / ISR quickly to not paralyze the rest of main() / other threads from running, otherwise device is paralyzed from acting.\n\nAvoid calculations, significant IO, data Tx/Rx, etc.\nPrefer simple actions, like toggling the state of a Boolean variable or posting an event.\n\nCallback functions can be removed (gpio_remove_callback_dt()) or re-assigned from an ISR.\n\nButton function can change as a function of the state of the system.\nButton can be disabled or re-enabled based on the state of the system.",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#overview",
    "href": "slides/zephyr-gpio-isr-callbacks.html#overview",
    "title": "GPIO / ISR / Callbacks",
    "section": "Overview",
    "text": "Overview\n\nprj.conf - enable GPIO, enable logging libraries\ndevicetree.overlay - define GPIO pin as an input, define callback function\nmain.c - initialize GPIO struct, initialize callback struct, associate callback with GPIO pin, define callback function, test for callback event state in your code",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#devicetree-overlay-gpio-keys",
    "href": "slides/zephyr-gpio-isr-callbacks.html#devicetree-overlay-gpio-keys",
    "title": "GPIO / ISR / Callbacks",
    "section": "Devicetree (overlay): gpio-keys",
    "text": "Devicetree (overlay): gpio-keys\nThe Devicetree is used to separate hardware-specific definitions from the firmware logic. Your development kit has a pre-defined devicetree in Zephyr that can be modified with an overlay file. This overlay file can be:\n\nManually edited (YAML format), or\nEdited/visualized with the nRF DeviceTree extension in VS Code\n\n/ {\n    aliases {\n        sw0: &button0;\n    }\n\n    buttons {\n        compatible = \"gpio-keys\";\n        button0: button_0 {\n            gpios = &lt;&gpio0 8 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)&gt;;\n            label = \"Push button\";\n        };\n    };\n};",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#what-is-active-state",
    "href": "slides/zephyr-gpio-isr-callbacks.html#what-is-active-state",
    "title": "GPIO / ISR / Callbacks",
    "section": "What is “ACTIVE” state?",
    "text": "What is “ACTIVE” state?\n\nGPIO_ACTIVE_LOW - button is active when pulled to low voltage (GND)\nGPIO_ACTIVE_HIGH - button is active when pulled to high voltage (VDD)\n\n\nhttps://docs.nordicsemi.com/bundle/ug_nrf52833_dk/page/UG/dk/hw_buttons_leds.html",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#collecting-gpio-information-from-the-devicetree-into-a-struct",
    "href": "slides/zephyr-gpio-isr-callbacks.html#collecting-gpio-information-from-the-devicetree-into-a-struct",
    "title": "GPIO / ISR / Callbacks",
    "section": "Collecting GPIO Information from the Devicetree into a struct",
    "text": "Collecting GPIO Information from the Devicetree into a struct\n// create this struct before main()\n// initialize GPIO struct\nstatic const struct gpio_dt_spec sw0 = GPIO_DT_SPEC_GET(DT_ALIAS(sw0), gpios);\n\nGPIO_DT_SPEC_GET: macro to get GPIO information from the DT\nDT_ALIAS: reference the pin of interest by an alias (sw0) in the DT\ngpio_dt_spec: struct prototype to store all of the information about this GPIO pin\nsw0: name of the struct that will store the information about the GPIO pin",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#define-callback-function",
    "href": "slides/zephyr-gpio-isr-callbacks.html#define-callback-function",
    "title": "GPIO / ISR / Callbacks",
    "section": "Define Callback Function",
    "text": "Define Callback Function\n// declare callback function\nvoid sw0_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins);\n// initialize GPIO callback struct\nstatic struct gpio_callback sw0_cb;  \n\ngpio_callback: struct prototype is defined in gpio.h\nsw0_cb: name of the struct based on the gpio_callback prototype that will store the information about the callback function\n\n// define callback function\nvoid sw0_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins)\n{\n    sw0_event = 1;  // conditional statement in main() can now do something based on the event detection\n                    // we can also use actual system kernel event flags, but this is simpler (for now)\n}",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#constraints-on-callback-functions",
    "href": "slides/zephyr-gpio-isr-callbacks.html#constraints-on-callback-functions",
    "title": "GPIO / ISR / Callbacks",
    "section": "Constraints on Callback Functions",
    "text": "Constraints on Callback Functions\n\nThe contents of this function should consume minimal resources / time (i.e., cannot “block”).\nCommon action is to set an event or toggle the state of a Boolean, the value of which is reset after action is taken in the main code.",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#within-main",
    "href": "slides/zephyr-gpio-isr-callbacks.html#within-main",
    "title": "GPIO / ISR / Callbacks",
    "section": "Within main()",
    "text": "Within main()\n// check if interface is ready\nif (!device_is_ready(sw0.port)) {\n    LOG_ERR(\"gpio0 interface not ready.\");  // logging module output\n    return -1;  // exit code that will exit main()\n}\n\n// configure GPIO pin\nint err;\nerr = gpio_pin_configure_dt(&sw0, GPIO_INPUT);\nif (err &lt; 0) {\n    LOG_ERR(\"Cannot configure sw0 pin.\");\n    return err;\n}\n// associate callback with GPIO pin\nerr = gpio_pin_interrupt_configure_dt(&sw0, GPIO_INT_EDGE_TO_ACTIVE); // trigger on transition from INACTIVE -&gt; ACTIVE  \n                                                                      // ACTIVE could be HIGH or LOW\nif (err &lt; 0) {\n    LOG_ERR(\"Cannot attach callback to sw0.\");\n}\ngpio_init_callback(&sw0_cb, sw0_callback, BIT(sw0.pin)); // populate CB struct with information about the CB function and pin\ngpio_add_callback_dt(sw0, &sw0_cb); // associate callback with GPIO pin\n\n\n// test for the callback event state in your code...\nwhile () {\n    if (sw0_event) {\n        do_something_less_trivial();  // this can take more time than the callback function\n        sw0_event = 0;\n    } \n}",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#some-useful-api-documentation",
    "href": "slides/zephyr-gpio-isr-callbacks.html#some-useful-api-documentation",
    "title": "GPIO / ISR / Callbacks",
    "section": "Some useful API documentation",
    "text": "Some useful API documentation\n\ngpio_pin_configure_dt()\ngpio_init_callback()\ngpio_add_callback_dt()\nThe entire GPIO API",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#modifying-button-functionality",
    "href": "slides/zephyr-gpio-isr-callbacks.html#modifying-button-functionality",
    "title": "GPIO / ISR / Callbacks",
    "section": "Modifying Button Functionality",
    "text": "Modifying Button Functionality\n\nIf you want a button to have multiple functionalities, you can do so by changing the callback associated with the button.\nNext are the steps to set up a button with 2 different callbacks.",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#placed-outside-of-while-loop",
    "href": "slides/zephyr-gpio-isr-callbacks.html#placed-outside-of-while-loop",
    "title": "GPIO / ISR / Callbacks",
    "section": "Placed outside of while loop",
    "text": "Placed outside of while loop\n// declare second callback function\nvoid sw0_callback_2(const struct device *dev, struct gpio_callback *cb, uint32_t pins);\n\n// initialize second GPIO Callback Struct}\nstatic struct gpio_callback sw0_cb_2;\n\n// define second callback function.\nvoid sw0_callback_2(const struct device *dev, struct gpio_callback *cb, uint32_t pins)\n{\n    different_event = 1;\n    //This callback now toggles a different event trigger\n}\n\n//Associate the second callback function to the second callback struct\ngpio_init_callback(&sw0_cb_2, sw0_callback_2, BIT(sw0.pin));\nThe gpio_callback struct is used to store information about the callback function. This includes the function and the GPIO pin that it is associated with.\n\nOnce this is setup, the following syntax will switch the function associated with the button press:\ngpio_remove_callback_dt(sw0, &sw0_cb);\ngpio_add_callback_dt(sw0, &sw0_cb_2);",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#deactivating-the-button",
    "href": "slides/zephyr-gpio-isr-callbacks.html#deactivating-the-button",
    "title": "GPIO / ISR / Callbacks",
    "section": "Deactivating the Button",
    "text": "Deactivating the Button\n\nOther times you’ll wish to deactivate the button entirely.\nHowever, removing the callback like above will still cause the interrupt to trigger.\nInstead, it is best to remove the interrupt with gpio_pin_configure_dt:\n\ngpio_pin_interrupt_configure_dt(&sw0, GPIO_INT_DISABLE);",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#callback-functions-should-not-test-for-state",
    "href": "slides/zephyr-gpio-isr-callbacks.html#callback-functions-should-not-test-for-state",
    "title": "GPIO / ISR / Callbacks",
    "section": "Callback Functions Should Not Test For State",
    "text": "Callback Functions Should Not Test For State\nvoid callback_function(const struct device *dev, struct gpio_callback *cb, uint32_t pins)\n{\n    if (state == AWAKE) {\n        state = NEW_STATE_A;\n    } else (state == SLEEP) {\n        state = NEW_STATE_B;\n    }\n}\n\nInstead, have state-specific callbacks for each ISR:\n\nDetach a callback function in an exit transition state.\nAttach a new state-specific callback function in an entry transition state.",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#configure-gpio-pin-as-output",
    "href": "slides/zephyr-gpio-isr-callbacks.html#configure-gpio-pin-as-output",
    "title": "GPIO / ISR / Callbacks",
    "section": "Configure GPIO Pin as Output",
    "text": "Configure GPIO Pin as Output\n// led is a gpio struct you have already created from the devicetree\n\n// check if interface is ready\nif (!device_is_ready(led.port)) {\n    LOG_ERR(\"gpio0 interface not ready.\");  // logging module output\n    return -1;  // exit code that will exit main()\n}\n\n// configure GPIO pin\nint err;\nerr = gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE);  // ACTIVE referes to ON, not HIGH\nif (err &lt; 0) {\n    LOG_ERR(\"Cannot configure GPIO output pin.\");\n    return err;\n}",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#set-pin-state",
    "href": "slides/zephyr-gpio-isr-callbacks.html#set-pin-state",
    "title": "GPIO / ISR / Callbacks",
    "section": "Set Pin State",
    "text": "Set Pin State\n#define SLEEP_TIME_MS 1000\nbool led_state = true;\n\nint ret = gpio_pin_toggle_dt(&led);\n// can explicitly set with gpio_pin_set_dt(&led, led_state);\nif (ret &lt; 0) {\n    LOG_ERR(\"Cannot toggle GPIO output pin.\");\n    return ret;\n}\n\nled_state = !led_state;\nLOG_INF(\"LED state: %s\\n\", led_state ? \"ON\" : \"OFF\");\nk_msleep(SLEEP_TIME_MS);  // this is BLOCKING",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#interrupt-configuration-flags",
    "href": "slides/zephyr-gpio-isr-callbacks.html#interrupt-configuration-flags",
    "title": "GPIO / ISR / Callbacks",
    "section": "Interrupt Configuration Flags",
    "text": "Interrupt Configuration Flags\nThere are several other interrupt configuration flags that can be used to toggle the interrupt to trigger on falling edge, on both edges, etc.:\nGPIO Flags & Documentation\nRelevant MACROS:\n\nGPIO_INT_EDGE_[TO_ACTIVE/TO_INACTIVE/BOTH]\nGPIO_INT_DISABLE",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#button-debouncing",
    "href": "slides/zephyr-gpio-isr-callbacks.html#button-debouncing",
    "title": "GPIO / ISR / Callbacks",
    "section": "Button Debouncing",
    "text": "Button Debouncing\n\n\n\n\n\n\nWhat is debouncing?\n\n\n\n“Debouncing” is a technique used to ensure that only a single signal is registered when a button is pressed, despite the fact that mechanical buttons can produce multiple rapid on/off signals (bounces) when pressed or released.\n\n\nHow to Debounce Button Inputs in a RTOS",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks.html#resources",
    "href": "slides/zephyr-gpio-isr-callbacks.html#resources",
    "title": "GPIO / ISR / Callbacks",
    "section": "Resources",
    "text": "Resources\n\nNordic DevAcademy: Reading buttons and controlling LEDs",
    "crumbs": [
      "Learning Modules",
      "GPIO, ISR, and Callbacks"
    ]
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#timing-of-read-in-main",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#timing-of-read-in-main",
    "title": "GPIO / ISR / Callbacks",
    "section": "Timing of read() in main()",
    "text": "Timing of read() in main()\nvoid main() {\n    while (1) {\n        // do stuff\n        k_msleep(1000);\n        sw0_event = command_to_read_digital_pin();\n        if (sw0_event) {\n            // do stuff\n        }\n    }\n} \n\nWhat if you press the button while the code is “sleeping”?\nWhat if “do stuff” is time consuming / blocking?"
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#the-phone-call-analogy",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#the-phone-call-analogy",
    "title": "GPIO / ISR / Callbacks",
    "section": "The phone call analogy…",
    "text": "The phone call analogy…\n\nTrying to read a button at a specific time is like only checking if you have an incoming phone call at a specific time interval (i.e., no ring).\nInstead, think of the ringing phone as an event trigger that you allow to happen “whenever”."
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#interrupts",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#interrupts",
    "title": "GPIO / ISR / Callbacks",
    "section": "Interrupts",
    "text": "Interrupts"
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#what-do-you-do-when-the-phone-rings",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#what-do-you-do-when-the-phone-rings",
    "title": "GPIO / ISR / Callbacks",
    "section": "What do you do when the phone rings?",
    "text": "What do you do when the phone rings?\n\nYou might not be able to take a 2-hour phone call right when your phone rings, but you can:\n\nAcknowledge that you received the call (e.g., thumbs-up emoji text message)\nAdd an item to your “to do” list (i.e., “queue”) to call the person back when you have time\n\nWhat you do when the phone rings (the interrupt) is captured in a callback function."
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#isr---callback-function",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#isr---callback-function",
    "title": "GPIO / ISR / Callbacks",
    "section": "ISR -> Callback Function",
    "text": "ISR -&gt; Callback Function\n\nAn interrupt can be used to call a callback function (“callback” = a function executed in response to an interrupt or event).\nNeed to execute the callback / ISR quickly to not paralyze the rest of main() / other threads from running, otherwise device is paralyzed from acting.\n\nAvoid calculations, significant IO, data Tx/Rx, etc.\nPrefer simple actions, like toggling the state of a Boolean variable or posting an event.\n\nCallback functions can be removed (gpio_remove_callback_dt()) or re-assigned from an ISR.\n\nButton function can change as a function of the state of the system.\nButton can be disabled or re-enabled based on the state of the system."
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#overview",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#overview",
    "title": "GPIO / ISR / Callbacks",
    "section": "Overview",
    "text": "Overview\n\nprj.conf - enable GPIO, enable logging libraries\ndevicetree.overlay - define GPIO pin as an input, define callback function\nmain.c - initialize GPIO struct, initialize callback struct, associate callback with GPIO pin, define callback function, test for callback event state in your code"
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#devicetree-overlay-gpio-keys",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#devicetree-overlay-gpio-keys",
    "title": "GPIO / ISR / Callbacks",
    "section": "Devicetree (overlay): gpio-keys",
    "text": "Devicetree (overlay): gpio-keys\nThe Devicetree is used to separate hardware-specific definitions from the firmware logic. Your development kit has a pre-defined devicetree in Zephyr that can be modified with an overlay file. This overlay file can be:\n\nManually edited (YAML format), or\nEdited/visualized with the nRF DeviceTree extension in VS Code\n\n/ {\n    aliases {\n        sw0: &button0;\n    }\n\n    buttons {\n        compatible = \"gpio-keys\";\n        button0: button_0 {\n            gpios = &lt;&gpio0 8 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)&gt;;\n            label = \"Push button\";\n        };\n    };\n};"
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#what-is-active-state",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#what-is-active-state",
    "title": "GPIO / ISR / Callbacks",
    "section": "What is “ACTIVE” state?",
    "text": "What is “ACTIVE” state?\n\nGPIO_ACTIVE_LOW - button is active when pulled to low voltage (GND)\nGPIO_ACTIVE_HIGH - button is active when pulled to high voltage (VDD)\n\n\nhttps://docs.nordicsemi.com/bundle/ug_nrf52833_dk/page/UG/dk/hw_buttons_leds.html"
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#collecting-gpio-information-from-the-devicetree-into-a-struct",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#collecting-gpio-information-from-the-devicetree-into-a-struct",
    "title": "GPIO / ISR / Callbacks",
    "section": "Collecting GPIO Information from the Devicetree into a struct",
    "text": "Collecting GPIO Information from the Devicetree into a struct\n// create this struct before main()\n// initialize GPIO struct\nstatic const struct gpio_dt_spec sw0 = GPIO_DT_SPEC_GET(DT_ALIAS(sw0), gpios);\n\nGPIO_DT_SPEC_GET: macro to get GPIO information from the DT\nDT_ALIAS: reference the pin of interest by an alias (sw0) in the DT\ngpio_dt_spec: struct prototype to store all of the information about this GPIO pin\nsw0: name of the struct that will store the information about the GPIO pin"
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#define-callback-function",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#define-callback-function",
    "title": "GPIO / ISR / Callbacks",
    "section": "Define Callback Function",
    "text": "Define Callback Function\n// declare callback function\nvoid sw0_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins);\n// initialize GPIO callback struct\nstatic struct gpio_callback sw0_cb;  \n\ngpio_callback: struct prototype is defined in gpio.h\nsw0_cb: name of the struct based on the gpio_callback prototype that will store the information about the callback function\n\n// define callback function\nvoid sw0_callback(const struct device *dev, struct gpio_callback *cb, uint32_t pins)\n{\n    sw0_event = 1;  // conditional statement in main() can now do something based on the event detection\n                    // we can also use actual system kernel event flags, but this is simpler (for now)\n}"
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#constraints-on-callback-functions",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#constraints-on-callback-functions",
    "title": "GPIO / ISR / Callbacks",
    "section": "Constraints on Callback Functions",
    "text": "Constraints on Callback Functions\n\nThe contents of this function should consume minimal resources / time (i.e., cannot “block”).\nCommon action is to set an event or toggle the state of a Boolean, the value of which is reset after action is taken in the main code."
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#within-main",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#within-main",
    "title": "GPIO / ISR / Callbacks",
    "section": "Within main()",
    "text": "Within main()\n// check if interface is ready\nif (!device_is_ready(sw0.port)) {\n    LOG_ERR(\"gpio0 interface not ready.\");  // logging module output\n    return -1;  // exit code that will exit main()\n}\n\n// configure GPIO pin\nint err;\nerr = gpio_pin_configure_dt(&sw0, GPIO_INPUT);\nif (err &lt; 0) {\n    LOG_ERR(\"Cannot configure sw0 pin.\");\n    return err;\n}\n// associate callback with GPIO pin\nerr = gpio_pin_interrupt_configure_dt(&sw0, GPIO_INT_EDGE_TO_ACTIVE); // trigger on transition from INACTIVE -&gt; ACTIVE  \n                                                                      // ACTIVE could be HIGH or LOW\nif (err &lt; 0) {\n    LOG_ERR(\"Cannot attach callback to sw0.\");\n}\ngpio_init_callback(&sw0_cb, sw0_callback, BIT(sw0.pin)); // populate CB struct with information about the CB function and pin\ngpio_add_callback_dt(sw0, &sw0_cb); // associate callback with GPIO pin\n\n\n// test for the callback event state in your code...\nwhile () {\n    if (sw0_event) {\n        do_something_less_trivial();  // this can take more time than the callback function\n        sw0_event = 0;\n    } \n}"
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#some-useful-api-documentation",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#some-useful-api-documentation",
    "title": "GPIO / ISR / Callbacks",
    "section": "Some useful API documentation",
    "text": "Some useful API documentation\n\ngpio_pin_configure_dt()\ngpio_init_callback()\ngpio_add_callback_dt()\nThe entire GPIO API"
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#modifying-button-functionality",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#modifying-button-functionality",
    "title": "GPIO / ISR / Callbacks",
    "section": "Modifying Button Functionality",
    "text": "Modifying Button Functionality\n\nIf you want a button to have multiple functionalities, you can do so by changing the callback associated with the button.\nNext are the steps to set up a button with 2 different callbacks."
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#placed-outside-of-while-loop",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#placed-outside-of-while-loop",
    "title": "GPIO / ISR / Callbacks",
    "section": "Placed outside of while loop",
    "text": "Placed outside of while loop\n// declare second callback function\nvoid sw0_callback_2(const struct device *dev, struct gpio_callback *cb, uint32_t pins);\n\n// initialize second GPIO Callback Struct}\nstatic struct gpio_callback sw0_cb_2;\n\n// define second callback function.\nvoid sw0_callback_2(const struct device *dev, struct gpio_callback *cb, uint32_t pins)\n{\n    different_event = 1;\n    //This callback now toggles a different event trigger\n}\n\n//Associate the second callback function to the second callback struct\ngpio_init_callback(&sw0_cb_2, sw0_callback_2, BIT(sw0.pin));\nThe gpio_callback struct is used to store information about the callback function. This includes the function and the GPIO pin that it is associated with."
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#deactivating-the-button",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#deactivating-the-button",
    "title": "GPIO / ISR / Callbacks",
    "section": "Deactivating the Button",
    "text": "Deactivating the Button\n\nOther times you’ll wish to deactivate the button entirely.\nHowever, removing the callback like above will still cause the interrupt to trigger.\nInstead, it is best to remove the interrupt with gpio_pin_configure_dt:\n\ngpio_pin_interrupt_configure_dt(&sw0, GPIO_INT_DISABLE);"
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#callback-functions-should-not-test-for-state",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#callback-functions-should-not-test-for-state",
    "title": "GPIO / ISR / Callbacks",
    "section": "Callback Functions Should Not Test For State",
    "text": "Callback Functions Should Not Test For State\nvoid callback_function(const struct device *dev, struct gpio_callback *cb, uint32_t pins)\n{\n    if (state == AWAKE) {\n        state = NEW_STATE_A;\n    } else (state == SLEEP) {\n        state = NEW_STATE_B;\n    }\n}\n\nInstead, have state-specific callbacks for each ISR:\n\nDetach a callback function in an exit transition state.\nAttach a new state-specific callback function in an entry transition state."
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#configure-gpio-pin-as-output",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#configure-gpio-pin-as-output",
    "title": "GPIO / ISR / Callbacks",
    "section": "Configure GPIO Pin as Output",
    "text": "Configure GPIO Pin as Output\n// led is a gpio struct you have already created from the devicetree\n\n// check if interface is ready\nif (!device_is_ready(led.port)) {\n    LOG_ERR(\"gpio0 interface not ready.\");  // logging module output\n    return -1;  // exit code that will exit main()\n}\n\n// configure GPIO pin\nint err;\nerr = gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE);  // ACTIVE referes to ON, not HIGH\nif (err &lt; 0) {\n    LOG_ERR(\"Cannot configure GPIO output pin.\");\n    return err;\n}"
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#set-pin-state",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#set-pin-state",
    "title": "GPIO / ISR / Callbacks",
    "section": "Set Pin State",
    "text": "Set Pin State\n#define SLEEP_TIME_MS 1000\nbool led_state = true;\n\nint ret = gpio_pin_toggle_dt(&led);\n// can explicitly set with gpio_pin_set_dt(&led, led_state);\nif (ret &lt; 0) {\n    LOG_ERR(\"Cannot toggle GPIO output pin.\");\n    return ret;\n}\n\nled_state = !led_state;\nLOG_INF(\"LED state: %s\\n\", led_state ? \"ON\" : \"OFF\");\nk_msleep(SLEEP_TIME_MS);  // this is BLOCKING"
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#interrupt-configuration-flags",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#interrupt-configuration-flags",
    "title": "GPIO / ISR / Callbacks",
    "section": "Interrupt Configuration Flags",
    "text": "Interrupt Configuration Flags\nThere are several other interrupt configuration flags that can be used to toggle the interrupt to trigger on falling edge, on both edges, etc.:\nGPIO Flags & Documentation\nRelevant MACROS:\n\nGPIO_INT_EDGE_[TO_ACTIVE/TO_INACTIVE/BOTH]\nGPIO_INT_DISABLE"
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#button-debouncing",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#button-debouncing",
    "title": "GPIO / ISR / Callbacks",
    "section": "Button Debouncing",
    "text": "Button Debouncing\n\n\n\n\n\n\n\nWhat is debouncing?\n\n\n“Debouncing” is a technique used to ensure that only a single signal is registered when a button is pressed, despite the fact that mechanical buttons can produce multiple rapid on/off signals (bounces) when pressed or released.\n\n\n\n\nHow to Debounce Button Inputs in a RTOS"
  },
  {
    "objectID": "slides/zephyr-gpio-isr-callbacks-slides.html#resources",
    "href": "slides/zephyr-gpio-isr-callbacks-slides.html#resources",
    "title": "GPIO / ISR / Callbacks",
    "section": "Resources",
    "text": "Resources\n\nNordic DevAcademy: Reading buttons and controlling LEDs"
  },
  {
    "objectID": "slides/c-programming-notes.html",
    "href": "slides/c-programming-notes.html",
    "title": "C Programming",
    "section": "",
    "text": "Binary states: HIGH and LOW\nLOW is commonly GND\nHIGH is commonly either 5, 3.3 or 1.8 V.\nWhy binary? Electronics really can only represent On and Off states at the lowest level in hardware.\n\n\n\n\n\nbase10 (decimal): 0-9 in summed powers of 10.\nbase2 (binary): 0, 1 in summed powers of 2.\nConvert binary to decimal: \\(a_n2^n + a_{n-1}2^{n-1}+\\dots+a_12^1+a_02^0\\), where \\(a_n\\) is the \\(n^{th}\\) bit in the binary number:\n\nFor example, for the binary number 0b101 (where ‘0b’ means the number is represented in binary), the first 1 (from left to right) is in the 2nd bit spot, the 0 is in the 1st bit spot, and the second 1 is in the 0th bit spot.\nUsing the above formula results in \\(1*2^2 + 0*2^1 + 1*2^0 = 4 + 0 + 1 = 5\\)\n\n\n\n\n\nWord: Number of bits to use to express a value\n\n\n\nBit Depth\nName\nExample\n\n\n\n\n1\nBit\n0\n\n\n4\nNibble\n1001\n\n\n8\nByte\n10011011\n\n\n\n“Standard” word length can be system architecture dependent (16-, 32- or 64-bits)\n\n\n\nThe bits–or bytes–of a word can be organized from most significant to least significant or vice versa; this order is referred to as endianness.\n\n\n\n\n\nhttps://en.wikipedia.org/wiki/Endianness\n\n\n\nRaw binary data (bits) can quickly become cumbersome to read and write. To make data more human readable, we can encode it into a more compact form.\n\n\n\n\nbase16 (hexadecimal): 0-9, A-F in summed powers of 16 (0-15).\nA single character represents a nibble.\nHex is indicated by a leading 0x or 16 subscript: 22546 = 0x5812 = 581216\n\nhttps://en.wikipedia.org/wiki/Hexadecimal\n\n\n\n\n\n\n\n\nhttps://en.wikipedia.org/wiki/Base64",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#why-base2",
    "href": "slides/c-programming-notes.html#why-base2",
    "title": "C Programming",
    "section": "",
    "text": "Binary states: HIGH and LOW\nLOW is commonly GND\nHIGH is commonly either 5, 3.3 or 1.8 V.\nWhy binary? Electronics really can only represent On and Off states at the lowest level in hardware.",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#binary-base2-numbers",
    "href": "slides/c-programming-notes.html#binary-base2-numbers",
    "title": "C Programming",
    "section": "",
    "text": "base10 (decimal): 0-9 in summed powers of 10.\nbase2 (binary): 0, 1 in summed powers of 2.\nConvert binary to decimal: \\(a_n2^n + a_{n-1}2^{n-1}+\\dots+a_12^1+a_02^0\\), where \\(a_n\\) is the \\(n^{th}\\) bit in the binary number:\n\nFor example, for the binary number 0b101 (where ‘0b’ means the number is represented in binary), the first 1 (from left to right) is in the 2nd bit spot, the 0 is in the 1st bit spot, and the second 1 is in the 0th bit spot.\nUsing the above formula results in \\(1*2^2 + 0*2^1 + 1*2^0 = 4 + 0 + 1 = 5\\)",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#common-binary-number-word-lengths",
    "href": "slides/c-programming-notes.html#common-binary-number-word-lengths",
    "title": "C Programming",
    "section": "",
    "text": "Word: Number of bits to use to express a value\n\n\n\nBit Depth\nName\nExample\n\n\n\n\n1\nBit\n0\n\n\n4\nNibble\n1001\n\n\n8\nByte\n10011011\n\n\n\n“Standard” word length can be system architecture dependent (16-, 32- or 64-bits)",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#endianness",
    "href": "slides/c-programming-notes.html#endianness",
    "title": "C Programming",
    "section": "",
    "text": "The bits–or bytes–of a word can be organized from most significant to least significant or vice versa; this order is referred to as endianness.\n\n\n\n\n\nhttps://en.wikipedia.org/wiki/Endianness",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#data-encoding",
    "href": "slides/c-programming-notes.html#data-encoding",
    "title": "C Programming",
    "section": "",
    "text": "Raw binary data (bits) can quickly become cumbersome to read and write. To make data more human readable, we can encode it into a more compact form.",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#hexadecimal-base16",
    "href": "slides/c-programming-notes.html#hexadecimal-base16",
    "title": "C Programming",
    "section": "",
    "text": "base16 (hexadecimal): 0-9, A-F in summed powers of 16 (0-15).\nA single character represents a nibble.\nHex is indicated by a leading 0x or 16 subscript: 22546 = 0x5812 = 581216\n\nhttps://en.wikipedia.org/wiki/Hexadecimal",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#base64",
    "href": "slides/c-programming-notes.html#base64",
    "title": "C Programming",
    "section": "",
    "text": "https://en.wikipedia.org/wiki/Base64",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#ascii",
    "href": "slides/c-programming-notes.html#ascii",
    "title": "C Programming",
    "section": "ASCII",
    "text": "ASCII\n\n\n\n\n\nhttps://en.wikipedia.org/wiki/ASCII",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#utf-8",
    "href": "slides/c-programming-notes.html#utf-8",
    "title": "C Programming",
    "section": "UTF-8",
    "text": "UTF-8\nhttps://en.wikipedia.org/wiki/UTF-8",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#data-types-c",
    "href": "slides/c-programming-notes.html#data-types-c",
    "title": "C Programming",
    "section": "Data Types (C)",
    "text": "Data Types (C)\n\n\n\nName\nBit Depth\nValue Range\n\n\n\n\nbool\n1 or 8\ntrue/false (1/0)\n\n\nbyte\n8\n0-255 (unsigned)\n\n\nchar\n8\n-128-127 (signed)\n\n\nint\n16\n-32768-32767 (signed)\n\n\nuint\n16\n0-65535 (unsigned)\n\n\nlong\n32\n-2147483648-2147483647 (signed)\n\n\nfloat\n32\n1.2E-38–3.4E38 (signed)\n\n\ndouble\n64\n2.3E-308-1.7E308 (signed)",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#how-are-floating-point-numbers-represented",
    "href": "slides/c-programming-notes.html#how-are-floating-point-numbers-represented",
    "title": "C Programming",
    "section": "How are floating point numbers represented?",
    "text": "How are floating point numbers represented?",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#declaring-variables-by-data-type-c",
    "href": "slides/c-programming-notes.html#declaring-variables-by-data-type-c",
    "title": "C Programming",
    "section": "Declaring Variables by Data Type (C)",
    "text": "Declaring Variables by Data Type (C)\n\nMatlab, by default, declares variables when first used, and defaults all numerical data to be double (64-bit floating point).\n\nPython infers data type based on the value assigned to the variable.\n\nIn C, we must explicitly declare the data type of a variable, and the data type cannot change over the life of the variable.",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#why-not-just-make-all-numbers-floatsdoubles",
    "href": "slides/c-programming-notes.html#why-not-just-make-all-numbers-floatsdoubles",
    "title": "C Programming",
    "section": "Why not just make all numbers floats/doubles?",
    "text": "Why not just make all numbers floats/doubles?\nThe nRF52833 only has 128 kB of RAM. If we can use smaller data types, we can store more data in memory.\n\nint16_t my_int = 5; // 16-bit signed integer\nuint16_t my_uint = 5; // 16-bit unsigned integer\nfloat my_float = 5.0; // 32-bit floating point",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#variable-scope",
    "href": "slides/c-programming-notes.html#variable-scope",
    "title": "C Programming",
    "section": "Variable Scope",
    "text": "Variable Scope\nVariables can be limited in their scope (where they are accessible).\n\nGlobal variables are defined outside of functions and are globally available to everything in your program.\nLocal variables are defined inside of functions and are only visible within that function.\n\n#include &lt;zephyr/kernel.h&gt;\n\nint my_global_variable; // global variable\n\nvoid my_function(int my_input) {\n  int my_local_variable; // local variable\n  // do something\n}",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#constants-const",
    "href": "slides/c-programming-notes.html#constants-const",
    "title": "C Programming",
    "section": "Constants (const)",
    "text": "Constants (const)\n\nVariables that have values that will not change can be declared as constants (const).\nConstant variables consume a fixed amount of memory based on their data type when they are declared and defined.",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#macros",
    "href": "slides/c-programming-notes.html#macros",
    "title": "C Programming",
    "section": "MACROS",
    "text": "MACROS\n\nMACROS are preprocessor directives that are replaced with their values (constants of function definitions) before the code is compiled.\nMACROS save memory compared to using constant variables and can improve readability.\nDefined with the #define directive after #include preprocessor directives and are typically typed in ALLCAPS.\nVS Code will color highlight MACROs differently than variables.\n\n#include &lt;zephyr/kernel.h&gt;\n\n#define MY_MACRO 1\n\nvoid my_function(int my_input) {\n  // do something\n  int a = MY_MACRO * my_input;\n}",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#static-variables",
    "href": "slides/c-programming-notes.html#static-variables",
    "title": "C Programming",
    "section": "Static Variables",
    "text": "Static Variables\nStatic variables have different properties depending on whether they are local or global. Static variables get their own memory space that is not shared with other variables that are more dynamically allocated.\n\nGlobal\n\nGlobally-defined static variables are limited in scope to the *.c file they are defined in.\nProtects against name collisions (linkage) across multiple source code files.\n\n\n\nLocal\n\nStatic variables defined in functions retain their value between function calls (exit and re-entry).\n\n#include &lt;zephyr/kernel.h&gt;\n\nvoid my_function(int my_input) {\n  static int my_static_variable = 0; // static local variable\n  my_static_variable += my_input;\n  printk(\"The value of my_static_variable is %d\\n\", my_static_variable);\n}",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#typecasting",
    "href": "slides/c-programming-notes.html#typecasting",
    "title": "C Programming",
    "section": "Typecasting",
    "text": "Typecasting\n\nUse different data types in mathematical operations can lead to unexpected results.\n\n\n\n\n\n\n\nWarning\n\n\n\nWatch out for integer math (fixed point) that will yield a non-integer (floating point) result.\n\n\nvoid main(void) {\n  int a = 5;\n  int b = 3;\n  float c;\n\n  c = a / b; // c = 1.0\n}\n\n\nTypecasting is performed by placing the desired data type in parentheses before the value or variable.\nOnce a typecasted variable is encountered in the expression (by order of operations), then the rest of the operation is performed in that typecast unless typecasted again.\n\nint a = 5;\nint b = 3;\nfloat c;\n\nc = (float)a / b; // b is typecasted to float \n                  // because a is typecasted to float",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#bit-depth",
    "href": "slides/c-programming-notes.html#bit-depth",
    "title": "C Programming",
    "section": "Bit Depth",
    "text": "Bit Depth\n\n\n\n\n\n\nWarning\n\n\n\nWatch out for the range of your data type! If your mathematical operation exceeds the min/max value of the bit depth, the data will “wrap around”.\n\n\n\nuint8_t a = 255; // 8-bit unsigned integer\n\na = a + 1; // a = 0",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#printing-logging-data-types",
    "href": "slides/c-programming-notes.html#printing-logging-data-types",
    "title": "C Programming",
    "section": "Printing / Logging Data Types",
    "text": "Printing / Logging Data Types\n\n\n\nFormatted Print Placeholder\nData Type\n\n\n\n\n%d\ndecimal (int)\n\n\n%ld\nlong decimal (32-bit)\n\n\n%lld\nlong long decimal (64-bit)\n\n\n%u\nunsigned decimal (uint)\n\n\n%f\nfloat\n\n\n%c\nchar\n\n\n%s\nstring (char array)\n\n\n%x\nhex (int)\n\n\n%b\nbinary (int)\n\n\n%p\npointer (memory address)\n\n\n\nprintk(\"The value of a is %d\\n\", a); // %d must match the data type of a to properly print its value",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#pointers",
    "href": "slides/c-programming-notes.html#pointers",
    "title": "C Programming",
    "section": "Pointers",
    "text": "Pointers\nOne of the greatest strengths–and most dangerous aspects–of C is the use of pointers. A pointer is a variable that stores the memory address of another variable. Pointers are used to pass variables by reference (in contrast to value) to functions, and to dynamically allocate memory.\nPointers save memory and time by not copying the value of a variable to a function. Instead, the function can directly access the variable in memory. This is especially useful for large data structures.\n\nint a = 5;\n\nvoid my_function(int *a_ptr) {  // *a_ptr is a pointer to int a\n  *a_ptr = 10; // dereference a_ptr to change the value of a\n  // note no value is returned; it is assigned directly to the memory address\n}\n\nvoid main() {\n  printk(\"The value of a is %d\\n\", a); // prints 5\n  my_function(&a); // pass the memory address (&) of a to my_function\n  printk(\"The value of a is %d\\n\", a); // prints 10\n}",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#general-c-code-structure",
    "href": "slides/c-programming-notes.html#general-c-code-structure",
    "title": "C Programming",
    "section": "General C Code Structure",
    "text": "General C Code Structure\n\nOrganization of C code is very important! Developers will “expect” certain things to be in certain places.\nC code is compiled (built) into a binary executable that is loaded onto the microcontroller. It is not “run” on-the-fly as an interpreted language like Matlab or Python.\n\n\n#include &lt;zephyr/kernel.h&gt;  // include system libraries\n#include \"my_great_library.h\" // include your own libraries\n\n#define MY_MACRO 1 // define MACROs\n\nvoid my_function(int32_t my_input); // function prototype\n\nint32_t my_global_variable; // global variable\n\nvoid my_function(int32_t my_input) { // function definition\n  // do something\n  // no return b/c of void return type\n}",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#coding-style",
    "href": "slides/c-programming-notes.html#coding-style",
    "title": "C Programming",
    "section": "Coding Style",
    "text": "Coding Style\n\nAll lines of code must end with a semicolon ;.\n\nIndentation helps with readability, but does nothing to delineate code blocks.\n\nCode blocks are delineated by curly braces {}.",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#return-typescodes",
    "href": "slides/c-programming-notes.html#return-typescodes",
    "title": "C Programming",
    "section": "Return Types/Codes",
    "text": "Return Types/Codes\n\nMost C functions will return a value, but that value tends to be an exit code, not a value being assigned to a variable.\nThese codes are used to indicate the success or failure of the function, and tend to be ints.\n\nReturned 0 indicates success, and any other value indicates failure.\nThe return type is defined in the function prototype.\n\nIf the function does not return a value, the return type is void.\n\n\nint my_function(void) {\n  // do something\n  return 0; // return 0 for success\n}\n\nvoid main(void) {\n  int return_code = my_function();\n  if (return_code) {\n    printk(\"Failure!\\n\");\n  } else {\n    printk(\"Success!\\n\");\n  }\n}",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#function-arguments",
    "href": "slides/c-programming-notes.html#function-arguments",
    "title": "C Programming",
    "section": "Function Arguments",
    "text": "Function Arguments\n\nFunction arguments are defined in the function prototype.\nMost of our arguments will be passed by reference (pointers to memory addresses), not value. This means that the function will be able to change the value of the variable passed to it by pointer reference.\nIf the function does not take any arguments, the argument list is void. The function may still operate on variables if they are global.",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#main",
    "href": "slides/c-programming-notes.html#main",
    "title": "C Programming",
    "section": "main",
    "text": "main\n\nIn Zephyr, the primary source code file is src/main.c.\nIn Zephyr (and many other C frameworks), the main() function is the entry point of the program.",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#arrays",
    "href": "slides/c-programming-notes.html#arrays",
    "title": "C Programming",
    "section": "Arrays",
    "text": "Arrays\n\nArrays are a contiguous block of memory that can store multiple values of the same data type.\nArrays are declared with a fixed length.\nArrays are indexed starting at 0 (not 1!).\nArrays can be declared with an initial value, or initialized later.\n\nint my_array[5] = {1, 2, 3, 4, 5};\nint my_array[5] = {0};\nint my_array[5];\n\nThe only time to populate all of the elements of an array is when it is initialized. Otherwise, you can:\n\nPopulate each element individually (e.g., a for loop), or\nCreate a new array and then copy it over the existing array using memcpy().",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#enumerations-enums",
    "href": "slides/c-programming-notes.html#enumerations-enums",
    "title": "C Programming",
    "section": "Enumerations (Enums)",
    "text": "Enumerations (Enums)\n\nEnums are a way to assign a name to a value.\nEnums are declared with a fixed length.\nEnums are indexed starting at 0 (not 1!).\nVery useful for more verbose / readable switch/case statements.\n\n\nenum Level {\n  LOW,    // by default, 0\n  MEDIUM, // 1\n  HIGH    // 2\n};\n\nvoid main(void) {\n  enum Level my_level = MEDIUM;\n\n  switch (my_level) {\n    case LOW:\n      printk(\"Low level\\n\");\n      break; // break out of switch statement\n    case MEDIUM:\n      printk(\"Medium level\\n\");\n      break;\n    case HIGH:\n      printk(\"High level\\n\");\n      break;\n    default:\n      printk(\"Unknown level\\n\");\n      break;\n  }\n}",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#structs",
    "href": "slides/c-programming-notes.html#structs",
    "title": "C Programming",
    "section": "Structs",
    "text": "Structs\n\nStructures group multiple variables together.\nStructures are declared with a fixed length.\nNice data structure to organize variables that are related to each other.\n\nstruct Person {\n  char name[50];\n  int age;\n  float height;\n};\n\nvoid main(void) {\n  struct Person my_person = {\"John\", 32, 1.8};\n\n  printk(\"My name is %s\\n\", my_person.name);\n  printk(\"I am %d years old\\n\", my_person.age);\n  printk(\"I am %f meters tall\\n\", my_person.height);\n}",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#conditional-statements",
    "href": "slides/c-programming-notes.html#conditional-statements",
    "title": "C Programming",
    "section": "Conditional Statements",
    "text": "Conditional Statements\nif (a == 5) {\n  // do something\n} else if (b != 3) {\n  // do something else\n} else {\n  // do something else\n}",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#loops",
    "href": "slides/c-programming-notes.html#loops",
    "title": "C Programming",
    "section": "Loops",
    "text": "Loops\nfor (int i = 0; i &lt; 10; i++) {\n  // do something\n}\n\nwhile (a &lt; 10) {\n  // do something\n  a++;\n}\n\nwhile () {\n  // do something\n  if (a == 10) {\n    break; // break out of loop\n  }\n}",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#project-libraries",
    "href": "slides/c-programming-notes.html#project-libraries",
    "title": "C Programming",
    "section": "Project Libraries",
    "text": "Project Libraries\n\nWriting your own libraries is a great way to organize your code and make it more readable.\nLibraries can also be shared with others and re-used in other projects.\n#include \"your_library.h\" can be used to include a library in your source code.\nA library contains a pair of files:\n\nyour_library.h contains the function prototypes and macro definitions.\nyour_library.c contains the function definitions.\n\nTo make sure that a library doesn’t get included multiple times, use the following syntax in your header file:\n\n\n#ifndef YOUR_LIBRARY_H\n#define YOUR_LIBRARY_H\n\n// function prototypes and macro definitions\n\n#endif\n\nThe definition of the macro YOUR_LIBRARY_H is tested for, and it is defined, then it has already been included into the code.\nIn your library source code (your_library.c), you need to include this header file:\n\n#include \"your_library.h\"",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#cmake-build-system",
    "href": "slides/c-programming-notes.html#cmake-build-system",
    "title": "C Programming",
    "section": "CMake Build System",
    "text": "CMake Build System\n\nZephyr uses cmake as its build system, which helps link libraries used in your source code.\nYou will also need to add the library to your CMakeLists.txt file:\n\ntarget_sources(app PRIVATE src/main.c src/your_library.c)",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#memory-management",
    "href": "slides/c-programming-notes.html#memory-management",
    "title": "C Programming",
    "section": "Memory Management",
    "text": "Memory Management\n\nA great summary of the different types of memory in C is summarized below from http://www.gotw.ca/gotw/009.htm:",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#const-data",
    "href": "slides/c-programming-notes.html#const-data",
    "title": "C Programming",
    "section": "const Data",
    "text": "const Data\n\nImmutable data that are read-only; trying to modify it is undefined.\n\nStore data whose values are known at compile time and guarded against inadvertent modification.\n\nAll data in this area are available during the entire lifetime of the program.\nOptimized memory usage since multiple references to the same const data can share the same memory location.",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#stack",
    "href": "slides/c-programming-notes.html#stack",
    "title": "C Programming",
    "section": "Stack",
    "text": "Stack\n\nStores automatic variables.\nTypically allocation is much faster than for dynamic storage (heap or free store) because a memory allocation involves only pointer increment rather than more complex management.\n\nObjects are constructed immediately after memory is allocated and destroyed immediately before memory is deallocated, so there is no opportunity for programmers to directly manipulate allocated but uninitialized stack space (barring willful tampering using explicit dtors and placement new).",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#free-store",
    "href": "slides/c-programming-notes.html#free-store",
    "title": "C Programming",
    "section": "Free Store",
    "text": "Free Store\n\nThe free store is one of the two dynamic memory areas, allocated/freed by new/delete.",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#heap",
    "href": "slides/c-programming-notes.html#heap",
    "title": "C Programming",
    "section": "Heap",
    "text": "Heap\n\nThe other dynamic memory area, allocated/freed by malloc()/free() and their variants.",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#globalstatic",
    "href": "slides/c-programming-notes.html#globalstatic",
    "title": "C Programming",
    "section": "Global/Static",
    "text": "Global/Static\n\nGlobal or static variables and objects have their storage allocated at program startup, but may not be initialized until after the program has begun executing.",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-notes.html#resources",
    "href": "slides/c-programming-notes.html#resources",
    "title": "C Programming",
    "section": "Resources",
    "text": "Resources\n\nC Programming Language\nNordic DevAcademy: Debugging",
    "crumbs": [
      "Learning Modules",
      "C Programming"
    ]
  },
  {
    "objectID": "slides/c-programming-slides.html#why-base2",
    "href": "slides/c-programming-slides.html#why-base2",
    "title": "C Programming",
    "section": "Why Base2?",
    "text": "Why Base2?\n\nBinary states: HIGH and LOW\nLOW is commonly GND\nHIGH is commonly either 5, 3.3 or 1.8 V.\nWhy binary? Electronics really can only represent On and Off states at the lowest level in hardware."
  },
  {
    "objectID": "slides/c-programming-slides.html#binary-base2-numbers",
    "href": "slides/c-programming-slides.html#binary-base2-numbers",
    "title": "C Programming",
    "section": "Binary (Base2) Numbers",
    "text": "Binary (Base2) Numbers\n\nbase10 (decimal): 0-9 in summed powers of 10.\nbase2 (binary): 0, 1 in summed powers of 2.\nConvert binary to decimal: \\(a_n2^n + a_{n-1}2^{n-1}+\\dots+a_12^1+a_02^0\\), where \\(a_n\\) is the \\(n^{th}\\) bit in the binary number:\n\nFor example, for the binary number 0b101 (where ‘0b’ means the number is represented in binary), the first 1 (from left to right) is in the 2nd bit spot, the 0 is in the 1st bit spot, and the second 1 is in the 0th bit spot.\nUsing the above formula results in \\(1*2^2 + 0*2^1 + 1*2^0 = 4 + 0 + 1 = 5\\)"
  },
  {
    "objectID": "slides/c-programming-slides.html#common-binary-number-word-lengths",
    "href": "slides/c-programming-slides.html#common-binary-number-word-lengths",
    "title": "C Programming",
    "section": "Common Binary Number Word Lengths",
    "text": "Common Binary Number Word Lengths\nWord: Number of bits to use to express a value\n\n\n\nBit Depth\nName\nExample\n\n\n\n\n1\nBit\n0\n\n\n4\nNibble\n1001\n\n\n8\nByte\n10011011\n\n\n\n“Standard” word length can be system architecture dependent (16-, 32- or 64-bits)"
  },
  {
    "objectID": "slides/c-programming-slides.html#endianness",
    "href": "slides/c-programming-slides.html#endianness",
    "title": "C Programming",
    "section": "Endianness",
    "text": "Endianness\nThe bits–or bytes–of a word can be organized from most significant to least significant or vice versa; this order is referred to as endianness.\n\nhttps://en.wikipedia.org/wiki/Endianness"
  },
  {
    "objectID": "slides/c-programming-slides.html#data-encoding",
    "href": "slides/c-programming-slides.html#data-encoding",
    "title": "C Programming",
    "section": "Data Encoding",
    "text": "Data Encoding\nRaw binary data (bits) can quickly become cumbersome to read and write. To make data more human readable, we can encode it into a more compact form."
  },
  {
    "objectID": "slides/c-programming-slides.html#hexadecimal-base16",
    "href": "slides/c-programming-slides.html#hexadecimal-base16",
    "title": "C Programming",
    "section": "Hexadecimal (Base16)",
    "text": "Hexadecimal (Base16)\n\nbase16 (hexadecimal): 0-9, A-F in summed powers of 16 (0-15).\nA single character represents a nibble.\nHex is indicated by a leading 0x or 16 subscript: 22546 = 0x5812 = 581216\n\nhttps://en.wikipedia.org/wiki/Hexadecimal"
  },
  {
    "objectID": "slides/c-programming-slides.html#base64",
    "href": "slides/c-programming-slides.html#base64",
    "title": "C Programming",
    "section": "Base64",
    "text": "Base64\n\nhttps://en.wikipedia.org/wiki/Base64"
  },
  {
    "objectID": "slides/c-programming-slides.html#ascii",
    "href": "slides/c-programming-slides.html#ascii",
    "title": "C Programming",
    "section": "ASCII",
    "text": "ASCII\n\nhttps://en.wikipedia.org/wiki/ASCII"
  },
  {
    "objectID": "slides/c-programming-slides.html#utf-8",
    "href": "slides/c-programming-slides.html#utf-8",
    "title": "C Programming",
    "section": "UTF-8",
    "text": "UTF-8\nhttps://en.wikipedia.org/wiki/UTF-8"
  },
  {
    "objectID": "slides/c-programming-slides.html#data-types-c",
    "href": "slides/c-programming-slides.html#data-types-c",
    "title": "C Programming",
    "section": "Data Types (C)",
    "text": "Data Types (C)\n\n\n\nName\nBit Depth\nValue Range\n\n\n\n\nbool\n1 or 8\ntrue/false (1/0)\n\n\nbyte\n8\n0-255 (unsigned)\n\n\nchar\n8\n-128-127 (signed)\n\n\nint\n16\n-32768-32767 (signed)\n\n\nuint\n16\n0-65535 (unsigned)\n\n\nlong\n32\n-2147483648-2147483647 (signed)\n\n\nfloat\n32\n1.2E-38–3.4E38 (signed)\n\n\ndouble\n64\n2.3E-308-1.7E308 (signed)"
  },
  {
    "objectID": "slides/c-programming-slides.html#how-are-floating-point-numbers-represented",
    "href": "slides/c-programming-slides.html#how-are-floating-point-numbers-represented",
    "title": "C Programming",
    "section": "How are floating point numbers represented?",
    "text": "How are floating point numbers represented?"
  },
  {
    "objectID": "slides/c-programming-slides.html#declaring-variables-by-data-type-c",
    "href": "slides/c-programming-slides.html#declaring-variables-by-data-type-c",
    "title": "C Programming",
    "section": "Declaring Variables by Data Type (C)",
    "text": "Declaring Variables by Data Type (C)\n\nMatlab, by default, declares variables when first used, and defaults all numerical data to be double (64-bit floating point).\n\nPython infers data type based on the value assigned to the variable.\n\nIn C, we must explicitly declare the data type of a variable, and the data type cannot change over the life of the variable."
  },
  {
    "objectID": "slides/c-programming-slides.html#why-not-just-make-all-numbers-floatsdoubles",
    "href": "slides/c-programming-slides.html#why-not-just-make-all-numbers-floatsdoubles",
    "title": "C Programming",
    "section": "Why not just make all numbers floats/doubles?",
    "text": "Why not just make all numbers floats/doubles?\nThe nRF52833 only has 128 kB of RAM. If we can use smaller data types, we can store more data in memory.\n\nint16_t my_int = 5; // 16-bit signed integer\nuint16_t my_uint = 5; // 16-bit unsigned integer\nfloat my_float = 5.0; // 32-bit floating point"
  },
  {
    "objectID": "slides/c-programming-slides.html#variable-scope",
    "href": "slides/c-programming-slides.html#variable-scope",
    "title": "C Programming",
    "section": "Variable Scope",
    "text": "Variable Scope\nVariables can be limited in their scope (where they are accessible).\n\nGlobal variables are defined outside of functions and are globally available to everything in your program.\nLocal variables are defined inside of functions and are only visible within that function.\n\n#include &lt;zephyr/kernel.h&gt;\n\nint my_global_variable; // global variable\n\nvoid my_function(int my_input) {\n  int my_local_variable; // local variable\n  // do something\n}"
  },
  {
    "objectID": "slides/c-programming-slides.html#constants-const",
    "href": "slides/c-programming-slides.html#constants-const",
    "title": "C Programming",
    "section": "Constants (const)",
    "text": "Constants (const)\n\nVariables that have values that will not change can be declared as constants (const).\nConstant variables consume a fixed amount of memory based on their data type when they are declared and defined."
  },
  {
    "objectID": "slides/c-programming-slides.html#macros",
    "href": "slides/c-programming-slides.html#macros",
    "title": "C Programming",
    "section": "MACROS",
    "text": "MACROS\n\nMACROS are preprocessor directives that are replaced with their values (constants of function definitions) before the code is compiled.\nMACROS save memory compared to using constant variables and can improve readability.\nDefined with the #define directive after #include preprocessor directives and are typically typed in ALLCAPS.\nVS Code will color highlight MACROs differently than variables.\n\n#include &lt;zephyr/kernel.h&gt;\n\n#define MY_MACRO 1\n\nvoid my_function(int my_input) {\n  // do something\n  int a = MY_MACRO * my_input;\n}"
  },
  {
    "objectID": "slides/c-programming-slides.html#static-variables",
    "href": "slides/c-programming-slides.html#static-variables",
    "title": "C Programming",
    "section": "Static Variables",
    "text": "Static Variables\nStatic variables have different properties depending on whether they are local or global. Static variables get their own memory space that is not shared with other variables that are more dynamically allocated.\nGlobal\n\nGlobally-defined static variables are limited in scope to the *.c file they are defined in.\nProtects against name collisions (linkage) across multiple source code files.\n\nLocal\n\nStatic variables defined in functions retain their value between function calls (exit and re-entry).\n\n#include &lt;zephyr/kernel.h&gt;\n\nvoid my_function(int my_input) {\n  static int my_static_variable = 0; // static local variable\n  my_static_variable += my_input;\n  printk(\"The value of my_static_variable is %d\\n\", my_static_variable);\n}"
  },
  {
    "objectID": "slides/c-programming-slides.html#typecasting",
    "href": "slides/c-programming-slides.html#typecasting",
    "title": "C Programming",
    "section": "Typecasting",
    "text": "Typecasting\n\nUse different data types in mathematical operations can lead to unexpected results.\n\n\n\n\n\n\n\nWarning\n\n\nWatch out for integer math (fixed point) that will yield a non-integer (floating point) result.\n\n\n\nvoid main(void) {\n  int a = 5;\n  int b = 3;\n  float c;\n\n  c = a / b; // c = 1.0\n}"
  },
  {
    "objectID": "slides/c-programming-slides.html#bit-depth",
    "href": "slides/c-programming-slides.html#bit-depth",
    "title": "C Programming",
    "section": "Bit Depth",
    "text": "Bit Depth\n\n\n\n\n\n\nWarning\n\n\nWatch out for the range of your data type! If your mathematical operation exceeds the min/max value of the bit depth, the data will “wrap around”.\n\n\n\n\nuint8_t a = 255; // 8-bit unsigned integer\n\na = a + 1; // a = 0"
  },
  {
    "objectID": "slides/c-programming-slides.html#printing-logging-data-types",
    "href": "slides/c-programming-slides.html#printing-logging-data-types",
    "title": "C Programming",
    "section": "Printing / Logging Data Types",
    "text": "Printing / Logging Data Types\n\n\n\nFormatted Print Placeholder\nData Type\n\n\n\n\n%d\ndecimal (int)\n\n\n%ld\nlong decimal (32-bit)\n\n\n%lld\nlong long decimal (64-bit)\n\n\n%u\nunsigned decimal (uint)\n\n\n%f\nfloat\n\n\n%c\nchar\n\n\n%s\nstring (char array)\n\n\n%x\nhex (int)\n\n\n%b\nbinary (int)\n\n\n%p\npointer (memory address)\n\n\n\nprintk(\"The value of a is %d\\n\", a); // %d must match the data type of a to properly print its value"
  },
  {
    "objectID": "slides/c-programming-slides.html#pointers",
    "href": "slides/c-programming-slides.html#pointers",
    "title": "C Programming",
    "section": "Pointers",
    "text": "Pointers\nOne of the greatest strengths–and most dangerous aspects–of C is the use of pointers. A pointer is a variable that stores the memory address of another variable. Pointers are used to pass variables by reference (in contrast to value) to functions, and to dynamically allocate memory.\nPointers save memory and time by not copying the value of a variable to a function. Instead, the function can directly access the variable in memory. This is especially useful for large data structures."
  },
  {
    "objectID": "slides/c-programming-slides.html#general-c-code-structure",
    "href": "slides/c-programming-slides.html#general-c-code-structure",
    "title": "C Programming",
    "section": "General C Code Structure",
    "text": "General C Code Structure\n\nOrganization of C code is very important! Developers will “expect” certain things to be in certain places.\nC code is compiled (built) into a binary executable that is loaded onto the microcontroller. It is not “run” on-the-fly as an interpreted language like Matlab or Python."
  },
  {
    "objectID": "slides/c-programming-slides.html#coding-style",
    "href": "slides/c-programming-slides.html#coding-style",
    "title": "C Programming",
    "section": "Coding Style",
    "text": "Coding Style\n\nAll lines of code must end with a semicolon ;.\n\nIndentation helps with readability, but does nothing to delineate code blocks.\n\nCode blocks are delineated by curly braces {}."
  },
  {
    "objectID": "slides/c-programming-slides.html#return-typescodes",
    "href": "slides/c-programming-slides.html#return-typescodes",
    "title": "C Programming",
    "section": "Return Types/Codes",
    "text": "Return Types/Codes\n\nMost C functions will return a value, but that value tends to be an exit code, not a value being assigned to a variable.\nThese codes are used to indicate the success or failure of the function, and tend to be ints.\n\nReturned 0 indicates success, and any other value indicates failure.\nThe return type is defined in the function prototype.\n\nIf the function does not return a value, the return type is void."
  },
  {
    "objectID": "slides/c-programming-slides.html#function-arguments",
    "href": "slides/c-programming-slides.html#function-arguments",
    "title": "C Programming",
    "section": "Function Arguments",
    "text": "Function Arguments\n\nFunction arguments are defined in the function prototype.\nMost of our arguments will be passed by reference (pointers to memory addresses), not value. This means that the function will be able to change the value of the variable passed to it by pointer reference.\nIf the function does not take any arguments, the argument list is void. The function may still operate on variables if they are global."
  },
  {
    "objectID": "slides/c-programming-slides.html#main",
    "href": "slides/c-programming-slides.html#main",
    "title": "C Programming",
    "section": "main",
    "text": "main\n\nIn Zephyr, the primary source code file is src/main.c.\nIn Zephyr (and many other C frameworks), the main() function is the entry point of the program."
  },
  {
    "objectID": "slides/c-programming-slides.html#arrays",
    "href": "slides/c-programming-slides.html#arrays",
    "title": "C Programming",
    "section": "Arrays",
    "text": "Arrays\n\nArrays are a contiguous block of memory that can store multiple values of the same data type.\nArrays are declared with a fixed length.\nArrays are indexed starting at 0 (not 1!).\nArrays can be declared with an initial value, or initialized later.\n\nint my_array[5] = {1, 2, 3, 4, 5};\nint my_array[5] = {0};\nint my_array[5];\n\nThe only time to populate all of the elements of an array is when it is initialized. Otherwise, you can:\n\nPopulate each element individually (e.g., a for loop), or\nCreate a new array and then copy it over the existing array using memcpy()."
  },
  {
    "objectID": "slides/c-programming-slides.html#enumerations-enums",
    "href": "slides/c-programming-slides.html#enumerations-enums",
    "title": "C Programming",
    "section": "Enumerations (Enums)",
    "text": "Enumerations (Enums)\n\nEnums are a way to assign a name to a value.\nEnums are declared with a fixed length.\nEnums are indexed starting at 0 (not 1!).\nVery useful for more verbose / readable switch/case statements."
  },
  {
    "objectID": "slides/c-programming-slides.html#structs",
    "href": "slides/c-programming-slides.html#structs",
    "title": "C Programming",
    "section": "Structs",
    "text": "Structs\n\nStructures group multiple variables together.\nStructures are declared with a fixed length.\nNice data structure to organize variables that are related to each other.\n\nstruct Person {\n  char name[50];\n  int age;\n  float height;\n};\n\nvoid main(void) {\n  struct Person my_person = {\"John\", 32, 1.8};\n\n  printk(\"My name is %s\\n\", my_person.name);\n  printk(\"I am %d years old\\n\", my_person.age);\n  printk(\"I am %f meters tall\\n\", my_person.height);\n}"
  },
  {
    "objectID": "slides/c-programming-slides.html#conditional-statements",
    "href": "slides/c-programming-slides.html#conditional-statements",
    "title": "C Programming",
    "section": "Conditional Statements",
    "text": "Conditional Statements\nif (a == 5) {\n  // do something\n} else if (b != 3) {\n  // do something else\n} else {\n  // do something else\n}"
  },
  {
    "objectID": "slides/c-programming-slides.html#loops",
    "href": "slides/c-programming-slides.html#loops",
    "title": "C Programming",
    "section": "Loops",
    "text": "Loops\nfor (int i = 0; i &lt; 10; i++) {\n  // do something\n}\n\nwhile (a &lt; 10) {\n  // do something\n  a++;\n}\n\nwhile () {\n  // do something\n  if (a == 10) {\n    break; // break out of loop\n  }\n}"
  },
  {
    "objectID": "slides/c-programming-slides.html#project-libraries",
    "href": "slides/c-programming-slides.html#project-libraries",
    "title": "C Programming",
    "section": "Project Libraries",
    "text": "Project Libraries\n\nWriting your own libraries is a great way to organize your code and make it more readable.\nLibraries can also be shared with others and re-used in other projects.\n#include \"your_library.h\" can be used to include a library in your source code.\nA library contains a pair of files:\n\nyour_library.h contains the function prototypes and macro definitions.\nyour_library.c contains the function definitions.\n\nTo make sure that a library doesn’t get included multiple times, use the following syntax in your header file:"
  },
  {
    "objectID": "slides/c-programming-slides.html#cmake-build-system",
    "href": "slides/c-programming-slides.html#cmake-build-system",
    "title": "C Programming",
    "section": "CMake Build System",
    "text": "CMake Build System\n\nZephyr uses cmake as its build system, which helps link libraries used in your source code.\nYou will also need to add the library to your CMakeLists.txt file:\n\ntarget_sources(app PRIVATE src/main.c src/your_library.c)"
  },
  {
    "objectID": "slides/c-programming-slides.html#memory-management",
    "href": "slides/c-programming-slides.html#memory-management",
    "title": "C Programming",
    "section": "Memory Management",
    "text": "Memory Management\n\nA great summary of the different types of memory in C is summarized below from http://www.gotw.ca/gotw/009.htm:"
  },
  {
    "objectID": "slides/c-programming-slides.html#const-data",
    "href": "slides/c-programming-slides.html#const-data",
    "title": "C Programming",
    "section": "const Data",
    "text": "const Data\n\nImmutable data that are read-only; trying to modify it is undefined.\n\nStore data whose values are known at compile time and guarded against inadvertent modification.\n\nAll data in this area are available during the entire lifetime of the program.\nOptimized memory usage since multiple references to the same const data can share the same memory location."
  },
  {
    "objectID": "slides/c-programming-slides.html#stack",
    "href": "slides/c-programming-slides.html#stack",
    "title": "C Programming",
    "section": "Stack",
    "text": "Stack\n\nStores automatic variables.\nTypically allocation is much faster than for dynamic storage (heap or free store) because a memory allocation involves only pointer increment rather than more complex management.\n\nObjects are constructed immediately after memory is allocated and destroyed immediately before memory is deallocated, so there is no opportunity for programmers to directly manipulate allocated but uninitialized stack space (barring willful tampering using explicit dtors and placement new)."
  },
  {
    "objectID": "slides/c-programming-slides.html#free-store",
    "href": "slides/c-programming-slides.html#free-store",
    "title": "C Programming",
    "section": "Free Store",
    "text": "Free Store\n\nThe free store is one of the two dynamic memory areas, allocated/freed by new/delete."
  },
  {
    "objectID": "slides/c-programming-slides.html#heap",
    "href": "slides/c-programming-slides.html#heap",
    "title": "C Programming",
    "section": "Heap",
    "text": "Heap\n\nThe other dynamic memory area, allocated/freed by malloc()/free() and their variants."
  },
  {
    "objectID": "slides/c-programming-slides.html#globalstatic",
    "href": "slides/c-programming-slides.html#globalstatic",
    "title": "C Programming",
    "section": "Global/Static",
    "text": "Global/Static\n\nGlobal or static variables and objects have their storage allocated at program startup, but may not be initialized until after the program has begun executing."
  },
  {
    "objectID": "slides/c-programming-slides.html#resources",
    "href": "slides/c-programming-slides.html#resources",
    "title": "C Programming",
    "section": "Resources",
    "text": "Resources\n\nC Programming Language\nNordic DevAcademy: Debugging"
  },
  {
    "objectID": "slides/event-driven-state-machine.html",
    "href": "slides/event-driven-state-machine.html",
    "title": "Event-Driven State Machine",
    "section": "",
    "text": "Nested conditional logic main loops are hard to read and maintain.\nState machines are a common way to implement complex logic.\nStates have transitions that are triggered by events or conditions.\n\nStates can have entry / exit routines that are executed when the state is entered / exited.\nThe “run” status of a state is commonly referred to as the “state machine tick” and recurrently loops.\n\nState diagrams are used to visualize state machines.\nState structures are used to capture variables associated with describing the state.",
    "crumbs": [
      "Learning Modules",
      "Event-Driven State Machines"
    ]
  },
  {
    "objectID": "slides/event-driven-state-machine.html#introduction",
    "href": "slides/event-driven-state-machine.html#introduction",
    "title": "Event-Driven State Machine",
    "section": "",
    "text": "Nested conditional logic main loops are hard to read and maintain.\nState machines are a common way to implement complex logic.\nStates have transitions that are triggered by events or conditions.\n\nStates can have entry / exit routines that are executed when the state is entered / exited.\nThe “run” status of a state is commonly referred to as the “state machine tick” and recurrently loops.\n\nState diagrams are used to visualize state machines.\nState structures are used to capture variables associated with describing the state.",
    "crumbs": [
      "Learning Modules",
      "Event-Driven State Machines"
    ]
  },
  {
    "objectID": "slides/event-driven-state-machine.html#in-class-demo",
    "href": "slides/event-driven-state-machine.html#in-class-demo",
    "title": "Event-Driven State Machine",
    "section": "In-Class Demo",
    "text": "In-Class Demo\n\nYou (and your daily routine)\n\nWhat are your “states”?\nWhat are your “events”?\n\nICD",
    "crumbs": [
      "Learning Modules",
      "Event-Driven State Machines"
    ]
  },
  {
    "objectID": "slides/event-driven-state-machine.html#state-diagram",
    "href": "slides/event-driven-state-machine.html#state-diagram",
    "title": "Event-Driven State Machine",
    "section": "State Diagram",
    "text": "State Diagram\n\nGenerating the state diagram is the first step in implementing a state machine.\nUsually start with “pencil and paper” to sketch out the states and transitions.\nConsider the following:\n\nWhat are the states?\nWhat are the transitions?\nWhat are the events that trigger transitions?\nWhat are the entry / exit routines for each state?\n\nUML (Universal Modeling Language) is a common way to represent state diagrams.",
    "crumbs": [
      "Learning Modules",
      "Event-Driven State Machines"
    ]
  },
  {
    "objectID": "slides/event-driven-state-machine.html#plantuml-example",
    "href": "slides/event-driven-state-machine.html#plantuml-example",
    "title": "Event-Driven State Machine",
    "section": "PlantUML Example",
    "text": "PlantUML Example\n@startuml\n\n[*] -&gt; Init\n\nstate Init {\n    init_run: Do Stuff\n}\n\nstate RhythmDetect {\n    rhythm_detect_run: Detect Rhythm\n}\n\nstate Sleep {\n    sleep_run: Save Power\n}\n\nstate Pace {\n    pace_run: Pace\n}\n\nstate OTA {\n    ota_init: Download Update\n    ota_init -&gt; ota_run\n    ota_run: Over The Air Update\n    ota_run -&gt; ota_exit\n    ota_exit: Post Successful OTA\n}\n\nstate Error {\n    error_run: Put device into safe mode\n}\n\nInit -&gt; RhythmDetect : Successful Init\nInit -d-&gt; Error : Init Fault Error Code\nRhythmDetect -&gt; Pace : Arrhythmia Detected\nPace -&gt; RhythmDetect : Pacing Timer Expired\nRhythmDetect -d-&gt; Sleep : NSR\nSleep -&gt; RhythmDetect: Sleep Timer Expired\nSleep -&gt; OTA : OTA Button Pressed\nOTA -&gt; RhythmDetect : OTA Success Kernel Event Posted\nError -&gt; [*]\n\n@enduml",
    "crumbs": [
      "Learning Modules",
      "Event-Driven State Machines"
    ]
  },
  {
    "objectID": "slides/event-driven-state-machine.html#kernel-events",
    "href": "slides/event-driven-state-machine.html#kernel-events",
    "title": "Event-Driven State Machine",
    "section": "Kernel Events",
    "text": "Kernel Events\n\nWhat is a “kernel”?\n\nThe part of the RTOS that interacts with hardware.\n\nKernel events can be used to indicate that “something” has happened, which may dictate the function of the state machine.\n\nButton press\nSensor crossing a threshold\nTimer expiring\n\nWhen an event occurs, it triggers an Interupt Service Routine (ISR), which calls a callback function.",
    "crumbs": [
      "Learning Modules",
      "Event-Driven State Machines"
    ]
  },
  {
    "objectID": "slides/event-driven-state-machine.html#code-switch-case",
    "href": "slides/event-driven-state-machine.html#code-switch-case",
    "title": "Event-Driven State Machine",
    "section": "Code: Switch-Case",
    "text": "Code: Switch-Case\n\nThe simplest implementation of a state machine is a switch-case statement.\nThe switch statement is used to select the current state.\nThe case statements are used to implement the logic for each state.\n\nCases can be nested to implement sub-states.\nEnumerations can be used to give states verbose names instead of numbers.\n\nThe break statement is used to exit the switch statement.\nThe default statement is used to handle unexpected states.",
    "crumbs": [
      "Learning Modules",
      "Event-Driven State Machines"
    ]
  },
  {
    "objectID": "slides/event-driven-state-machine.html#pseudo-code",
    "href": "slides/event-driven-state-machine.html#pseudo-code",
    "title": "Event-Driven State Machine",
    "section": "Pseudo-Code",
    "text": "Pseudo-Code\nenum device_states { init, run, sleep };\n\nint device_state = init; // initialize state\n\n/* structure to bookkeep state variables */\nstruct device_state_vars {\n    int var1;\n    int var2;\n};\n\nwhile (1) {\n    switch (device_state) {\n        case init:\n            /* do stuff to initialize device */\n            device_state = run; // change the state\n            break;  // exit the switch statement\n        case run:\n            /* run device */\n            if (condition) {\n                device_state = sleep;\n            }\n            break;\n        case sleep:\n            /* sleep device */\n            if (condition) {\n                device_state = run;\n            }\n            break;\n        default:\n            /* handle unexpected state */\n            break;\n    }\n}\nThe switch-case approach loses some of its elegance when there are many states and many transitions and states have entry / exit routines.",
    "crumbs": [
      "Learning Modules",
      "Event-Driven State Machines"
    ]
  },
  {
    "objectID": "slides/event-driven-state-machine.html#resources",
    "href": "slides/event-driven-state-machine.html#resources",
    "title": "Event-Driven State Machine",
    "section": "Resources",
    "text": "Resources\n\nDigiKey: How to Program and Arduino Finite State Machine\nInstructables: Finite State Machine on an Arduino",
    "crumbs": [
      "Learning Modules",
      "Event-Driven State Machines"
    ]
  },
  {
    "objectID": "slides/event-driven-state-machine-slides.html#introduction",
    "href": "slides/event-driven-state-machine-slides.html#introduction",
    "title": "Event-Driven State Machine",
    "section": "Introduction",
    "text": "Introduction\n\nNested conditional logic main loops are hard to read and maintain.\nState machines are a common way to implement complex logic.\nStates have transitions that are triggered by events or conditions.\n\nStates can have entry / exit routines that are executed when the state is entered / exited.\nThe “run” status of a state is commonly referred to as the “state machine tick” and recurrently loops.\n\nState diagrams are used to visualize state machines.\nState structures are used to capture variables associated with describing the state."
  },
  {
    "objectID": "slides/event-driven-state-machine-slides.html#in-class-demo",
    "href": "slides/event-driven-state-machine-slides.html#in-class-demo",
    "title": "Event-Driven State Machine",
    "section": "In-Class Demo",
    "text": "In-Class Demo\n\nYou (and your daily routine)\n\nWhat are your “states”?\nWhat are your “events”?\n\nICD"
  },
  {
    "objectID": "slides/event-driven-state-machine-slides.html#state-diagram",
    "href": "slides/event-driven-state-machine-slides.html#state-diagram",
    "title": "Event-Driven State Machine",
    "section": "State Diagram",
    "text": "State Diagram\n\nGenerating the state diagram is the first step in implementing a state machine.\nUsually start with “pencil and paper” to sketch out the states and transitions.\nConsider the following:\n\nWhat are the states?\nWhat are the transitions?\nWhat are the events that trigger transitions?\nWhat are the entry / exit routines for each state?\n\nUML (Universal Modeling Language) is a common way to represent state diagrams."
  },
  {
    "objectID": "slides/event-driven-state-machine-slides.html#plantuml-example",
    "href": "slides/event-driven-state-machine-slides.html#plantuml-example",
    "title": "Event-Driven State Machine",
    "section": "PlantUML Example",
    "text": "PlantUML Example\n@startuml\n\n[*] -&gt; Init\n\nstate Init {\n    init_run: Do Stuff\n}\n\nstate RhythmDetect {\n    rhythm_detect_run: Detect Rhythm\n}\n\nstate Sleep {\n    sleep_run: Save Power\n}\n\nstate Pace {\n    pace_run: Pace\n}\n\nstate OTA {\n    ota_init: Download Update\n    ota_init -&gt; ota_run\n    ota_run: Over The Air Update\n    ota_run -&gt; ota_exit\n    ota_exit: Post Successful OTA\n}\n\nstate Error {\n    error_run: Put device into safe mode\n}\n\nInit -&gt; RhythmDetect : Successful Init\nInit -d-&gt; Error : Init Fault Error Code\nRhythmDetect -&gt; Pace : Arrhythmia Detected\nPace -&gt; RhythmDetect : Pacing Timer Expired\nRhythmDetect -d-&gt; Sleep : NSR\nSleep -&gt; RhythmDetect: Sleep Timer Expired\nSleep -&gt; OTA : OTA Button Pressed\nOTA -&gt; RhythmDetect : OTA Success Kernel Event Posted\nError -&gt; [*]\n\n@enduml"
  },
  {
    "objectID": "slides/event-driven-state-machine-slides.html#kernel-events",
    "href": "slides/event-driven-state-machine-slides.html#kernel-events",
    "title": "Event-Driven State Machine",
    "section": "Kernel Events",
    "text": "Kernel Events\n\nWhat is a “kernel”?\n\nThe part of the RTOS that interacts with hardware.\n\nKernel events can be used to indicate that “something” has happened, which may dictate the function of the state machine.\n\nButton press\nSensor crossing a threshold\nTimer expiring\n\nWhen an event occurs, it triggers an Interupt Service Routine (ISR), which calls a callback function."
  },
  {
    "objectID": "slides/event-driven-state-machine-slides.html#code-switch-case",
    "href": "slides/event-driven-state-machine-slides.html#code-switch-case",
    "title": "Event-Driven State Machine",
    "section": "Code: Switch-Case",
    "text": "Code: Switch-Case\n\nThe simplest implementation of a state machine is a switch-case statement.\nThe switch statement is used to select the current state.\nThe case statements are used to implement the logic for each state.\n\nCases can be nested to implement sub-states.\nEnumerations can be used to give states verbose names instead of numbers.\n\nThe break statement is used to exit the switch statement.\nThe default statement is used to handle unexpected states."
  },
  {
    "objectID": "slides/event-driven-state-machine-slides.html#pseudo-code",
    "href": "slides/event-driven-state-machine-slides.html#pseudo-code",
    "title": "Event-Driven State Machine",
    "section": "Pseudo-Code",
    "text": "Pseudo-Code\nenum device_states { init, run, sleep };\n\nint device_state = init; // initialize state\n\n/* structure to bookkeep state variables */\nstruct device_state_vars {\n    int var1;\n    int var2;\n};\n\nwhile (1) {\n    switch (device_state) {\n        case init:\n            /* do stuff to initialize device */\n            device_state = run; // change the state\n            break;  // exit the switch statement\n        case run:\n            /* run device */\n            if (condition) {\n                device_state = sleep;\n            }\n            break;\n        case sleep:\n            /* sleep device */\n            if (condition) {\n                device_state = run;\n            }\n            break;\n        default:\n            /* handle unexpected state */\n            break;\n    }\n}\nThe switch-case approach loses some of its elegance when there are many states and many transitions and states have entry / exit routines."
  },
  {
    "objectID": "slides/event-driven-state-machine-slides.html#resources",
    "href": "slides/event-driven-state-machine-slides.html#resources",
    "title": "Event-Driven State Machine",
    "section": "Resources",
    "text": "Resources\n\nDigiKey: How to Program and Arduino Finite State Machine\nInstructables: Finite State Machine on an Arduino"
  },
  {
    "objectID": "TODO.html",
    "href": "TODO.html",
    "title": "TODO",
    "section": "",
    "text": "FUTURE: Unit tests w/ hardware emulators\nImprove the mechanics of giving code feedback to integrate with the git repo and be more timely; consider using an autograder based on an LLM\n\n\n\n\n\nCreate GPIO quiz\nCreate timers quiz\n\n\n\n\n\nUpdate schedule & syllabus\nSetup Ed Discussion\n\nDiscussion Categories\n\nSetup Gradescope\n\nDuplicate assignments\n\nPublish Canvas\n\nAdd TAs and lab staff\nLink syllabus\n\nSetup Pratt AV Panopto recording (https://it.pratt.duke.edu/av)"
  },
  {
    "objectID": "TODO.html#labs",
    "href": "TODO.html#labs",
    "title": "TODO",
    "section": "",
    "text": "FUTURE: Unit tests w/ hardware emulators\nImprove the mechanics of giving code feedback to integrate with the git repo and be more timely; consider using an autograder based on an LLM"
  },
  {
    "objectID": "TODO.html#quizzes",
    "href": "TODO.html#quizzes",
    "title": "TODO",
    "section": "",
    "text": "Create GPIO quiz\nCreate timers quiz"
  },
  {
    "objectID": "TODO.html#new-semester-tasks",
    "href": "TODO.html#new-semester-tasks",
    "title": "TODO",
    "section": "",
    "text": "Update schedule & syllabus\nSetup Ed Discussion\n\nDiscussion Categories\n\nSetup Gradescope\n\nDuplicate assignments\n\nPublish Canvas\n\nAdd TAs and lab staff\nLink syllabus\n\nSetup Pratt AV Panopto recording (https://it.pratt.duke.edu/av)"
  },
  {
    "objectID": "resources/how-to-generate-ecg-waveforms.html",
    "href": "resources/how-to-generate-ecg-waveforms.html",
    "title": "How to Generate ECG Waveforms",
    "section": "",
    "text": "This video shows how to generate an ECG waveform using the LeCroy WaveStation 2012.",
    "crumbs": [
      "Resources",
      "How to Generate ECG Waveforms"
    ]
  },
  {
    "objectID": "resources/how-to-generate-ecg-waveforms.html#functionarbitrary-waveform-generator",
    "href": "resources/how-to-generate-ecg-waveforms.html#functionarbitrary-waveform-generator",
    "title": "How to Generate ECG Waveforms",
    "section": "",
    "text": "This video shows how to generate an ECG waveform using the LeCroy WaveStation 2012.",
    "crumbs": [
      "Resources",
      "How to Generate ECG Waveforms"
    ]
  },
  {
    "objectID": "resources/how-to-generate-ecg-waveforms.html#digilent-analog-discovery-waveform-generator",
    "href": "resources/how-to-generate-ecg-waveforms.html#digilent-analog-discovery-waveform-generator",
    "title": "How to Generate ECG Waveforms",
    "section": "Digilent Analog Discovery Waveform Generator",
    "text": "Digilent Analog Discovery Waveform Generator\nThe following script can be used to generate an ECG waveform on a Digilent Analog Discovery:\n// Constants for waveforms\nvar A_P = 0.2;       // P-wave amplitude (increased for realism)\nvar mu_P = 0.15;     // P-wave center (earlier position)\nvar sigma_P = 0.03;  // P-wave width\n\nvar A_Q = -0.2;      // Q-wave amplitude (swapped with S)\nvar mu_Q = 0.45;     // Q-wave center\nvar sigma_Q = 0.015; // Q-wave width\n\nvar A_R = 1.0;       // R-wave amplitude (unchanged)\nvar mu_R = 0.5;      // R-wave center\nvar sigma_R = 0.02;  // R-wave width\n\nvar A_S = -0.3;      // S-wave amplitude (swapped with Q)\nvar mu_S = 0.55;     // S-wave center\nvar sigma_S = 0.015; // S-wave width\n\nvar A_T = 0.4;       // T-wave amplitude (increased for realism)\nvar mu_T = 0.95;     // T-wave center (further shifted to extend ST segment)\nvar sigma_T = 0.05;  // T-wave width\n\n// Euler's number (approximation)\nvar E = 2.71828;\n\n// P-wave\nvar P_wave = A_P * pow(E, -pow((X - mu_P), 2) / (2 * pow(sigma_P, 2)));\n\n// QRS complex as a combination of Q, R, and S waves\nvar Q_wave = A_Q * pow(E, -pow((X - mu_Q), 2) / (2 * pow(sigma_Q, 2)));\nvar R_wave = A_R * pow(E, -pow((X - mu_R), 2) / (2 * pow(sigma_R, 2)));\nvar S_wave = A_S * pow(E, -pow((X - mu_S), 2) / (2 * pow(sigma_S, 2)));\nvar QRS_wave = Q_wave + R_wave + S_wave;\n\n// T-wave (shifted later for realistic ST segment)\nvar T_wave = A_T * pow(E, -pow((X - mu_T), 2) / (2 * pow(sigma_T, 2)));\n\n// Noise\nvar noise = 0.1 * (random() - 0.5); // Noise in range [-0.05, 0.05]\n\n// Combine components\nP_wave + QRS_wave + T_wave;",
    "crumbs": [
      "Resources",
      "How to Generate ECG Waveforms"
    ]
  },
  {
    "objectID": "resources/debugging.html",
    "href": "resources/debugging.html",
    "title": "Zephyr: Debugging in VS Code",
    "section": "",
    "text": "A debugger is a tool that allows you to step through the code and inspect the state of the program.\nIt allows you to set breakpoints and single-step through the code.\nIt allows you to inspect the values of variables and the call stack.\nIt allows you to set conditional breakpoints.\nIt allows you to watch expressions and variables.\nIt allows you to inspect states and threads.",
    "crumbs": [
      "Resources",
      "Zephyr: Debugging in VS Code"
    ]
  },
  {
    "objectID": "resources/debugging.html#what-is-a-debugger",
    "href": "resources/debugging.html#what-is-a-debugger",
    "title": "Zephyr: Debugging in VS Code",
    "section": "",
    "text": "A debugger is a tool that allows you to step through the code and inspect the state of the program.\nIt allows you to set breakpoints and single-step through the code.\nIt allows you to inspect the values of variables and the call stack.\nIt allows you to set conditional breakpoints.\nIt allows you to watch expressions and variables.\nIt allows you to inspect states and threads.",
    "crumbs": [
      "Resources",
      "Zephyr: Debugging in VS Code"
    ]
  },
  {
    "objectID": "resources/debugging.html#nordic-devacademy-debugging",
    "href": "resources/debugging.html#nordic-devacademy-debugging",
    "title": "Zephyr: Debugging in VS Code",
    "section": "Nordic DevAcademy: Debugging",
    "text": "Nordic DevAcademy: Debugging\nNordic: DevAcademy: Debugging",
    "crumbs": [
      "Resources",
      "Zephyr: Debugging in VS Code"
    ]
  },
  {
    "objectID": "resources/git.html",
    "href": "resources/git.html",
    "title": "Git: Getting Started",
    "section": "",
    "text": "Git - version control software\n\n\n\n\n\n\n\nNote\n\n\n\nMacOS usually comes with git pre-installed, so there is no need to install anything else.\n\n\n\nAfter installing git, please configure it: Getting Started - First-Time Git Setup\nThe setup steps above should create a ~/.gitconfig file that has some barebones configuration options. We can expand that a bit by manually editing it with the following content:\n\n[user]\n    name = your first and last name\n    email = yournetid@duke.edu\n[alias]\n    lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative\n[core]\n    editor = nano\n    autocrlf = input\n    preloadindex = true\n    fileMode = false\n[color]\n    status = auto\n    branch = auto\n    interactive = auto\n    diff = auto\n    ui = auto\n[push]\n    default = current\n    autoSetupRemote = true\n[pull]\n    rebase = false\n[merge]\n    ff = no\n[init]\n    defaultBranch = main\n\nThe above configuration will:\n\nSet your name and email address for commits\nSet up a git lg alias that will show a nice graph of the commit history\nChange the default editor for making commit messages from vi to nano.\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou can change this to something else, like VS Code!\n\n\n\nThis is a good tutorial on using git within VS Code: Using Git source control in VS Code",
    "crumbs": [
      "Resources",
      "Git Version Control"
    ]
  },
  {
    "objectID": "resources/git.html#installation-configuration",
    "href": "resources/git.html#installation-configuration",
    "title": "Git: Getting Started",
    "section": "",
    "text": "Git - version control software\n\n\n\n\n\n\n\nNote\n\n\n\nMacOS usually comes with git pre-installed, so there is no need to install anything else.\n\n\n\nAfter installing git, please configure it: Getting Started - First-Time Git Setup\nThe setup steps above should create a ~/.gitconfig file that has some barebones configuration options. We can expand that a bit by manually editing it with the following content:\n\n[user]\n    name = your first and last name\n    email = yournetid@duke.edu\n[alias]\n    lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative\n[core]\n    editor = nano\n    autocrlf = input\n    preloadindex = true\n    fileMode = false\n[color]\n    status = auto\n    branch = auto\n    interactive = auto\n    diff = auto\n    ui = auto\n[push]\n    default = current\n    autoSetupRemote = true\n[pull]\n    rebase = false\n[merge]\n    ff = no\n[init]\n    defaultBranch = main\n\nThe above configuration will:\n\nSet your name and email address for commits\nSet up a git lg alias that will show a nice graph of the commit history\nChange the default editor for making commit messages from vi to nano.\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou can change this to something else, like VS Code!\n\n\n\nThis is a good tutorial on using git within VS Code: Using Git source control in VS Code",
    "crumbs": [
      "Resources",
      "Git Version Control"
    ]
  },
  {
    "objectID": "resources/git.html#setup-duke-gitlab-account",
    "href": "resources/git.html#setup-duke-gitlab-account",
    "title": "Git: Getting Started",
    "section": "Setup Duke GitLab Account",
    "text": "Setup Duke GitLab Account\nWhile GitHub is a very popular public git repository hosting site, we will be using Duke’s GitLab server. Please make sure you can log into https://gitlab.oit.duke.edu using your Oath2 NetID authentication.\n\n\n\n\n\n\nWarning\n\n\n\nThis is not gitlab.com!\n\n\n\n\n\n\n\n\nCaution\n\n\n\nDo not edit files in remote git repositories using the GitLab web interface!! Only work with your repository files using your local clone of the repository.",
    "crumbs": [
      "Resources",
      "Git Version Control"
    ]
  },
  {
    "objectID": "resources/git.html#ssh-key-authentication",
    "href": "resources/git.html#ssh-key-authentication",
    "title": "Git: Getting Started",
    "section": "SSH Key Authentication",
    "text": "SSH Key Authentication\nWe will use SSH keys to authenticate us on GitLab to be able to clone/push/pull from GitLab without needing to always enter your username and password.\nTo setup an SSH key and add it to your GitLab profile:\n\n\n\n\n\n\nWarning\n\n\n\nThe guide below will reference github.com; you want to substitute gitlab.oit.duke.edu.\n\n\n\nGenerate a New SSH Key\n\nWhile your private key is most secure by encrypting it with a passphrase, you will need to either enter that passphrase everytime the key is used, or you will need to add it to your local credential manager (i.e., keychain) or ssh-agent to keep it unlocked.\nIf you are just using this SSH key for this class, you can use an empty passphrase and not need to worry about needing to deal with the password management.\n\nAdd your SSH key to your GitLab Profile\n\n\n\n\n\n\n\nWarning\n\n\n\nThe guide above will reference gitlab.com; you want to substitute gitlab.oit.duke.edu.",
    "crumbs": [
      "Resources",
      "Git Version Control"
    ]
  },
  {
    "objectID": "resources/git.html#git-tutorials",
    "href": "resources/git.html#git-tutorials",
    "title": "Git: Getting Started",
    "section": "Git Tutorials",
    "text": "Git Tutorials\nWe are going to cover git extensively in class, but it can really help to review some tutorials ahead of time to get familiar with the nomenclature and high-level overview of the workflow. If you have never used git before, I would recommend reviewing the following tutorials:\n\nGit Immersion\nLearn Git Branching\nThink Like (a) Git\nGit Tutorial for Beginners: Learn Git in 1 Hour\n\nMore comprehensive git documentation can be found at https://git-scm.com/doc.",
    "crumbs": [
      "Resources",
      "Git Version Control"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Embedded Medical Devices",
    "section": "",
    "text": "Please use the links in the sidebar to navigate through the course materials."
  },
  {
    "objectID": "labs/event-driven-state-machine-lab.html",
    "href": "labs/event-driven-state-machine-lab.html",
    "title": "Event Driven State Machine Lab",
    "section": "",
    "text": "Tip\n\n\n\nI would recommend doing this with pencil and paper first, not immediately jumping into a tool. Err on the side of more detail than not.",
    "crumbs": [
      "Labs",
      "Event-Driven State Machine Lab"
    ]
  },
  {
    "objectID": "labs/event-driven-state-machine-lab.html#digital-kitchen-timer",
    "href": "labs/event-driven-state-machine-lab.html#digital-kitchen-timer",
    "title": "Event Driven State Machine Lab",
    "section": "Digital Kitchen Timer",
    "text": "Digital Kitchen Timer\nGenerate a state diagram for a simple digital kitchen timer that has the following buttons:\n\nStart/Stop Button\nReset Button\nPause Button\nUp/Down/Left/Right Arrow Buttons (4)\n\nThe timer outputs time intervals in the format: HH:MM:SS",
    "crumbs": [
      "Labs",
      "Event-Driven State Machine Lab"
    ]
  },
  {
    "objectID": "labs/event-driven-state-machine-lab.html#functional-states",
    "href": "labs/event-driven-state-machine-lab.html#functional-states",
    "title": "Event Driven State Machine Lab",
    "section": "Functional States",
    "text": "Functional States\n\nThe kitchen timer has an “Idle” state when it isn’t actively counting down time. In this state:\n\nThe Up/Down buttons increment the time for the HH, MM or SS values.\nThe Left/Right buttons let you move between HH, MM and SS.\nTime intervals will wrap around to 00 when a reasonable max value is exceeded.\nThe Reset button sets all of the time values to 00.\nThe Pause button is inactive.\n\nStart/Stop will start the timer countdown when in Idle.\nIn the Countdown state:\n\nThe Start/Stop button will stop and reset the countdown interval.\nThe Pause button will pause, but not reset, the countdown time.\n\nWhen the countdown is done, the timer enters an Alarm state, where:\n\nThe Up/Down/Right/Left arrow buttons, Reset and Pause buttons are inactive.\nStart/Stop will stop the alarm and return the timer to Idle with the previously set countdown time.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIf any functional state expectation isn’t explicitly described above, please implement something reasonable.\n\n\nMake sure that your state diagram:\n\nHas initialization (i.e., batteries put in) and termination (i.e., completely powered off) dots.\nIncludes all functional states, including (but not limited to):\n\nIdle\nCountdown\nPaused\nAlarm\n\nConsider if states should have entry and exit actions.\nMake sure all transitions between states are annotated with associated triggering events.",
    "crumbs": [
      "Labs",
      "Event-Driven State Machine Lab"
    ]
  },
  {
    "objectID": "labs/event-driven-state-machine-lab.html#generate-the-state-diagram",
    "href": "labs/event-driven-state-machine-lab.html#generate-the-state-diagram",
    "title": "Event Driven State Machine Lab",
    "section": "Generate the State Diagram",
    "text": "Generate the State Diagram\nFormally render your state diagram using one of the tools outlined on the State Diagram Tools page.",
    "crumbs": [
      "Labs",
      "Event-Driven State Machine Lab"
    ]
  },
  {
    "objectID": "labs/event-driven-state-machine-lab.html#gradescope",
    "href": "labs/event-driven-state-machine-lab.html#gradescope",
    "title": "Event Driven State Machine Lab",
    "section": "Gradescope",
    "text": "Gradescope\nUpload your rendered state diagram to the associated Gradescope assignment.",
    "crumbs": [
      "Labs",
      "Event-Driven State Machine Lab"
    ]
  },
  {
    "objectID": "labs/git-fundamentals-lab.html",
    "href": "labs/git-fundamentals-lab.html",
    "title": "Git Fundamentals Lab",
    "section": "",
    "text": "This week we will go through a very simple git workflow to get you familiar with the process and to confirm that your toolchain works for future assignments.\n\n\n\nMake sure that you have git installed, ssh keys configured, and your Duke GitLab account is setup, as detailed here\nBe sure to review the tutorials outlined on the git setup page, as needed, to complete the tasks below.\nCreate a fork–not a clone–of the git-fundamentals-lab in your userspace.\nAdd Dr. Palmeri (mlp6) as a Maintainer of your forked repository (Left Sidebar: Manage -&gt; Members -&gt; Invite members)\nClone your forked repository to your laptop using the URL available under the blue Code button: Clone with SSH.\n\n\n\n\n\n\n\nWarning\n\n\n\nYou want to clone your forked repository, not the parent repository you forked from!\n\n\n\n\n\n\nSwitch to the about_me branch.\nEdit AboutMe.md to replace all of the FILL_ME_IN placeholders with your own information.\nAdd and commit these text changes with a meaningful commit message.\nAdd and commit a new image file named fun_picture.png in a directory called images/ to complete that section of the AboutMe.md file.\nPush this updated branch to the remote of your GitLab repository.\n\nConfirm that you can see your latest commit on this branch on the GitLab website.\n\n\n\n\n\nCreate a new Merge Request on the GitLab to merge the about_me branch into the main branch.\n\nAssign the Merge Request to yourself.\nYou do not need a Reviewer.\nYou do not want to squash or rebase your branch commits\nYou do not want to delete the source branch.\n\nCheck that the check_image and check_about_me pipline jobs have passed.\n\nBuild -&gt; Pipelines\nClick on the latest pipeline (the colored rounded rectangle button in the status column).\nClick on the check_image or check_about_me job to see the output of the test if it Failed.\n\nIf the pipeline jobs for this branch have failed, you will need to fix the issue(s) and push the changes to your about_me branch.\n\nIf you are not sure what the issue is, click on the failed job to see the output of the test.\nIf you are not sure how to fix it, ask for help!\n\nOnce your CI jobs pass, approve your Merge Request on the GitLab website and Merge your about_me branch into main.\nCheckout the main branch on your laptop and pull the latest changes from the GitLab server.\nConfirm that you can see the updated AboutMe.md file in your main branch, along with its associated commit in your git commit history.\n\n\n\n\n\nOn main, create an annotated tag for this commit associated with your merged about_me branch called v1.0.0, with the message \"include the about me info\".\nPush this annotated tag to the GitLab server (origin).\nConfirm that you can see your latest commit and tag on the GitLab website.\nYou should see that the check_v1_0_0_tag pipeline job has passed if this was successful.\n\n\n\n\n\nInspect the contents of AboutDrPalmeri.md in main.\nSwitch to the about_dr_p branch, and look at the content (slightly different) of AboutDrPalmeri.md.\nSwitch back to the main branch, and merge the about_dr_p branch into main.\n\nYou will be told that there is a Merge Conflict:\n\n$ git merge about_dr_p\nCONFLICT (content): Merge conflict in AboutDrPalmeri.md\nAutomatic merge failed; fix conflicts and then commit the result.\n\ngit status will show you the files that are in conflict, and what your next likely steps will be to resolve this conflict:\n\n$ git status\nYour branch is up to date with 'origin/main'.\n\nYou have unmerged paths.\n(fix conflicts and run \"git commit\")\n(use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n(use \"git add &lt;file&gt;...\" to mark resolution)\n        both modified:   AboutDrPalmeri.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\") \nStaying on the main branch, open AboutDrPalmeri.md in your text editor, and inspect the &lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, and &gt;&gt;&gt;&gt;&gt;&gt;&gt; markers that indicate the conflicting lines.\nKeep the version of the conflicting line that is in main, and delete the line that was incoming from about_dr_p.\nBe sure to delete the &lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, and &gt;&gt;&gt;&gt;&gt;&gt;&gt; markers (lines).\nAdd and commit this merge conflict resolution.\nCreate an annotated tag called v1.0.1 with the message \"fix Dr. P's age\".\nPush your latest commits and tags to main on the GitLab server (origin).\nAll of your CI jobs should pass if everything was successful.",
    "crumbs": [
      "Labs",
      "Git Fundamentals Lab"
    ]
  },
  {
    "objectID": "labs/git-fundamentals-lab.html#git-practice",
    "href": "labs/git-fundamentals-lab.html#git-practice",
    "title": "Git Fundamentals Lab",
    "section": "",
    "text": "This week we will go through a very simple git workflow to get you familiar with the process and to confirm that your toolchain works for future assignments.\n\n\n\nMake sure that you have git installed, ssh keys configured, and your Duke GitLab account is setup, as detailed here\nBe sure to review the tutorials outlined on the git setup page, as needed, to complete the tasks below.\nCreate a fork–not a clone–of the git-fundamentals-lab in your userspace.\nAdd Dr. Palmeri (mlp6) as a Maintainer of your forked repository (Left Sidebar: Manage -&gt; Members -&gt; Invite members)\nClone your forked repository to your laptop using the URL available under the blue Code button: Clone with SSH.\n\n\n\n\n\n\n\nWarning\n\n\n\nYou want to clone your forked repository, not the parent repository you forked from!\n\n\n\n\n\n\nSwitch to the about_me branch.\nEdit AboutMe.md to replace all of the FILL_ME_IN placeholders with your own information.\nAdd and commit these text changes with a meaningful commit message.\nAdd and commit a new image file named fun_picture.png in a directory called images/ to complete that section of the AboutMe.md file.\nPush this updated branch to the remote of your GitLab repository.\n\nConfirm that you can see your latest commit on this branch on the GitLab website.\n\n\n\n\n\nCreate a new Merge Request on the GitLab to merge the about_me branch into the main branch.\n\nAssign the Merge Request to yourself.\nYou do not need a Reviewer.\nYou do not want to squash or rebase your branch commits\nYou do not want to delete the source branch.\n\nCheck that the check_image and check_about_me pipline jobs have passed.\n\nBuild -&gt; Pipelines\nClick on the latest pipeline (the colored rounded rectangle button in the status column).\nClick on the check_image or check_about_me job to see the output of the test if it Failed.\n\nIf the pipeline jobs for this branch have failed, you will need to fix the issue(s) and push the changes to your about_me branch.\n\nIf you are not sure what the issue is, click on the failed job to see the output of the test.\nIf you are not sure how to fix it, ask for help!\n\nOnce your CI jobs pass, approve your Merge Request on the GitLab website and Merge your about_me branch into main.\nCheckout the main branch on your laptop and pull the latest changes from the GitLab server.\nConfirm that you can see the updated AboutMe.md file in your main branch, along with its associated commit in your git commit history.\n\n\n\n\n\nOn main, create an annotated tag for this commit associated with your merged about_me branch called v1.0.0, with the message \"include the about me info\".\nPush this annotated tag to the GitLab server (origin).\nConfirm that you can see your latest commit and tag on the GitLab website.\nYou should see that the check_v1_0_0_tag pipeline job has passed if this was successful.\n\n\n\n\n\nInspect the contents of AboutDrPalmeri.md in main.\nSwitch to the about_dr_p branch, and look at the content (slightly different) of AboutDrPalmeri.md.\nSwitch back to the main branch, and merge the about_dr_p branch into main.\n\nYou will be told that there is a Merge Conflict:\n\n$ git merge about_dr_p\nCONFLICT (content): Merge conflict in AboutDrPalmeri.md\nAutomatic merge failed; fix conflicts and then commit the result.\n\ngit status will show you the files that are in conflict, and what your next likely steps will be to resolve this conflict:\n\n$ git status\nYour branch is up to date with 'origin/main'.\n\nYou have unmerged paths.\n(fix conflicts and run \"git commit\")\n(use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n(use \"git add &lt;file&gt;...\" to mark resolution)\n        both modified:   AboutDrPalmeri.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\") \nStaying on the main branch, open AboutDrPalmeri.md in your text editor, and inspect the &lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, and &gt;&gt;&gt;&gt;&gt;&gt;&gt; markers that indicate the conflicting lines.\nKeep the version of the conflicting line that is in main, and delete the line that was incoming from about_dr_p.\nBe sure to delete the &lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, and &gt;&gt;&gt;&gt;&gt;&gt;&gt; markers (lines).\nAdd and commit this merge conflict resolution.\nCreate an annotated tag called v1.0.1 with the message \"fix Dr. P's age\".\nPush your latest commits and tags to main on the GitLab server (origin).\nAll of your CI jobs should pass if everything was successful.",
    "crumbs": [
      "Labs",
      "Git Fundamentals Lab"
    ]
  },
  {
    "objectID": "labs/git-fundamentals-lab.html#how-to-ask-for-help",
    "href": "labs/git-fundamentals-lab.html#how-to-ask-for-help",
    "title": "Git Fundamentals Lab",
    "section": "How to Ask for Help",
    "text": "How to Ask for Help\n\nIf you have a general / non-coding question, you should ask your TAs / Dr. Palmeri on Ed to allow any of them to respond in a timely manner.\nPush you code to your GitLab repository, ideally with your active development on a non-main branch.\nCreate an Issue in your repository.\n\nAdd as much detail as possible as to your problem, and add links to specific lines / section of code when possible.\nAssign the label “Bug” or “Question”, as appropriate.\nBe sure to specify what branch you are working on.\nAssign the Issue to one of the TAs.\nIf your TA cannot solve your Issue, they can escalate the Issue to Dr. Palmeri.\n\nYou will get a response to your Issue, and maybe a new branch of code will be pushed to help you with some example syntax that you can use git diff to visualize.",
    "crumbs": [
      "Labs",
      "Git Fundamentals Lab"
    ]
  },
  {
    "objectID": "labs/git-fundamentals-lab.html#what-to-submit",
    "href": "labs/git-fundamentals-lab.html#what-to-submit",
    "title": "Git Fundamentals Lab",
    "section": "What to Submit",
    "text": "What to Submit\nYour fork of this GitLab repository will be running this CI script: .gitlab-ci.yml\n\nGo to the Build -&gt; Pipelines page of your GitLab repository.\nTake a screenshot of the latest pipeline that shows all of the tests passing, along with your repository information, as shown below (except all of those Failed tests should report Passed).\n\n\n\n\nci_pipeline\n\n\n\nSubmit this screenshot to Gradescope assignment, along with completing the prompted questions.",
    "crumbs": [
      "Labs",
      "Git Fundamentals Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-smf-lab.html",
    "href": "labs/zephyr-smf-lab.html",
    "title": "Zephyr: State Machine Framework Refactor Lab",
    "section": "",
    "text": "Use best practices for version control (branching, commit messages, etc.).\nDo all development on a dedicated branch that is merged into main once it is functional.\nCommits should be very specific to the changes/additions you are making to your code. This will help you and others understand what you did and why you did it.\n\nOn a given development branch, try to implement one small piece of functionality at a time, commit it, and then move on to the next piece of functionality.\n\n\n\n\n\n\n\nImportant\n\n\n\nYou do not want one, monolithic git commit right before you submit your project.",
    "crumbs": [
      "Labs",
      "State Machine Framework (SMF) Refactor Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-smf-lab.html#git-version-control",
    "href": "labs/zephyr-smf-lab.html#git-version-control",
    "title": "Zephyr: State Machine Framework Refactor Lab",
    "section": "",
    "text": "Use best practices for version control (branching, commit messages, etc.).\nDo all development on a dedicated branch that is merged into main once it is functional.\nCommits should be very specific to the changes/additions you are making to your code. This will help you and others understand what you did and why you did it.\n\nOn a given development branch, try to implement one small piece of functionality at a time, commit it, and then move on to the next piece of functionality.\n\n\n\n\n\n\n\nImportant\n\n\n\nYou do not want one, monolithic git commit right before you submit your project.",
    "crumbs": [
      "Labs",
      "State Machine Framework (SMF) Refactor Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-smf-lab.html#refactor-state-machine-framework",
    "href": "labs/zephyr-smf-lab.html#refactor-state-machine-framework",
    "title": "Zephyr: State Machine Framework Refactor Lab",
    "section": "Refactor: State Machine Framework",
    "text": "Refactor: State Machine Framework\n\nCreate a new development branch in your forked repository you have used the last few weeks called refactor_smf.\nRefactor your code to use the Zephyr State Machine Framework (SMF).\n\nUse entry and exit substates to handle state transitions where something should be done “once” when entering or exiting a state.\nRefactor code to make sure that state-specific things are done in that state. For example, if an error LED should only be on in the ERROR state, then the code to turn on the LED should be in the ERROR entry state and not done in the exit of the previous state.\nMake sure that your device initialization is done in an INIT state (so that, in the future, a soft reset can allow the device to be completely re-initialized).\n\nMake sure that your state diagram is updated to reflect these entry / exit actions. This diagram should exactly match your firmware implementation of the SMF.\nQualitatively make sure that your device continues to function as expected.",
    "crumbs": [
      "Labs",
      "State Machine Framework (SMF) Refactor Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-smf-lab.html#how-do-i-ask-for-help",
    "href": "labs/zephyr-smf-lab.html#how-do-i-ask-for-help",
    "title": "Zephyr: State Machine Framework Refactor Lab",
    "section": "How do I ask for help?",
    "text": "How do I ask for help?\n\nIf you have a general / non-coding question, you should ask your TAs / Dr. Palmeri on Ed to allow any of them to respond in a timely manner.\nPush you code to your GitLab repository, ideally with your active development on a non-main branch.\nCreate an Issue in your repository.\n\nAdd as much detail as possible as to your problem, and add links to specific lines / section of code when possible.\nAssign the label “Bug” or “Question”, as appropriate.\nBe sure to specify what branch you are working on.\nAssign the Issue to one of the TAs.\nIf your TA cannot solve your Issue, they can escalate the Issue to Dr. Palmeri.\n\nYou will get a response to your Issue, and maybe a new branch of code will be pushed to help you with some example syntax that you can use git diff to visualize.",
    "crumbs": [
      "Labs",
      "State Machine Framework (SMF) Refactor Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-smf-lab.html#what-to-submit",
    "href": "labs/zephyr-smf-lab.html#what-to-submit",
    "title": "Zephyr: State Machine Framework Refactor Lab",
    "section": "What to Submit",
    "text": "What to Submit\n\nAs with the previous labs, push this development branch to Gitlab and merge it into main.\nCreate an annotated tag for that merged commit called v1.4.0.\nCreate an Issue assigned to Dr. Palmeri to review your code for v1.4.0. (Teaching team will upload a zip archive of your project to Gradescope.)",
    "crumbs": [
      "Labs",
      "State Machine Framework (SMF) Refactor Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-timers-lab.html",
    "href": "labs/zephyr-timers-lab.html",
    "title": "Zephyr: Timers Lab",
    "section": "",
    "text": "You will be refactoring your code from the GPIO lab to now use timers. Do all of the refactoring below on a new branch called timers.\n\nEliminate any conditional logic (if/else statements) to test for elapsed time to toggle/set LED output states.\nUse timers for all LED illumination events.\nImplement finer resolution for timing than what k_uptime_get() can provide (ms) by using k_uptime_ticks() (documentation) and k_ticks_to_ns_near64() (documentation).\nYou do not have to use work queues if your timer handler functions run quickly and do not block. However, if your handler functions are more complex, you should use work queues to submit the work to the system work queue.",
    "crumbs": [
      "Labs",
      "Timers Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-timers-lab.html#refactor-your-gpio-lab-code",
    "href": "labs/zephyr-timers-lab.html#refactor-your-gpio-lab-code",
    "title": "Zephyr: Timers Lab",
    "section": "",
    "text": "You will be refactoring your code from the GPIO lab to now use timers. Do all of the refactoring below on a new branch called timers.\n\nEliminate any conditional logic (if/else statements) to test for elapsed time to toggle/set LED output states.\nUse timers for all LED illumination events.\nImplement finer resolution for timing than what k_uptime_get() can provide (ms) by using k_uptime_ticks() (documentation) and k_ticks_to_ns_near64() (documentation).\nYou do not have to use work queues if your timer handler functions run quickly and do not block. However, if your handler functions are more complex, you should use work queues to submit the work to the system work queue.",
    "crumbs": [
      "Labs",
      "Timers Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-timers-lab.html#git-version-control",
    "href": "labs/zephyr-timers-lab.html#git-version-control",
    "title": "Zephyr: Timers Lab",
    "section": "Git Version Control",
    "text": "Git Version Control\n\nUse best practices for version control (branching, commit messages, etc.).\nDo all development on a dedicated branch that is merged into main once it is functional.\nCommits should be very specific to the changes/additions you are making to your code. This will help you and others understand what you did and why you did it.\n\nOn a given development branch, try to implement one small piece of functionality at a time, commit it, and then move on to the next piece of functionality.\n\n\n\n\n\n\n\nImportant\n\n\n\nYou do not want one, monolithic git commit right before you submit your project.",
    "crumbs": [
      "Labs",
      "Timers Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-timers-lab.html#test-the-accuracy-of-your-timing",
    "href": "labs/zephyr-timers-lab.html#test-the-accuracy-of-your-timing",
    "title": "Zephyr: Timers Lab",
    "section": "Test the Accuracy of your Timing",
    "text": "Test the Accuracy of your Timing\nFor the measurements below, record and analyze your data in the technical report captured in a Jupyter notebook called testing/timer_testing.ipynb. You can use the Jupyter notebook included in the lab repository (testing/technical_report.ipynb), which includes some example code, as a starting point, but be sure to rename the notebook in the testing/ directory.\nYour technical report should include:\n\nMethods\nA brief Methods section describing what you did (e.g., how you captured the timing via logging or how you measured timing on the oscilloscope).\nFor each section below, all raw data should be read in from a dedicated file (e.g., a CSV file).\n\n\n\n\n\n\nWarning\n\n\n\nDo not manually type in data in your Jupyter notebook.\n\n\n\n\nLogging Statements\n\nUse logging statements to test the accuracy of your heartbeat and action LED timing for the (a) default, (b) fastest and (c) slowest blink rate of your action LEDs.\n\n\n\n\n\n\n\nNote\n\n\n\nNote that logging statements, by default, are low priority and non-blocking (asynchronous).\n\n\n\nGiven the latency of when a log message may be printed relative to the event you are trying to get the timing of, you should save the execution time of the timing handler to be log printed later.\nSave your logging output data to a CSV file to be read into your Jupyter notebook.\n\n\n\n\n\n\n\nNote\n\n\n\nThere is no elegant way to directly save your data to a CSV file directly from the Terminal in VS Code.\nTwo possible approaches:\n\nYou can save the entire Terminal output to a file and parse it in your Jupyter notebook, or\nYou can cut-and-paste the relevant values from the Terminal output to a CSV file.\n\nAn example Terminal output might look like:\n[00:01:00.009,429] &lt;inf&gt; timers_lab: action toggle period (ns): 100006104\n[00:01:00.109,436] &lt;inf&gt; timers_lab: action toggle period (ns): 100006104\n[00:01:00.209,442] &lt;inf&gt; timers_lab: action toggle period (ns): 100006104\n[00:01:00.254,333] &lt;inf&gt; timers_lab: heart toggle period (ns): 500000000\n[00:01:00.309,448] &lt;inf&gt; timers_lab: action toggle period (ns): 100006104\n[00:01:00.409,454] &lt;inf&gt; timers_lab: action toggle period (ns): 100006104\n[00:01:00.509,460] &lt;inf&gt; timers_lab: action toggle period (ns): 100006104\n[00:01:00.609,466] &lt;inf&gt; timers_lab: action toggle period (ns): 100006104\n[00:01:00.709,472] &lt;inf&gt; timers_lab: action toggle period (ns): 100006104\n[00:01:00.754,333] &lt;inf&gt; timers_lab: heart toggle period (ns): 500000000\n[00:01:00.809,478] &lt;inf&gt; timers_lab: action toggle period (ns): 100006104\n[00:01:00.909,484] &lt;inf&gt; timers_lab: action toggle period (ns): 100006104\n[00:01:01.009,490] &lt;inf&gt; timers_lab: action toggle period (ns): 100006104\n[00:01:01.109,497] &lt;inf&gt; timers_lab: action toggle period (ns): 100006104\n[00:01:01.209,503] &lt;inf&gt; timers_lab: action toggle period (ns): 100006104\n[00:01:01.254,333] &lt;inf&gt; timers_lab: heart toggle period (ns): 500000000\nYou could then leverage the following snippet in your Jupyter notebook to parse out the relevant data:\nlog_5Hz = pd.read_csv('log_5Hz.txt', sep=\" \",header =None, usecols=[0,3,7], \n                      names =['timestamp','type','toggle duration (ns)'])\nlog_5Hz['frequency (Hz)'] = (1e9/(2*log_5Hz['toggle duration (ns)']))\nprint('Table with action LEDs nominally set to 5 Hz:')\nwith pd.option_context('display.max_rows', None, \n                       'display.max_columns', None):\n    print(log_5Hz)\nIf you run out of terminal output buffer, you can increase the buffer size in VS Code settings under Terminal &gt; Integrated: Scrollback.\n\n\n\nEstimate the 95% confidence interval (2x standard deviation for normally-distributed data) for your timing relative to the nominal specification.\n\n\n\nOscilloscope Measurements\n\nRepeat your timing accuracy analysis you performed with logging statements using an oscilloscope directly measuring the GPIO pin signals. Remember that all of the GPIO pins are accessible as female header sockets on the development kit; you do not need to try to directly connect to the pads of the LEDs and buttons!\nSave your oscilloscope measurements to a CSV file to be read into your Jupyter notebook.\nUse the oscilloscope cursors to measure the timing intervals.\n\n\n\n\n\n\n\nNote\n\n\n\nRemember that you will need multiple independent measurements to calculate confidence intervals.\n\n\n\nQuantify a 95% confidence interval for your timing relative to the nominal specification using these oscillosocpe measurements.\n\n\n\nDiscussion\nDiscuss how well the measurements match their nominal values, and if significant deviation has occurred, discuss why this may have happened and how it could be improved moving forward.",
    "crumbs": [
      "Labs",
      "Timers Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-timers-lab.html#how-to-ask-for-help",
    "href": "labs/zephyr-timers-lab.html#how-to-ask-for-help",
    "title": "Zephyr: Timers Lab",
    "section": "How to Ask for Help",
    "text": "How to Ask for Help\n\nIf you have a general / non-coding question, you should ask your TAs / Dr. Palmeri on Ed to allow any of them to respond in a timely manner.\nPush you code to your GitLab repository, ideally with your active development on a non-main branch.\nCreate an Issue in your repository.\n\nAdd as much detail as possible as to your problem, and add links to specific lines / section of code when possible.\nAssign the label “Bug” or “Question”, as appropriate.\nBe sure to specify what branch you are working on.\nAssign the Issue to one of the TAs.\nIf your TA cannot solve your Issue, they can escalate the Issue to Dr. Palmeri.\n\nYou will get a response to your Issue, and maybe a new branch of code will be pushed to help you with some example syntax that you can use git diff to visualize.",
    "crumbs": [
      "Labs",
      "Timers Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-timers-lab.html#what-to-submit",
    "href": "labs/zephyr-timers-lab.html#what-to-submit",
    "title": "Zephyr: Timers Lab",
    "section": "What to Submit",
    "text": "What to Submit\n\nMake sure that your complete timing_analysis.ipynb notebook is in your timers branch in a directory called testing/, which also includes all raw CSV data.\nMake sure that your Jupyter notebook reads in data from relative paths for the repository, not absolute paths on your local machine.\nPush your timers branch to GitLab.\nCreate a new Merge Request to merge timers into your forked repository’s main branch.\n\n\n\n\n\n\n\nWarning\n\n\n\nDo not create a Merge Request in to the parent repository that you forked from!\n\n\n\nMerge your timers branch into your main branch.\nCreate an annotated tag for that merge commit called v1.1.0.\nCreate a new Issue assigned to Dr. Palmeri to request a code review for v1.1.0.\n\n\n\n\n\n\n\nNote\n\n\n\nIf you fix any bugs after creating the original annotated tag, increment up the patch number with a new annotated tag version number, and update the Issue to reflect which annotated tag should be reviewed.",
    "crumbs": [
      "Labs",
      "Timers Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-gpio-isr-callbacks-lab.html",
    "href": "labs/zephyr-gpio-isr-callbacks-lab.html",
    "title": "Zephyr: Devicetree, GPIO, ISR and Callbacks Lab",
    "section": "",
    "text": "This week we will start programming the firmware that will be controlling your nRF52833DK. We will be using buttons to trigger device events and LEDs will be used to visualize output activity for the device. While LEDs might seem underwhelming, they are a universal way to represent how digital ouput signals could be used to control other devices (e.g., motors, actuators, etc.).",
    "crumbs": [
      "Labs",
      "GPIO, ISR, and Callbacks Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-gpio-isr-callbacks-lab.html#overview",
    "href": "labs/zephyr-gpio-isr-callbacks-lab.html#overview",
    "title": "Zephyr: Devicetree, GPIO, ISR and Callbacks Lab",
    "section": "",
    "text": "This week we will start programming the firmware that will be controlling your nRF52833DK. We will be using buttons to trigger device events and LEDs will be used to visualize output activity for the device. While LEDs might seem underwhelming, they are a universal way to represent how digital ouput signals could be used to control other devices (e.g., motors, actuators, etc.).",
    "crumbs": [
      "Labs",
      "GPIO, ISR, and Callbacks Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-gpio-isr-callbacks-lab.html#nordic-devacademy-modules",
    "href": "labs/zephyr-gpio-isr-callbacks-lab.html#nordic-devacademy-modules",
    "title": "Zephyr: Devicetree, GPIO, ISR and Callbacks Lab",
    "section": "Nordic DevAcademy Modules",
    "text": "Nordic DevAcademy Modules\nPlease complete the following Nordic DevAcademy modules:\n\nReading Buttons and Controlling LEDs\nDebugging & Troubleshooting",
    "crumbs": [
      "Labs",
      "GPIO, ISR, and Callbacks Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-gpio-isr-callbacks-lab.html#git-version-control",
    "href": "labs/zephyr-gpio-isr-callbacks-lab.html#git-version-control",
    "title": "Zephyr: Devicetree, GPIO, ISR and Callbacks Lab",
    "section": "Git Version Control",
    "text": "Git Version Control\n\nUse best practices for version control (branching, commit messages, etc.).\nDo all development on a dedicated branch that is merged into main once it is functional.\nCommits should be very specific to the changes/additions you are making to your code. This will help you and others understand what you did and why you did it.\n\nOn a given development branch, try to implement one small piece of functionality at a time, commit it, and then move on to the next piece of functionality.\n\n\n\n\n\n\n\nImportant\n\n\n\nYou do not want one, monolithic git commit right before you submit your project.",
    "crumbs": [
      "Labs",
      "GPIO, ISR, and Callbacks Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-gpio-isr-callbacks-lab.html#repository-setup",
    "href": "labs/zephyr-gpio-isr-callbacks-lab.html#repository-setup",
    "title": "Zephyr: Devicetree, GPIO, ISR and Callbacks Lab",
    "section": "Repository Setup",
    "text": "Repository Setup\n\nFork the Duke-BME554-ECG-TEMP-BLE-Lab template repository into your personal GitLab user space.\nAdd Dr. Palmeri (mlp6) as a Maintainer of your project ASAP. This will allow him to add your TAs and some project labels to your repository.\nClone your forked project to your local laptop.\nRun west update to setup the SDK to for your project.",
    "crumbs": [
      "Labs",
      "GPIO, ISR, and Callbacks Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-gpio-isr-callbacks-lab.html#kernel-configuration",
    "href": "labs/zephyr-gpio-isr-callbacks-lab.html#kernel-configuration",
    "title": "Zephyr: Devicetree, GPIO, ISR and Callbacks Lab",
    "section": "Kernel Configuration",
    "text": "Kernel Configuration\nTake note of kernel configurations enabled in application/prj.conf.",
    "crumbs": [
      "Labs",
      "GPIO, ISR, and Callbacks Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-gpio-isr-callbacks-lab.html#devicetree",
    "href": "labs/zephyr-gpio-isr-callbacks-lab.html#devicetree",
    "title": "Zephyr: Devicetree, GPIO, ISR and Callbacks Lab",
    "section": "Devicetree",
    "text": "Devicetree\n\nWe have introduced the concept of the Devicetree (DT) for the nRF52833DK. The development kit has a preconfigured DT (nrf52833dk_nrf52833.dts), which is selected when we create a board configuration (the present selected in CMakePresents.json).\nTo make changes or additions to this DT, we will create a DT overlay file that will be compiled into the firmware. The default name of this file is nrf52833dk_nrf52833.overlay and it is located in the application/boards/ directory.\nThe nRF52833DK has 4 integrated LEDs. Edit the DT overlay file for your project to create alias for 4 LEDs on the following pins (all 4 of which are the integrated LEDs), which will then be associated with the specified firmware GPIO pin struct names:\n\n\n\n\n\n\n\n\n\n\n\nFirmware gpio_dt_spec Struct Name\nDT Alias\nDT Default Node Name\nPhysical GPIO Pin\nDK Part Label\n\n\n\n\nheartbeat_led\nheartbeat\nled0\nP0.13\nLED1\n\n\niv_pump_led\nivpump\nled1\nP0.14\nLED2\n\n\nbuzzer_led\nbuzzer\nled2\nP0.15\nLED3\n\n\nerror_led\nerror\nled3\nP0.16\nLED4\n\n\n\n\nThe nRF52833DK also has 4 integrated buttons. Edit the DT overlay file for your project to create aliases for these 4 buttons that are the same as their default DTS node names:\n\n\n\n\n\n\n\n\n\n\n\nFirmware gpio_dt_spec Struct Name\nDT Alias\nDT Default Node Name\nPhysical GPIO Pin\nDK Part Label\n\n\n\n\nsleep_button\nsleepbutton\nbutton0\nP0.11\nButton 1\n\n\nfreq_up_button\nfrequpbutton\nbutton1\nP0.12\nButton 2\n\n\nfreq_down_button\nfreqdownbutton\nbutton2\nP0.24\nButton 3\n\n\nreset_button\nresetbutton\nbutton3\nP0.25\nButton 4\n\n\n\nSource: https://docs.nordicsemi.com/bundle/ug_nrf52833_dk/page/UG/dk/hw_buttons_leds.html",
    "crumbs": [
      "Labs",
      "GPIO, ISR, and Callbacks Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-gpio-isr-callbacks-lab.html#firmware",
    "href": "labs/zephyr-gpio-isr-callbacks-lab.html#firmware",
    "title": "Zephyr: Devicetree, GPIO, ISR and Callbacks Lab",
    "section": "Firmware",
    "text": "Firmware\nImplement the following firmware functionality as a state machine (switch/case):\n\nCheck that the GPIO0 interface is ready.\nInitialize all LED output pins as GPIO_OUTPUT_ACTIVE or GPIO_OUTPUT_INACTIVE, as dictated by the functional specifications below. Note that ACTIVE for the LEDs on this DK corresponds to driving them LOW.\nBe sure to capture all function exit codes and have conditional statements to capture any returned error codes.\n\nImplement the following control logic:\n\nThe heartbeat LED blinks at a fixed 1 Hz while main() is being executed. Issue a LOG_INF() statement each time the heartbeat LED is toggled.\nThe 2 “action” LEDs (buzzer_led and iv_pump_led) blink out of phase with one another at 2 Hz by default.\n\nThis 2 Hz default blink frequency should be defined using a preprocessor macro: #define LED_BLINK_FREQ_HZ 2.\n\nIssue a LOG_INF() statement each time the “action” LEDs are toggled.\nfreq_up_button increases the blink frequency of the “action” LEDs by 1 Hz each time it is pressed.\nThis incremental increase in blink frequency should be defined by the preprocessor macro: #define FREQ_UP_INC_HZ 1.\n\nIssue a descriptive LOG_INF() statement each time this button is pressed, which indicates the new blink frequency.\nfreq_down_button decreases the blink frequency of the “action” LEDs by 1 Hz each time it is pressed.\nThis incremental increase in blink frequency should be defined by the preprocessor macro: #define FREQ_DOWN_INC_HZ 1.\n\nIssue a descriptive LOG_INF() statement each time this button is pressed, which indicates the new blink frequency.\nIf the blink frequency for the “action” LEDs is &lt; 1 Hz or &gt; 5 Hz, then:\n\nThe “action” LEDs should both be off, and\nThe error LED is continuously illuminated.\n\nIssue a descriptive LOG_ERR() statement.\nThe heartbeat LED should continue to blink at 1 Hz.\nfreq_up_button, freq_down_button, and sleep_button should be disabled (interrupts disabled).\nThe only way to exit the “error state” is to press the reset button.\n\nDefine each of these min/max blinking frequencylimits using preprocessor macros (you can choose appropriate names).\nPressing the reset button resets the “action” LEDs to blink at their default 2 Hz rate, out of phase with one another, and re-enables the freq_up_button, freq_down_button, and sleep_button.\nThe reset_button can be pressed from any state and resets the device back to the default state.\n\nA descriptive LOG_INF() statement should be issued each time the reset button is pressed.\nAt any point in time when the “action” LEDs are blinking (i.e., not the error state), if the sleep_button is pressed:\n\nThe current blink frequency for the “action” LEDs is stored,\nBoth “action” LEDs are turned off,\nThe heartbeat LED continues to blink,\nA descriptive LOG_INF() statement is issued,\nThe “sleep state” can be exited by:\nPressing the sleep button again, at which time the device returns to blinking the “action” LEDs at the same frequency and relative phase before being put to sleep. Relative phase means the appropriate relative timing between the different “action” LEDs.\nPressing the reset_button, at which time the device returns to blinking the “action” LEDs at their default 2 Hz rate, out of phase with one another.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nYou may want to make your state diagram before writing any code.\nDo not use k_msleep() in your code to control LED blink timing.\n\nSleep is blocking and paralyzes a single-threaded application.\n\nInstead, have your main while loop run as fast as possible and use the k_uptime_get() function to determine when to toggle the LEDs.\n\nSpoiler alert: We will be system kernel timers / threads to control the LED blink timing in the next lab.\n\n\nConsider using a struct for each LED to bookkeep the LED state, phase, blink frequency, etc.",
    "crumbs": [
      "Labs",
      "GPIO, ISR, and Callbacks Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-gpio-isr-callbacks-lab.html#state-diagram",
    "href": "labs/zephyr-gpio-isr-callbacks-lab.html#state-diagram",
    "title": "Zephyr: Devicetree, GPIO, ISR and Callbacks Lab",
    "section": "State Diagram",
    "text": "State Diagram\n\nCreate a state diagram of your firmware using PlantUML, or your diagraming program of choice.\nInclude a PNG of your block diagram in your git repository called state_diagram.png.",
    "crumbs": [
      "Labs",
      "GPIO, ISR, and Callbacks Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-gpio-isr-callbacks-lab.html#how-do-i-ask-for-help",
    "href": "labs/zephyr-gpio-isr-callbacks-lab.html#how-do-i-ask-for-help",
    "title": "Zephyr: Devicetree, GPIO, ISR and Callbacks Lab",
    "section": "How do I ask for help?",
    "text": "How do I ask for help?\n\nIf you have a general / non-coding question, you should ask your TAs / Dr. Palmeri on Ed to allow any of them to respond in a timely manner.\nPush you code to your GitLab repository, ideally with your active development on a non-main branch.\nCreate an Issue in your repository.\n\nAdd as much detail as possible as to your problem, and add links to specific lines / section of code when possible.\nAssign the label “Bug” or “Question”, as appropriate.\nBe sure to specify what branch you are working on.\nAssign the Issue to one of the TAs.\nIf your TA cannot solve your Issue, they can escalate the Issue to Dr. Palmeri.\n\nYou will get a response to your Issue, and maybe a new branch of code will be pushed to help you with some example syntax that you can use git diff to visualize.",
    "crumbs": [
      "Labs",
      "GPIO, ISR, and Callbacks Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-gpio-isr-callbacks-lab.html#what-to-submit-grading",
    "href": "labs/zephyr-gpio-isr-callbacks-lab.html#what-to-submit-grading",
    "title": "Zephyr: Devicetree, GPIO, ISR and Callbacks Lab",
    "section": "What to Submit & Grading",
    "text": "What to Submit & Grading\n\nMake sure you are committing as you develop your code, and have all of those commits pushed to GitLab (i.e., do not “squash” them).\nMake sure all of the CI pipelines are passing.\nCreate and annotated tag called v1.0.0 at the commit that represents your completed lab.\nPush your final repository and the annotated tag to GitLab.\nCreate an Issue assigned to Dr. Palmeri titled v1.0.0 ready for feedback and assign it the Label Review.\nYou do not need to upload anything to the Gradescope assignment; someone on the teaching team will upload your tagged code to the Gradescope assignment for you.\nGrading feedback will be given on:\n\nGit Usage\nCode Functionality\nEfficieny of code logic\nState diagram completeness and matching the firmware implementation\n“Readability”\n\n“Readability” does not mean a lot of verbose comments\n“Readability” means that the structure of the code, the naming of variables, etc. convey meaning and logical flow.",
    "crumbs": [
      "Labs",
      "GPIO, ISR, and Callbacks Lab"
    ]
  },
  {
    "objectID": "course-syllabus.html",
    "href": "course-syllabus.html",
    "title": "Embedded Medical Devices",
    "section": "",
    "text": "Dr. Mark Palmeri (mlp6)\n\nEmail: mark.palmeri@duke.edu\nEd Discussion (private message, TAs included)\nOffice Hours: Sign Up\n\n\n\n\n\nSophie Pelton (smp147)\nAmelia Cook (arc138)\n\nFor TA office hours (in the lab), please see the Canvas calendar.\n\n\n\n\n\n\nTip\n\n\n\nQuestions that can be answered by Dr. Palmeri or a teaching assistant should be posted on Ed Discussion.",
    "crumbs": [
      "Course Information",
      "Course Syllabus"
    ]
  },
  {
    "objectID": "course-syllabus.html#personnel",
    "href": "course-syllabus.html#personnel",
    "title": "Embedded Medical Devices",
    "section": "",
    "text": "Dr. Mark Palmeri (mlp6)\n\nEmail: mark.palmeri@duke.edu\nEd Discussion (private message, TAs included)\nOffice Hours: Sign Up\n\n\n\n\n\nSophie Pelton (smp147)\nAmelia Cook (arc138)\n\nFor TA office hours (in the lab), please see the Canvas calendar.\n\n\n\n\n\n\nTip\n\n\n\nQuestions that can be answered by Dr. Palmeri or a teaching assistant should be posted on Ed Discussion.",
    "crumbs": [
      "Course Information",
      "Course Syllabus"
    ]
  },
  {
    "objectID": "course-syllabus.html#course-times-locations",
    "href": "course-syllabus.html#course-times-locations",
    "title": "Embedded Medical Devices",
    "section": "Course Times & Locations",
    "text": "Course Times & Locations\n\nLecture\nMonday & Wednesday, 08:30-09:45, Hudson Hall 212 (Panopto recorded)\n\n\nLabs\nLocation: CIEMAS B209 (Door Code: 4-1-5-2)\nThere are no formally scheduled lab sections, but you will need to use the lab equipment to perform testing of your devices. Your TAs will announce times when they will hold lab hours.\n\n\n\n\n\n\nImportant\n\n\n\nPlease review the lab policies before using the lab for the first time this semester.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nNo food or drink is allowed in the lab! Failure to adhere to this policy will have consequences on your course participation grades.",
    "crumbs": [
      "Course Information",
      "Course Syllabus"
    ]
  },
  {
    "objectID": "course-syllabus.html#course-objectives",
    "href": "course-syllabus.html#course-objectives",
    "title": "Embedded Medical Devices",
    "section": "Course Objectives",
    "text": "Course Objectives\nThis course will give students experience with the design, function and deployment of embedded medical devices. Students will have hands on experience with electronic hardware and firmware (software) development, along with gaining experience with biosignal transduction into circuits.\nUpon completion of this course, students should be able to:\n\nVersion control software / firmware development using git.\nUse an Integrated Development Environment (IDE) for firmware development.\nDescribe hardware using a Devicetree hierarchical data structure.\nDevelop firmware using Zephyr as a bare-metal super-loop and a Realtime Operating System (RTOS)\nImplement state machines and generate state diagrams using the Unified Modeling Language (UML).\nUtilize callbacks / interrupt service routines for realtime event detection and response.\nUtilize threads and work queues.\nDevelop firmware to control common peripherals, including GPIO, ADC and PWM.\nUse different serial communication protocols, including UART, I2C, SPI, and BLE.\nUtilize firmware logging at different levels.\nTest firmware implementation on the nRF52833DK using electronic bench equipment and generate technical reports with data analysis for device verification.\nDevelop firmware with workflows that adhere to relevant industry and safety standards (e.g., UL, IEC60601, IEC62304) for FDA 510k clearance.",
    "crumbs": [
      "Course Information",
      "Course Syllabus"
    ]
  },
  {
    "objectID": "course-syllabus.html#prerequisites",
    "href": "course-syllabus.html#prerequisites",
    "title": "Embedded Medical Devices",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nMandatory\n\nEGR105L or equivalent experience [git, Python]\nIntrumentation (BME354L) / Mechatronics\nSignals & Systems (BME271/671 or equivalent experience [filtering, FFTs])",
    "crumbs": [
      "Course Information",
      "Course Syllabus"
    ]
  },
  {
    "objectID": "course-syllabus.html#learning-management-system",
    "href": "course-syllabus.html#learning-management-system",
    "title": "Embedded Medical Devices",
    "section": "Learning Management System",
    "text": "Learning Management System\nWe will be using Canvas as the learning management system for this course. Most resources will be linked to the course website. All grades will be posted via Canvas/Gradescope.\nDuke’s GitLab server will be used for most course lab exercises, and code-related questions will be submitted to Dr. Palmeri / TAs using GitLab Issues.\nEd Discussion will be used for general course questions and discussion.",
    "crumbs": [
      "Course Information",
      "Course Syllabus"
    ]
  },
  {
    "objectID": "course-syllabus.html#class-schedule",
    "href": "course-syllabus.html#class-schedule",
    "title": "Embedded Medical Devices",
    "section": "Class Schedule",
    "text": "Class Schedule\nThis class is organized in a sequence of modules. Specific details surrounding dates for assignments associated with each module will be posted to Canvas/Gradescope and linked below.\nThis course uses a version of Mastery Learning, where “mastery” of a given module is necessary to progress onto the subsequent module. Quizzes are used to evaluate “knowledge”; lab exercises are used to demonstrate application of skills. In this course, assignments of later modules depends on the successful completion of earlier modules.\n\nZephyr & Nordic SoC Overview\nEvent-Driven State Machines\nVersion Control with Git\nC Programming Overview\nDevicetree, GPIO, ISR, Callbacks\nTimers & Work Queues\nThreads & Kernel Events\nState Machine Framework\nAnalog-to-Digital Conversion (ADC)\nPulse-Width Modulation (PWM)\nSerial Communication Protocols: UART, I2C, SPI\nBluetooth Low Energy (BLE)",
    "crumbs": [
      "Course Information",
      "Course Syllabus"
    ]
  },
  {
    "objectID": "course-syllabus.html#attendance-participation",
    "href": "course-syllabus.html#attendance-participation",
    "title": "Embedded Medical Devices",
    "section": "Attendance & Participation",
    "text": "Attendance & Participation\nClass participation in lecture and utilize lab time with your TAs is strongly encouraged. Lecture will be used to provide skill overview and live demonstrations, many of while will kickstart your efforts for your project. Lab time will be used to access bench lab equipment and the TAs for assistance.\nStudents are responsible for obtaining missed lecture content from other students in the class. All lecture slides/presented content will be made availabe online and lectures will be recorded via Panopto and posted to Canvas.\nParticipation on Ed Discussion is also encouraged, in the form of:\n\nAsking questions about the course material (ideally, publicly, so that others can benefit (Anonymous okay))\nAnswering questions from other students\nSharing interesting articles or resources related to the course material",
    "crumbs": [
      "Course Information",
      "Course Syllabus"
    ]
  },
  {
    "objectID": "course-syllabus.html#assignments-grading",
    "href": "course-syllabus.html#assignments-grading",
    "title": "Embedded Medical Devices",
    "section": "Assignments & Grading",
    "text": "Assignments & Grading\n\nGrading\nFundamental knowledge will be assessed with online quizzes and the Nordic DevAcademy Fundamentals lessons.\nLab exercises will focus on implementing key functionality towards the final working device (a wireless ECG and temperature sensor). Each lab exercise will be evaluated with code reviews and technical reports that assess functionality.\nAll assignment grades will be posted to Gradescope/Canvas throughout the semester to track your performance.\n\nGrade Distribution\n\n\nGrade Category\nRelative Percentage\n\n\n\n\nQuizzes\n20%\n\n\nNordic DevAcademy Fundamentals Certificates\n10%\n\n\nCode Reviews\n20%\n\n\nTechnical Reports\n40%\n\n\nParticipation\n10%\n\n\n\n\n\nExtra Credit\nExtra credit may be earned by completing the Nordic DevAcademy nRF Connect SDK Intermediate course.\nThis can be used to offset late assignments, missed quizzes, etc.\n\n\nCourse Grade\nThis course is not “curved” (i.e., a distribution of grades will not be enforced), and a traditional grading scheme will be used (e.g., 90-93 = A-, 94-97 = A, 97-100 = A+).\nFailing the course can happen with a cummulative score \\(&lt;\\) 70 (C-).\n\n\n\n\n\n\nTip\n\n\n\nParticipation throughout the semester will influence rounding up/down for fractional grades.\n\n\n\n\nRegrades\nAny regrading requests need to be made within one week of grades for a given assignment being released. You must make the request via Gradescope and provide a description of why you feel a regrade is appropriate. Requesting a regrade could lead to additional loss of credit when an assignment is re-evaluated.\nSome assignments will have an opportunity to be resubmitted based on grading feedback at the discretion of Dr. Palmeri.\n\n\nLate Policy / SDAO Accomodations\nLate submission windows will be available for some assignments and should be used to accomodate acute illness, travel, high workload from other classes and other unforeseen circumstances. When available, this late submission window can be utilized without penalty and without prior approval.\nStudents with SDAO accomodations for extended time on assignments can use this extended late submission window for all assignments.\nAny assignments submitted after the late submission window will only be accepted for partial credit at the discretion of Dr. Palmeri or if prior approval was sought before the original due date. Requests for late submission accomodation will be considered on a case-by-case basis and will result in a deduction in the course participation grade.",
    "crumbs": [
      "Course Information",
      "Course Syllabus"
    ]
  },
  {
    "objectID": "course-syllabus.html#duke-community-standard",
    "href": "course-syllabus.html#duke-community-standard",
    "title": "Embedded Medical Devices",
    "section": "Duke Community Standard",
    "text": "Duke Community Standard\nAll students are expected to adhere to all principles of the Duke Community Standard. Violations of the Duke Community Standard will be referred immediately to the Office of Student Conduct. Please do not hesitate to talk with Dr. Palmeri about any situations involving academic honor, especially if it is ambiguous what should be done.",
    "crumbs": [
      "Course Information",
      "Course Syllabus"
    ]
  },
  {
    "objectID": "course-syllabus.html#faq",
    "href": "course-syllabus.html#faq",
    "title": "Embedded Medical Devices",
    "section": "FAQ",
    "text": "FAQ\n\nCan I collaborate with other students?\nEngineering is inherently a collaborative field, and in this class, you are encouraged to work collaboratively on your projects. That being said, all of the work that you submit must be generated by you and reflect your understanding of the material.\n\n\n\n\n\n\nImportant\n\n\n\nAll resources used in your projects that were developed by another person or company must be properly acknowledged using comments in your code and lab reports.\n\n\n\n\nCan I use AI?\nThe use of artificial intelligence is a rapidly developing resource / tool in engineering. In software development, there are many levels of AI-assitance available. Such form of assistance include the IntelliCode tools and GitHub CoPilot (free to students through the GitHub Education program). These tools can be leveraged to help with syntax.\n\n\n\n\n\n\nCaution\n\n\n\nYou are strongly cautioned to not rely on these tools for logical implementation.",
    "crumbs": [
      "Course Information",
      "Course Syllabus"
    ]
  },
  {
    "objectID": "bme-lab-policies.html",
    "href": "bme-lab-policies.html",
    "title": "BME Lab Procedures and Safety Expectations",
    "section": "",
    "text": "Important\n\n\n\nSafety is Always First, Cleanliness a close second\n\n\nSafety always comes first in lab. To that end, you are expected to follow the rules in this document. Failure to do so may result in revocation of laboratory privileges, reduction of your course grade, and possible withdrawal from your course. Understanding risks and learning to work safely in the laboratory are an important part of your education.\nBefore entering lab, your safety training must be current. You need Duke’s Occupational and Environmental Safety Office’s:\n\nFire/Life Safety, and\nLaboratory Safety-General\n\ntraining modules. We know that you may have done this training before, but it expires in one year, and you must be current through the end of the semester.\nMost accidents are the result of a series of failures. That said, most accidents are preventable. You are responsible for your safety and the safety of those around you. The vast majority of accidents involve some combination of inattention, carelessness, horseplay, impairment, broken tools, and lack of knowledge. All of these factors can be mitigated and it’s your job to do so.\nYou are responsible for keeping the lab clean.\n\n\n\n\n\n\nWarning\n\n\n\nFailure to keep a clean workspace can result in a lower grade for you and your team.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nIf you or someone else in lab needs immediate medical attention, call 911.\n\n\nIn case you need to report your location, you are in CIEMAS B209. Non-emergent problems, call 681-WELL (681-9355).\n\n\n\n\n\n\nImportant\n\n\n\nIn the event of a non-emergent injury, seek medical attention and let an instructor/TA/lab staff know immediately (absolutely within 12 hours). Lab staff after-hours phone number is on the contact cards posted outside every lab door.\n\n\n\n\n\n\n\n\nNote\n\n\n\nKeep these points in mind…\n\nFind the emergency exits.\nNever work alone. Two or more people must be present and able to see and hear each other.\nInspect every tool before use. Remove broken tools from service, place them on the broken tools shelf at the back of the room, and notify lab staff.\nWear safety glasses when appropriate. This includes, but is not limited to, activities such as soldering, sanding, filing, hammering, cutting wood/plastic/wire, stripping wire and drilling.\nWear hearing protection when using noisy tools such as drills and the Dremel tool. Ear buds or music headphones are not sufficient hearing protection.\nNever work impaired. If you are tired, stressed, in a rush, or impaired in any other way then do not work in lab. Go home and recuperate.\nTie back long hair to keep it away from tools.\nClosed-toe shoes must be worn in the lab. Long trousers are preferred.\nProperly secure materials. Clamps, vises and portable worktables are available.\nDon’t force anything. If the job requires significant force, you’re doing it wrong.\nKeep food and drink out of the lab!\nPower down equipment when finished with it.\nA fire extinguisher is outside the door.\nWash your hands before leaving lab.\nBits of unused solder, wire and lead trimmings all go in a “Solder Scrap” container.\nAnything contaminated with solder paste (wipes, boards, applicators) goes in a “Solder Scrap” container.\nOther hazardous waste dealt with on a case by case basis; ask lab staff for help.\nPut tools away, in the right place. Tool drawers are labeled, but if you’re unsure where to put a tool, ask your TA/lab staff.\nDo not hoard parts or tools.\nThis bears repeating: Take the parts you need, but only the parts you need. Do not hoard parts. If you see a part becoming scarce, let lab staff know so they can re-order.\nBenches are for temporary use only. Leave no trace that you were at the bench when you leave for the day. Rarely, with approval, a bench can be claimed for the semester.\nAny and all paint must be pre-approved by an instructor/TA/lab staff. Unapproved paint on projects will result in a lower grade. (Spray paint indoors is never approved.)\nA representative from your group is expected to participate in weekly cleaning. Your instructor will give you the schedule.\nPlace a cover on the bench for messy work. Chucks and Ram Board are available for this.\nLab staff have a collection of good soldering tips and fine tools (e.g. tweezers). If you have need for something better than you can find in lab, ask lab staff.",
    "crumbs": [
      "Course Information",
      "BME Lab Policies"
    ]
  },
  {
    "objectID": "labs/zephyr-threads-events-lab.html",
    "href": "labs/zephyr-threads-events-lab.html",
    "title": "Zephyr: Threads & Kernel Events Lab",
    "section": "",
    "text": "Use best practices for version control (branching, commit messages, etc.).\nDo all development on a dedicated branch that is merged into main once it is functional.\nCommits should be very specific to the changes/additions you are making to your code. This will help you and others understand what you did and why you did it.\n\nOn a given development branch, try to implement one small piece of functionality at a time, commit it, and then move on to the next piece of functionality.\n\n\n\n\n\n\n\nImportant\n\n\n\nYou do not want one, monolithic git commit right before you submit your project.",
    "crumbs": [
      "Labs",
      "Threads and Kernel Events Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-threads-events-lab.html#git-version-control",
    "href": "labs/zephyr-threads-events-lab.html#git-version-control",
    "title": "Zephyr: Threads & Kernel Events Lab",
    "section": "",
    "text": "Use best practices for version control (branching, commit messages, etc.).\nDo all development on a dedicated branch that is merged into main once it is functional.\nCommits should be very specific to the changes/additions you are making to your code. This will help you and others understand what you did and why you did it.\n\nOn a given development branch, try to implement one small piece of functionality at a time, commit it, and then move on to the next piece of functionality.\n\n\n\n\n\n\n\nImportant\n\n\n\nYou do not want one, monolithic git commit right before you submit your project.",
    "crumbs": [
      "Labs",
      "Threads and Kernel Events Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-threads-events-lab.html#refactor-heartbeat-led-25-duty-cycle",
    "href": "labs/zephyr-threads-events-lab.html#refactor-heartbeat-led-25-duty-cycle",
    "title": "Zephyr: Threads & Kernel Events Lab",
    "section": "Refactor: Heartbeat LED (25% Duty Cycle)",
    "text": "Refactor: Heartbeat LED (25% Duty Cycle)\nYou will be refactoring your code from the timers lab to use a thread to control the heartbeat LED. Do all of the refactoring below on a new branch called heartbeat_refactor.\n\nRefactor your code to use a thread instead of a kernel timer to control the heartbeat LED.\nInstead of having your heartbeat blink at 1 Hz with a 50% duty cycle, change it to have a 25% duty cycle (i.e., on for 250 ms, off for 750 ms).",
    "crumbs": [
      "Labs",
      "Threads and Kernel Events Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-threads-events-lab.html#test-the-accuracy-of-the-heartbeat-led-timing",
    "href": "labs/zephyr-threads-events-lab.html#test-the-accuracy-of-the-heartbeat-led-timing",
    "title": "Zephyr: Threads & Kernel Events Lab",
    "section": "Test the Accuracy of the Heartbeat LED Timing",
    "text": "Test the Accuracy of the Heartbeat LED Timing\n\nCreate a new Jupyter notebook for this lab’s technical report called testing/thread_testing.ipynb that analyzes the accuracy of your 25% duty cycle heartbeat LED.\nPerform these measurements using the oscilloscope, and save all raw data in dedicated CSV files.\nChoose what to measure and how to analyze the data to verify that the heartbeat LED thread is working as expected.\nDiscuss the results of your measurements and how they compare to the nominal specifications for the heartbeat LED.",
    "crumbs": [
      "Labs",
      "Threads and Kernel Events Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-threads-events-lab.html#merge-n-tag-this-refactored-heartbeat-led-code-and-analysis",
    "href": "labs/zephyr-threads-events-lab.html#merge-n-tag-this-refactored-heartbeat-led-code-and-analysis",
    "title": "Zephyr: Threads & Kernel Events Lab",
    "section": "Merge-n-Tag this Refactored Heartbeat LED Code and Analysis",
    "text": "Merge-n-Tag this Refactored Heartbeat LED Code and Analysis\n\n\n\n\n\n\nTip\n\n\n\nMake sure that your Jupyter notebook reads in data from relative paths for the repository, not absolute paths on your local machine.\n\n\n\nPush your heartbeat_refactor branch to GitLab.\nCreate a new Merge Request to merge heartbeat_refactor into your forked repository’s main branch.\nMerge your heartbeat_refactor branch into your main branch, and create an annotated tag for that merged commit called v1.2.0.",
    "crumbs": [
      "Labs",
      "Threads and Kernel Events Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-threads-events-lab.html#refactor-kernel-events",
    "href": "labs/zephyr-threads-events-lab.html#refactor-kernel-events",
    "title": "Zephyr: Threads & Kernel Events Lab",
    "section": "Refactor: Kernel Events",
    "text": "Refactor: Kernel Events\n\nDo the following refactoring on a new branch called kernel_events_refactor, branched after the v1.2.0 commit.\nRefactor all of your code to remove Boolean variables being used in your ISR callback functions to indicate that buttons have been pressed to now use kernel events in a single bit array called button_events.\nYou should use 1-bit for each button, meaning the bit array is 4-bits.\nImplement a k_event_wait() in the appropriate state(s) of your main thread to wait for button events to occur. This will be a blocking wait, meaning the main thread while loop will not be running while waiting for button events.",
    "crumbs": [
      "Labs",
      "Threads and Kernel Events Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-threads-events-lab.html#verify-that-your-led-timing-still-works",
    "href": "labs/zephyr-threads-events-lab.html#verify-that-your-led-timing-still-works",
    "title": "Zephyr: Threads & Kernel Events Lab",
    "section": "Verify that your LED Timing Still Works",
    "text": "Verify that your LED Timing Still Works\n\nCreate a new Jupyter notebook called testing/kernel_events_validation.ipynb to verify that your refactored code still works as expected.\nIt is up to you to now determine how to verify that your LED timing is still working with regard to what data to collect, how to analyze it, and how to present it in your notebook.",
    "crumbs": [
      "Labs",
      "Threads and Kernel Events Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-threads-events-lab.html#merge-n-tag-this-refactored-kernel-events-code-and-analysis",
    "href": "labs/zephyr-threads-events-lab.html#merge-n-tag-this-refactored-kernel-events-code-and-analysis",
    "title": "Zephyr: Threads & Kernel Events Lab",
    "section": "Merge-n-Tag this Refactored Kernel Events Code and Analysis",
    "text": "Merge-n-Tag this Refactored Kernel Events Code and Analysis\n\nCreate a Merge Request to merge kernel_events_refactor into your main branch.\nMerge your kernel_events_refactor branch into your main branch.\nCreate an annotated tag for that merge commit called v1.3.0.\nCreate an Issue assigned to Dr. Palmeri to review your code for both v1.2.0 and v1.3.0.",
    "crumbs": [
      "Labs",
      "Threads and Kernel Events Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-threads-events-lab.html#how-do-i-ask-for-help",
    "href": "labs/zephyr-threads-events-lab.html#how-do-i-ask-for-help",
    "title": "Zephyr: Threads & Kernel Events Lab",
    "section": "How do I ask for help?",
    "text": "How do I ask for help?\n\nIf you have a general / non-coding question, you should ask your TAs / Dr. Palmeri on Ed to allow any of them to respond in a timely manner.\nPush you code to your GitLab repository, ideally with your active development on a non-main branch.\nCreate an Issue in your repository.\n\nAdd as much detail as possible as to your problem, and add links to specific lines / section of code when possible.\nAssign the label “Bug” or “Question”, as appropriate.\nBe sure to specify what branch you are working on.\nAssign the Issue to one of the TAs.\nIf your TA cannot solve your Issue, they can escalate the Issue to Dr. Palmeri.\n\nYou will get a response to your Issue, and maybe a new branch of code will be pushed to help you with some example syntax that you can use git diff to visualize.",
    "crumbs": [
      "Labs",
      "Threads and Kernel Events Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-adc-lab.html",
    "href": "labs/zephyr-adc-lab.html",
    "title": "Analog-to-Digital Conversion (ADC) Lab",
    "section": "",
    "text": "Implement single-sample and buffered ADC data acquisitions.\nImplement fixed-reference and differential ADC inputs.\nImplement synchronous and asynchronous ADC acquisitions.",
    "crumbs": [
      "Labs",
      "Analog-to-Digital Conversion (ADC) Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-adc-lab.html#learning-objectives",
    "href": "labs/zephyr-adc-lab.html#learning-objectives",
    "title": "Analog-to-Digital Conversion (ADC) Lab",
    "section": "",
    "text": "Implement single-sample and buffered ADC data acquisitions.\nImplement fixed-reference and differential ADC inputs.\nImplement synchronous and asynchronous ADC acquisitions.",
    "crumbs": [
      "Labs",
      "Analog-to-Digital Conversion (ADC) Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-adc-lab.html#git-best-practices",
    "href": "labs/zephyr-adc-lab.html#git-best-practices",
    "title": "Analog-to-Digital Conversion (ADC) Lab",
    "section": "Git Best Practices",
    "text": "Git Best Practices\n\nUse best practices for version control (branching, commit messages, etc.).\nDo all development on a dedicated branch that is merged into main once it is functional.\nCommits should be very specific to the changes/additions you are making to your code. This will help you and others understand what you did and why you did it.\n\nOn a given development branch, try to implement one small piece of functionality at a time, commit it, and then move on to the next piece of functionality.\n\n\n\n\n\n\n\nImportant\n\n\n\nYou do not want one, monolithic git commit right before you submit your project.",
    "crumbs": [
      "Labs",
      "Analog-to-Digital Conversion (ADC) Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-adc-lab.html#firmware-expectations",
    "href": "labs/zephyr-adc-lab.html#firmware-expectations",
    "title": "Analog-to-Digital Conversion (ADC) Lab",
    "section": "Firmware Expectations",
    "text": "Firmware Expectations\n\nAll firmware should be written using the State Machine Framework.\nChoose your states for each part as a firmware engineer would, using what you have learned so far this semester.\nTimers, work queues, callbacks, and interrupts should be used as appropriate.\nAll good coding practices developed this semester should be followed.\nUse logging to display state information and other relevant information, warnings, and errors. Debugging log messages can remain in the code, but the logging level should be submitted at the INF level.\nInclude a state diagram in your repository (state_diagram.png) using UML (state_diagram.puml) or some equivalent.\n\n\n\n\n\n\n\nNote\n\n\n\nYou will continue to build upon the firmware from your previous labs, but you are replacing all functional specifications with those in this lab.\nAll states should be reconsidered given the new functional specifications.\nThis significant change in functionality is represented with the version tags changing to a new major version number starting at v2.0.0.",
    "crumbs": [
      "Labs",
      "Analog-to-Digital Conversion (ADC) Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-adc-lab.html#adc-single-sampling",
    "href": "labs/zephyr-adc-lab.html#adc-single-sampling",
    "title": "Analog-to-Digital Conversion (ADC) Lab",
    "section": "ADC Single Sampling",
    "text": "ADC Single Sampling\n\nFirmware Functional Specifications\n\nDo all development and testing for Part I on a developnment branch called adc_single_sample.\nLED and BUTTON number references below are based on Devicetree labels (not the annotation on the DK board itself).\nThere should be a heartbeat LED (LED0) that blinks at 1 Hz with a 25% duty cycle at all times when the firmware is running.\nWhen BUTTON0 is pressed, make a measurement using the AIN0 channel of the ADC.\n\nUse the ADC_REF_INTERNAL reference voltage.\nLinearly map 0-3.0 V measured on the AIN0 input to an LED1 blink rate of 1-5 Hz (e.g., 0 V -&gt; 1 Hz; 3.0 V -&gt; 5 Hz) with a duty cycle of 10%.\nLED1 should remaining blinking for 5 seconds after the button has been pressed.\n\nBUTTON0 should be disabled while the ADC measurement and LED1 blinking.\nAll errors should result in a transition to an ERROR state that can only be exited by hitting a reset button.\n\n\n\nTesting\nFor the following testing, you can use a power supply to provide known voltage input to AIN0.\n\nQuantify how linear the relationship is between the voltage applied to AIN0 and the LED1 blinking frequency by acquiring data to perform a linear regression of these variables and analyzing the resultant \\(R^2\\), slope and intercept.\n\n\n\n\n\n\n\nTip\n\n\n\nRemember that single data points for any single input voltage pair is not adequate; multiple measurements should be made and error bars presented on all plots.\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe bme554.py library has a functions called plot_with_fit() and calculate_confidence_intervals() that can help.\n\n\n\nQuantify the accuracy of the LED1 10% duty cycle for each frequency that you measure.\nQuantify the accuracy of LED1 5 second ontime duration.\nPresent all of these data, your analysis and your interpretation in a new Jupyter notebook named testing/testing_adc_single_sample.ipynb.\n\n\n\nCommit-n-Merge Single Sample Acquisition\n\nUpdate your state diagram.\nMerge your completed adc_single_sample branch into your main branch using a Merge Request on Gitlab.\nCreate an annotated tag of your main branch with all part of this lab merged in called v2.0.0.\nCreate an Issue assigned to your teaching assistant indicating that this tag is ready for review.",
    "crumbs": [
      "Labs",
      "Analog-to-Digital Conversion (ADC) Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-adc-lab.html#buffered-differential-adc-sampling",
    "href": "labs/zephyr-adc-lab.html#buffered-differential-adc-sampling",
    "title": "Analog-to-Digital Conversion (ADC) Lab",
    "section": "Buffered Differential ADC Sampling",
    "text": "Buffered Differential ADC Sampling\n\nFirmware Functional Specifications\nIn a new development branch called diff_adc, add the following functionality to your firmware:\n\nWhen you press BUTTON1 , add an additional differential ADC measurement using AIN1 and AIN2.\nChoose the reference voltage, gain, bit depth and acquisition time to adequately sample at least 20 cycles of a 10 Hz sinusoidal signal (\\(V_{pp}\\) = 2 V). 0 Implement the extra_sampling buffering of the ADC for this differential sinusoidal signal measurement so that all of the data are stored in an array in a single adc_read() call (i.e., you are not using a kernel call for every sample).\nDisable the BUTTON1 while your device is reading AIN1 and AIN2 and performing calculations below. 0 Write a library called calc_cycles that calculates the number of sampled sinusoidal cycles in the buffered ADC samples.\n\nThis can be rounded to the nearest integer, depending on your algorithm.\nHave this calculated number of cycles displayed using LOG_INF() in the console.\n\nWrite log messages to your serial terminal that dsplay a HEX array of the buffered ADC samples.\nUpdate your state diagram for this new functionality.\n\n\n\n\n\n\n\nWarning\n\n\n\nBe careful for the log message memory consumption! You may need to adjust the stack size of the appopriate thread if you are getting memory-related firmware faults.\n\n\n\n\n\n\n\n\nNote\n\n\n\nRemember that the data will be saved using two’s complement.\n\n\n\n\nTesting\n\nInput a 10 Hz sinusoidal signal with a 2 V \\(V_{pp}\\) into the differential AIN1 and AIN2 inputs.\nCreate a plot of your input signal and the buffered ADC samples (using the HEX array output).\n\n\n\n\n\n\n\nTip\n\n\n\nThere are helper functions in bme554.py called read_hex_data() and unwrap_twos_completely().\nThe HEX data array from the terminal can be copied and pasted into a text file in your git repository to read into your Jupyter notebook for analysis.\n\n\n\nDiscuss any differences between the input signal and your sampled signal.\nCalculate the frequency of your sampled signal and compare it to your input frequency.\nAdd this analysis to a new Jupyter notebook named testing/testing_adc_sync.ipynb.\n\n\n\n\n\n\n\nWarning\n\n\n\nMerging Jupyter notebooks from different branches can be tricky and usually requires some extra tools or manual intervention. We are creating separate Jupyter notebooks for each part of this lab in case you jump to code development in a different part before finishing the testing for the previous part.\n\n\n\n\nCommit-n-Merge Buffered Acquisition\n\nMerge your completed diff_adc branch into your main branch using a Merge Request on Gitlab.\nCreate an annotated tag of your main branch with all part of this lab merged in called v2.1.0.\nCreate an Issue assigned to your teaching assistant indicating that this tag is ready for review.",
    "crumbs": [
      "Labs",
      "Analog-to-Digital Conversion (ADC) Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-adc-lab.html#asynchronous-adc-sampling",
    "href": "labs/zephyr-adc-lab.html#asynchronous-adc-sampling",
    "title": "Analog-to-Digital Conversion (ADC) Lab",
    "section": "Asynchronous ADC Sampling",
    "text": "Asynchronous ADC Sampling\n\nFirmware Functional Specifications\nIn a new development branch called async_adc, add the following functionality to your firmware:\n\nRefactor your blocking, synchronous buffered ADC sequence acquisition to an asynchronous acquisition that populates the same array that was populated with the synchronous approach.\nUtilize the 3 Zephyr enumerations presented in lecture to modulate the behaviour of the asynchronous callback function.\nUse a kernel poll (k_poll) to wait for the ADC sequence to complete.\nImplement a timeout mechanism to handle the case where the ADC sequence does not complete within a reasonable time frame.\n\n\n\nTesting\n\nRepeat the testing you performed in a new Jupyter notebook named testing/testing_adc_async.ipynb.\nDiscuss the benefits and drawbacks of the asyncronous ADC sequence sampling compared to the synchronous sampling.\n\n\n\nCommit-n-Merge Asynchronous Sampling\n\nMerge your completed async_adc branch into your main branch using a Merge Request on Gitlab.\nCreate an annotated tag of your main branch with all part of this lab merged in called v2.2.0.\nCreate an Issue assigned to your teaching assistant indicating that this tag is ready for review.",
    "crumbs": [
      "Labs",
      "Analog-to-Digital Conversion (ADC) Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-adc-lab.html#timer-based-single-sampling-to-array",
    "href": "labs/zephyr-adc-lab.html#timer-based-single-sampling-to-array",
    "title": "Analog-to-Digital Conversion (ADC) Lab",
    "section": "Timer-Based Single Sampling to Array",
    "text": "Timer-Based Single Sampling to Array\n\nFirmware Functional Specifications\nIn a new development branch called timer_adc, add the following functionality to your firmware:\n\nRefactor your firmware to use a kernel timer to do single ADC samples that are sequentially stored in the array that was associated with the ADC sequence in the previous two sections.\n\n\n\nTesting\n\nRepeat the testing you performed in the asyncronous section for this timer-based implementation in a new Jupyter notebook named testing/testing_adc_timer.ipynb.\nDiscuss the benefits and drawbacks of using a timer-based ADC sampling scheme compared to the previous approaches when trying to accurately sample a sinusoidal signal.\n\n\n\nCommit-n-Merge Timer Sampling\n\nMerge your completed timer_adc branch into your main branch using a Merge Request on Gitlab.\nCreate an annotated tag of your main branch with all part of this lab merged in called v2.3.0.\nCreate an Issue assigned to your teaching assistant indicating that this tag is ready for review.",
    "crumbs": [
      "Labs",
      "Analog-to-Digital Conversion (ADC) Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-adc-lab.html#how-to-ask-for-help",
    "href": "labs/zephyr-adc-lab.html#how-to-ask-for-help",
    "title": "Analog-to-Digital Conversion (ADC) Lab",
    "section": "How to Ask for Help",
    "text": "How to Ask for Help\n\nIf you have a general / non-coding question, you should ask your TAs / Dr. Palmeri on Ed to allow any of them to respond in a timely manner.\nPush you code to your GitLab repository, ideally with your active development on a non-main branch.\nCreate an Issue in your repository.\n\nAdd as much detail as possible as to your problem, and add links to specific lines / section of code when possible.\nAssign the label “Bug” or “Question”, as appropriate.\nBe sure to specify what branch you are working on.\nAssign the Issue to one of the TAs.\nIf your TA cannot solve your Issue, they can escalate the Issue to Dr. Palmeri.\n\nYou will get a response to your Issue, and maybe a new branch of code will be pushed to help you with some example syntax that you can use git diff to visualize.",
    "crumbs": [
      "Labs",
      "Analog-to-Digital Conversion (ADC) Lab"
    ]
  },
  {
    "objectID": "labs/timers-lab-testing-notebook/timing_analysis.html",
    "href": "labs/timers-lab-testing-notebook/timing_analysis.html",
    "title": "Timers Technical Report (ENTER NAME AND NET ID HERE)",
    "section": "",
    "text": "Briefly describe what your did for each type of data acquisition (e.g., how did you capture the logging data and save data from the oscilloscope).\nThe code below is just starter / example code that you can use to help guide how you approach doing this analysis. Feel free to use other analysis approaches if you are more comfortable with them, as long as you can draw the same conclusions from your testing."
  },
  {
    "objectID": "labs/timers-lab-testing-notebook/timing_analysis.html#methods",
    "href": "labs/timers-lab-testing-notebook/timing_analysis.html#methods",
    "title": "Timers Technical Report (ENTER NAME AND NET ID HERE)",
    "section": "",
    "text": "Briefly describe what your did for each type of data acquisition (e.g., how did you capture the logging data and save data from the oscilloscope).\nThe code below is just starter / example code that you can use to help guide how you approach doing this analysis. Feel free to use other analysis approaches if you are more comfortable with them, as long as you can draw the same conclusions from your testing."
  },
  {
    "objectID": "labs/timers-lab-testing-notebook/timing_analysis.html#data-analysis",
    "href": "labs/timers-lab-testing-notebook/timing_analysis.html#data-analysis",
    "title": "Timers Technical Report (ENTER NAME AND NET ID HERE)",
    "section": "Data Analysis",
    "text": "Data Analysis\n\n# import useful packages for data analysis\nimport numpy as np\nimport scipy as sp\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n\nLogging Data\n\n# import data from CSV or similar files\n# DO NOT copy/paste raw data into the notebook directly (!); data should be independent on this notebook\ntiming_data = pd.read_csv('log_data.csv')\n\n# consider showing a snippet of the raw data too\ntiming_data.head(20)\n\n\n\n\n\n\n\n\nIdeal Period (ms)\nMeasurement Period (ms)\n\n\n\n\n0\n1000\n1005\n\n\n1\n1000\n1003\n\n\n2\n1000\n1001\n\n\n3\n1000\n990\n\n\n4\n1000\n995\n\n\n5\n500\n490\n\n\n6\n500\n495\n\n\n7\n500\n497\n\n\n8\n500\n492\n\n\n9\n500\n491\n\n\n10\n2000\n2100\n\n\n11\n2000\n2000\n\n\n12\n2000\n2300\n\n\n13\n2000\n1900\n\n\n14\n2000\n1950\n\n\n\n\n\n\n\n\n# display a plot or table of the data, along with the nominal values\ntiming_data.groupby('Ideal Period (ms)')['Measurement Period (ms)'].describe() \n\n\n\n\n\n\n\n\ncount\nmean\nstd\nmin\n25%\n50%\n75%\nmax\n\n\nIdeal Period (ms)\n\n\n\n\n\n\n\n\n\n\n\n\n500\n5.0\n493.0\n2.915476\n490.0\n491.0\n492.0\n495.0\n497.0\n\n\n1000\n5.0\n998.8\n6.180615\n990.0\n995.0\n1001.0\n1003.0\n1005.0\n\n\n2000\n5.0\n2050.0\n158.113883\n1900.0\n1950.0\n2000.0\n2100.0\n2300.0\n\n\n\n\n\n\n\n\n# calculate the 95% confidence interval for the mean timing interval\nconfidence_interval = timing_data.groupby('Ideal Period (ms)')['Measurement Period (ms)'].apply(\n    lambda x: sp.stats.t.interval(0.95, len(x)-1, loc=np.mean(x), scale=sp.stats.sem(x))\n)\nprint(confidence_interval)\n\nIdeal Period (ms)\n500      (489.3799584784563, 496.6200415215437)\n1000    (991.1257530463614, 1006.4742469536385)\n2000    (1853.675683852244, 2246.3243161477562)\nName: Measurement Period (ms), dtype: object\n\n\n\n\nOscilloscope Data\n\n# import data from CSV or similar files\n# DO NOT copy/paste raw data into the notebook directly (!); data should be independent on this notebook\ntiming_data = pd.read_csv('oscope_data.csv')\n\n# consider showing a snippet of the raw data too\ntiming_data.head(20)\n\n\n\n\n\n\n\n\nIdeal Period (ms)\nMeasurement Period (ms)\n\n\n\n\n0\n1000\n1005\n\n\n1\n1000\n1003\n\n\n2\n1000\n1001\n\n\n3\n1000\n990\n\n\n4\n1000\n995\n\n\n5\n500\n490\n\n\n6\n500\n495\n\n\n7\n500\n497\n\n\n8\n500\n492\n\n\n9\n500\n491\n\n\n10\n2000\n2100\n\n\n11\n2000\n2000\n\n\n12\n2000\n2300\n\n\n13\n2000\n1900\n\n\n14\n2000\n1950\n\n\n\n\n\n\n\n\n# display a plot or table of the data, along with the nominal values\ntiming_data.groupby('Ideal Period (ms)')['Measurement Period (ms)'].describe() \n\n\n\n\n\n\n\n\ncount\nmean\nstd\nmin\n25%\n50%\n75%\nmax\n\n\nIdeal Period (ms)\n\n\n\n\n\n\n\n\n\n\n\n\n500\n5.0\n493.0\n2.915476\n490.0\n491.0\n492.0\n495.0\n497.0\n\n\n1000\n5.0\n998.8\n6.180615\n990.0\n995.0\n1001.0\n1003.0\n1005.0\n\n\n2000\n5.0\n2050.0\n158.113883\n1900.0\n1950.0\n2000.0\n2100.0\n2300.0\n\n\n\n\n\n\n\n\n# calculate the 95% confidence interval for the mean timing interval\nconfidence_interval = timing_data.groupby('Ideal Period (ms)')['Measurement Period (ms)'].apply(\n    lambda x: sp.stats.t.interval(0.95, len(x)-1, loc=np.mean(x), scale=sp.stats.sem(x))\n)\nprint(confidence_interval)"
  },
  {
    "objectID": "labs/timers-lab-testing-notebook/timing_analysis.html#discussion",
    "href": "labs/timers-lab-testing-notebook/timing_analysis.html#discussion",
    "title": "Timers Technical Report (ENTER NAME AND NET ID HERE)",
    "section": "Discussion",
    "text": "Discussion\n\nHow do your logging-based data and oscilloscope data compare to the nominal timing intervals?\n\n\nWhich measurement approach is more accurate?\n\n\nIs there any difference in the accuracy of the default, slowest and fastest blink rate accuracy / precision?"
  },
  {
    "objectID": "labs/c-programming-lab.html",
    "href": "labs/c-programming-lab.html",
    "title": "C Programming Lab",
    "section": "",
    "text": "Complete Nordic DevAcademy: Lesson 3 – Elements of an nRF Connect SDK application\nComplete Nordic DevAcademy: Lesson 4 – Printing messages to console and logging\nReview Debugging resource.",
    "crumbs": [
      "Labs",
      "C Programming Lab"
    ]
  },
  {
    "objectID": "labs/c-programming-lab.html#prelab",
    "href": "labs/c-programming-lab.html#prelab",
    "title": "C Programming Lab",
    "section": "",
    "text": "Complete Nordic DevAcademy: Lesson 3 – Elements of an nRF Connect SDK application\nComplete Nordic DevAcademy: Lesson 4 – Printing messages to console and logging\nReview Debugging resource.",
    "crumbs": [
      "Labs",
      "C Programming Lab"
    ]
  },
  {
    "objectID": "labs/c-programming-lab.html#objectives",
    "href": "labs/c-programming-lab.html#objectives",
    "title": "C Programming Lab",
    "section": "Objectives",
    "text": "Objectives\n\nIntroduction to C Programming\nBuilding Zephyr application\nFlashing Zephyr application\nViewing serial output from Zephyr application running on your nrf52833DK\nDebugging Zephyr applications in VS Code",
    "crumbs": [
      "Labs",
      "C Programming Lab"
    ]
  },
  {
    "objectID": "labs/c-programming-lab.html#zephyr-application-git-repository-overview",
    "href": "labs/c-programming-lab.html#zephyr-application-git-repository-overview",
    "title": "C Programming Lab",
    "section": "Zephyr Application Git Repository Overview",
    "text": "Zephyr Application Git Repository Overview\n\nsrc/main.c - main application code\n.gitingore - ignore files that are not needed in the git repository\nCMakeLists.txt - build system configuration file\nprj.conf - Zephyr configuration file\nREADME.md - this file\nCMakePresets.json - CMake presets file (build configuration)\n.gitlab-ci.yml - GitLab CI configuration file",
    "crumbs": [
      "Labs",
      "C Programming Lab"
    ]
  },
  {
    "objectID": "labs/c-programming-lab.html#things-to-do",
    "href": "labs/c-programming-lab.html#things-to-do",
    "title": "C Programming Lab",
    "section": "Things To Do",
    "text": "Things To Do",
    "crumbs": [
      "Labs",
      "C Programming Lab"
    ]
  },
  {
    "objectID": "labs/c-programming-lab.html#git-best-practices",
    "href": "labs/c-programming-lab.html#git-best-practices",
    "title": "C Programming Lab",
    "section": "Git Best Practices",
    "text": "Git Best Practices\n\nUse best practices for version control (branching, commit messages, etc.).\nDo all development on a dedicated branch that is merged into main once it is functional.\nCommits should be very specific to the changes/additions you are making to your code. This will help you and others understand what you did and why you did it.\n\nOn a given development branch, try to implement one small piece of functionality at a time, commit it, and then move on to the next piece of functionality.\n\n\n\n\n\n\n\nImportant\n\n\n\nYou do not want one, monolithic git commit right before you submit your project.\n\n\n\nFork / Clone / Build / Flash / View Serial Output\n\nFork the C Programing lab repository on Duke’s GitLab server: https://gitlab.oit.duke.edu/kits/BME-554L-001-F25/c-programming-lab\nAdd Dr. Palmeri (mlp6) as a Maintainer in your forked repository.\nClone your forked repository to your local machine.\nBuild the Zephyr application “as is” (review DevAcademy: Lesson 1).\nFlash the Zephyr application to your development kit.\n\nConnect the VCOM port on the nrf52833DK to your computer (using Connected Devices and the plug icon)\nLook at the serial output in the VS Code Terminal\n\n\n\n\nModify the Zephyr Application (DataTypes / Typecasting / Formatted Printing)\n\nInspect the code to see how variables a, b and c are declared and initialized.\nFlash the existing code and note the terminal output:\n\n\n\nOn a development branch called fix_division, without changing the declared datatypes of a, b, or c, correct the code so that c is output in the terminal:\n\n\n\nPush the fix_division branch to your GitLab repository.\nCreate a Merge Request to merge the fix_division branch into your main branch.\nMake sure the GitLab CI pipeline is successful before merging the fix_division branch into main. If it isn’t passing, fix the problem locally on the same branch and push the changes to GitLab.\nPull your updated main branch to your local machine.\nCreate an annotated tag for the merged commit on main with the fixed division named v1.0.0.\nPush this annotated tag to your GitLab repository.\n\n\n\n\n\n\n\nTip\n\n\n\nNote that the CI pipelines running on the GitLab server can take a while to complete. Do not rely on them for immediate development feedback, but rather as a final check before merging code into main.",
    "crumbs": [
      "Labs",
      "C Programming Lab"
    ]
  },
  {
    "objectID": "labs/c-programming-lab.html#library-refactor",
    "href": "labs/c-programming-lab.html#library-refactor",
    "title": "C Programming Lab",
    "section": "Library Refactor",
    "text": "Library Refactor\n\nOn another development branch on your local machine called refactor_library, refactor the code to put the divide_numbers() function into a library called my_math_functions.h.\nOnce you have your code working with this library, locally merge the refactor_library branch into main.\nCreate an annotated tag for the merged commit on main with the refactored library named v1.1.0.\nPush the new commit(s) and annotated tag to your GitLab repository. Remember, this will need to be done with two commands, git push and git push --tags.",
    "crumbs": [
      "Labs",
      "C Programming Lab"
    ]
  },
  {
    "objectID": "labs/c-programming-lab.html#push-everything-to-gitlab-create-an-issue-to-notify-dr.-palmeri",
    "href": "labs/c-programming-lab.html#push-everything-to-gitlab-create-an-issue-to-notify-dr.-palmeri",
    "title": "C Programming Lab",
    "section": "Push Everything to GitLab & Create an Issue to Notify Dr. Palmeri",
    "text": "Push Everything to GitLab & Create an Issue to Notify Dr. Palmeri\n\nMake sure all of your commits are pushed to your main branch, along with both annotated tags.\nConfirm that the GitLab CI pipeline is successful.\nCreate an Issue titled C Programming Lab Complete and assign it to Dr. Palmeri (mlp6).",
    "crumbs": [
      "Labs",
      "C Programming Lab"
    ]
  },
  {
    "objectID": "labs/c-programming-lab.html#gradescope",
    "href": "labs/c-programming-lab.html#gradescope",
    "title": "C Programming Lab",
    "section": "Gradescope",
    "text": "Gradescope\nComplete the Gradescope assignment for this lab that is a few simple tasks:\n\nConfirm that you created the Issue above\nConfirm that you completed both of the Nordic DevAcademy lessons\nUpload a screenshot of your CI pipeline jobs passing",
    "crumbs": [
      "Labs",
      "C Programming Lab"
    ]
  },
  {
    "objectID": "labs/c-programming-lab.html#how-to-ask-for-help",
    "href": "labs/c-programming-lab.html#how-to-ask-for-help",
    "title": "C Programming Lab",
    "section": "How to Ask for Help",
    "text": "How to Ask for Help\n\nIf you have a general / non-coding question, you should ask your TAs / Dr. Palmeri on Ed to allow any of them to respond in a timely manner.\nPush you code to your GitLab repository, ideally with your active development on a non-main branch.\nCreate an Issue in your repository.\n\nAdd as much detail as possible as to your problem, and add links to specific lines / section of code when possible.\nAssign the label “Bug” or “Question”, as appropriate.\nBe sure to specify what branch you are working on.\nAssign the Issue to one of the TAs.\nIf your TA cannot solve your Issue, they can escalate the Issue to Dr. Palmeri.\n\nYou will get a response to your Issue, and maybe a new branch of code will be pushed to help you with some example syntax that you can use git diff to visualize.",
    "crumbs": [
      "Labs",
      "C Programming Lab"
    ]
  },
  {
    "objectID": "labs/ecg-temp-ble-lab.html",
    "href": "labs/ecg-temp-ble-lab.html",
    "title": "ECG & Temperature Sensor with BLE Lab",
    "section": "",
    "text": "This lab will be the final addition of functionality to your course firmware repository. You should take all functional specifications below to override and replace any previous lab functionality. You should refactor your code from all of the previous labs to demonstrate your mastery of best coding practices from this semester.",
    "crumbs": [
      "Labs",
      "ECG, Temperature Sensor, and BLE Lab"
    ]
  },
  {
    "objectID": "labs/ecg-temp-ble-lab.html#git-version-control",
    "href": "labs/ecg-temp-ble-lab.html#git-version-control",
    "title": "ECG & Temperature Sensor with BLE Lab",
    "section": "Git Version Control",
    "text": "Git Version Control\n\nUse best practices for version control (branching, commit messages, etc.).\nDo all development on a dedicated branch that is merged into main once it is functional.\nCommits should be very specific to the changes/additions you are making to your code. This will help you and others understand what you did and why you did it.\n\nOn a given development branch, try to implement one small piece of functionality at a time, commit it, and then move on to the next piece of functionality.\n\n\n\n\n\n\n\nImportant\n\n\n\nYou do not want one, monolithic git commit right before you submit your project.",
    "crumbs": [
      "Labs",
      "ECG, Temperature Sensor, and BLE Lab"
    ]
  },
  {
    "objectID": "labs/ecg-temp-ble-lab.html#best-coding-practices",
    "href": "labs/ecg-temp-ble-lab.html#best-coding-practices",
    "title": "ECG & Temperature Sensor with BLE Lab",
    "section": "Best Coding Practices",
    "text": "Best Coding Practices\nYou should refactor your code from all of the previous labs to demonstrate your mastery of best coding practices from this semester. Some reminders:\n\nFunctions should be short and do one thing. They should return an exit code that is checked in the calling function, indicating success or failure.\nMACROS! Avoid hard-coded values in your code.\nUse structs to organize related data.\nUse libraries for code that is self-contained.\nUse the LOGGING module to log errors, warnings, information and debug messages.\nYou should not have any compiler/build warnings. The CI script will build against v3.2.1 of the Zephyr SDK.",
    "crumbs": [
      "Labs",
      "ECG, Temperature Sensor, and BLE Lab"
    ]
  },
  {
    "objectID": "labs/ecg-temp-ble-lab.html#firmware-functional-specifications",
    "href": "labs/ecg-temp-ble-lab.html#firmware-functional-specifications",
    "title": "ECG & Temperature Sensor with BLE Lab",
    "section": "Firmware Functional Specifications",
    "text": "Firmware Functional Specifications\n\nWrite all firmware using the state machine framework.\n\nDo all device initialization in an INIT state.\nHave an IDLE state when the device isn’t making any measurements.\nHave an ERROR state if any error exit codes are returned from any functions.\n\nAll 4 LEDs should blink at a 50% duty cycle (ON:OFF time), in-phase with each other, in the ERROR state.\nAn error condition should post an error-related event that causes the device to enter the ERROR state.\nThe error code should specify the error condition that caused the device to enter the ERROR state. For example, you may choose to have a bit array that can capture multiple error conditions.\nA BLE notification should be sent with the error code (see BLE custom service/characteristic below).\n\nImplement states of your choosing for the following measurements, calculations and BLE communications.\n\nHave a heartbeat LED0 that blinks every 1 second with a 50% duty cycle (ON:OFF time) in all states.\nImplement functionality to measure a battery voltage (0-3.0 V) using AIN0:\n\nWhen the device first powers on, and then\nEvery 1 minute thereafter, but only when in the IDLE state.\nYou won’t actually be connecting a battery to your device; you can use a power support or another voltage source to input a voltage to AIN0 to simulate a battery level.\n\nHave the brightness of LED1 linearly modulated by the percentage of the battery level.\nImplement functionality to make a temperature measurement with your MCP9808 sensor (in degrees Celsius) after pressing BUTTON1.\nWhen you press BUTTON2, the device should measure “instantaneous” heart rate, expected to range from 40-200 BPM, using an ECG signal (ranging from -500 - 500 mV, note this is bipolar) from the function generator (see video on how to setup the function generator to output an ECG signal).\n\nPressing BUTTON2 during ECG measurements will stop the “live” ECG measurements.\nBlink LED2 with a 25% duty cycle (ON:OFF time) at the average heart rate you have calculated (updated as often as you feel is appropriate).\nYou should decide how often the heart rate is updated in the blinking rate of LED2 (e.g., every 1 second, every 5 seconds, etc.).\nBUTTON1 is allowed to be pressed during ECG measurements to take temperature measurements.\n\nHave Bluetooth notifications after the measurements are complete/updated and data have been processed, using the BLE services and characteristics described below.\n\nConfigure the DIS (Device Information Service) to report the device model as your Team Name (come up with something fun).\nSet the BAS (Battery Service) to report the battery level of your device. (This isn’t actually a battery level, but we’re using the AIN0 measurement as a surrogate for a battery level.)\nSet the Heart Rate Service to report the average heart rate. (See Resources section below.)\nSetup a custom service with the following custom characterisitics:\n\nTemperature for the I2C temperature sensor data in degrees Celcius.\nError Code for the error code that caused the device to enter the ERROR state.\n\n\nBUTTON3 should be used to reset the device from the ERROR state or any measurement state and return to the IDLE state.\nBUTTON0 should be used to return the device to the IDLE state from any measurement state without resetting the device (i.e., preserve all measured values that are stored in memory).\nUse timers, kernel events, work queues, threads and any other Zephyr RTOS features as needed to implement the above functionality.\nAny functionality not explicitly described above is left to your design discretion.",
    "crumbs": [
      "Labs",
      "ECG, Temperature Sensor, and BLE Lab"
    ]
  },
  {
    "objectID": "labs/ecg-temp-ble-lab.html#ble-server-mobile-app",
    "href": "labs/ecg-temp-ble-lab.html#ble-server-mobile-app",
    "title": "ECG & Temperature Sensor with BLE Lab",
    "section": "BLE Server (Mobile App)",
    "text": "BLE Server (Mobile App)\n\nYour device can connect via BLE to a mobile app called nRF Connect.\nThis app can be used to read the services and characteristics that your device is advertising.",
    "crumbs": [
      "Labs",
      "ECG, Temperature Sensor, and BLE Lab"
    ]
  },
  {
    "objectID": "labs/ecg-temp-ble-lab.html#state-diagram",
    "href": "labs/ecg-temp-ble-lab.html#state-diagram",
    "title": "ECG & Temperature Sensor with BLE Lab",
    "section": "State Diagram",
    "text": "State Diagram\n\nGenerate a detailed state diagram that all states, events and actions for your firmware.\nYou should add states, events and actions as needed to fully describe the functionality of your firmware.\n\n\n\n\nState Diagram",
    "crumbs": [
      "Labs",
      "ECG, Temperature Sensor, and BLE Lab"
    ]
  },
  {
    "objectID": "labs/ecg-temp-ble-lab.html#testing-verification",
    "href": "labs/ecg-temp-ble-lab.html#testing-verification",
    "title": "ECG & Temperature Sensor with BLE Lab",
    "section": "Testing & Verification",
    "text": "Testing & Verification\nCreate a new Jupyter notebook named final_technical_report.ipynb for your testing and verification technical report. The notebook should include the following sections:\n\nBattery Voltage Measurement\nVerify the accuracy of your battery level measurement (AIN0) for 0-3 V, as read through the nRF Connect app Bluetooth Battery Level GATT. Quantitative analysis should include:\n\nLinear regression analysis of the input voltage versus the battery level for both the LOG_INF() output, the oscilloscope measurement of the PWM duty cycle, and the nRF Connect app.\n95% confidence intervals for the slope and intercept of the linear regression.\n\n\n\nECG Heart Rate Measurement\n\nDescribe your method for calculating average heart rate from the ECG signal input. This should include any filtering, peak detection, and averaging methods used.\nDemonstrate that your average heart rate measurement is accurate, as recorded through LOG_INF() output, the oscilloscope measurements, and the nRF Connect app, relative to what was set on the function generator. This should be done for 40, 60, 120, 150, and 180 bpm. The 25% duty cycle should also be verified. Quantitative analysis should include:\n\nLinear regression analysis of the recorded heart rate versus the set heart rate for both the LOG_INF() output, oscilloscope measurements, and the nRF Connect app.\n95% confidence intervals for the slope and intercept of the linear regression.\nVerification that the duty cycle of out output is 25% for all heart rates.\n\n\n\n\nTemperature Sensor Measurment\n\nDemonstrate that your temperature sensor can have a room temperature measurement read through LOG_INF() output and the nRF Connect app.\nDo this in 3 locations with different temperatures.\nYou do not need to verify accuracy, just a reasonable measurements with agreement.",
    "crumbs": [
      "Labs",
      "ECG, Temperature Sensor, and BLE Lab"
    ]
  },
  {
    "objectID": "labs/ecg-temp-ble-lab.html#how-to-generate-an-ecg-signal",
    "href": "labs/ecg-temp-ble-lab.html#how-to-generate-an-ecg-signal",
    "title": "ECG & Temperature Sensor with BLE Lab",
    "section": "How to Generate an ECG Signal",
    "text": "How to Generate an ECG Signal\n\nWaveStation 2012 AWG\nDigilent Waveforms Script",
    "crumbs": [
      "Labs",
      "ECG, Temperature Sensor, and BLE Lab"
    ]
  },
  {
    "objectID": "labs/ecg-temp-ble-lab.html#grading",
    "href": "labs/ecg-temp-ble-lab.html#grading",
    "title": "ECG & Temperature Sensor with BLE Lab",
    "section": "Grading",
    "text": "Grading\n\nThis final project is worth 20% of your grade. Absolutely no late submissions will be accepted.\nGit version control will be graded based on best practices.\nFirmware will be graded based on all best practices taught throughout the semester.\nCode organization and coding best practices will be graded.\nState diagram will be graded based on completeness, accuracy and ease of interpretation.\nTesting and analysis technical report will be graded based on presentation, completeness, and accuracy.",
    "crumbs": [
      "Labs",
      "ECG, Temperature Sensor, and BLE Lab"
    ]
  },
  {
    "objectID": "labs/ecg-temp-ble-lab.html#how-to-ask-for-help",
    "href": "labs/ecg-temp-ble-lab.html#how-to-ask-for-help",
    "title": "ECG & Temperature Sensor with BLE Lab",
    "section": "How to Ask for Help",
    "text": "How to Ask for Help\n\nIf you have a general / non-coding question, you should ask your TAs / Dr. Palmeri on Ed to allow any of them to respond in a timely manner.\nPush you code to your GitLab repository, ideally with your active development on a non-main branch.\nCreate an Issue in your repository.\n\nAdd as much detail as possible as to your problem, and add links to specific lines / section of code when possible.\nAssign the label “Bug” or “Question”, as appropriate.\nBe sure to specify what branch you are working on.\nAssign the Issue to one of the TAs.\nIf your TA cannot solve your Issue, they can escalate the Issue to Dr. Palmeri.\n\nYou will get a response to your Issue, and maybe a new branch of code will be pushed to help you with some example syntax that you can use git diff to visualize.",
    "crumbs": [
      "Labs",
      "ECG, Temperature Sensor, and BLE Lab"
    ]
  },
  {
    "objectID": "labs/ecg-temp-ble-lab.html#what-to-submit",
    "href": "labs/ecg-temp-ble-lab.html#what-to-submit",
    "title": "ECG & Temperature Sensor with BLE Lab",
    "section": "What to Submit",
    "text": "What to Submit\n\nMake sure that all of your branches have been merged into the main branch.\nCreate an annotated tag called v4.0.0 to mark the commit that you want to be graded.\n\nIf you fix any bugs after creating this tag, you can create another tag called v4.0.1, etc.\nYour latest tag will be the one that is graded up until the final due date/time of the project.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nYou do not need to create an Issue for this final submission.\nAll repositories will be cloned with the latest tag at the due date/time for grading. No repository commits after the due date/time will be accepted.",
    "crumbs": [
      "Labs",
      "ECG, Temperature Sensor, and BLE Lab"
    ]
  },
  {
    "objectID": "labs/ecg-temp-ble-lab.html#resources",
    "href": "labs/ecg-temp-ble-lab.html#resources",
    "title": "ECG & Temperature Sensor with BLE Lab",
    "section": "Resources",
    "text": "Resources\n\nHeart Rate Service (GATT)\n\nBLE Sample: Peripheral Heartrate\nZephyr Docs: BT Heartrate Service",
    "crumbs": [
      "Labs",
      "ECG, Temperature Sensor, and BLE Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-pwm-lab.html",
    "href": "labs/zephyr-pwm-lab.html",
    "title": "Pulse Width Modulation (PWM) Lab",
    "section": "",
    "text": "Implement a steady-state PWM output to control “intensity” over a finite dynamic range.\nImplement a time-series-modulated PWM output.",
    "crumbs": [
      "Labs",
      "Pulse Width Modulation (PWM) Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-pwm-lab.html#learning-objectives",
    "href": "labs/zephyr-pwm-lab.html#learning-objectives",
    "title": "Pulse Width Modulation (PWM) Lab",
    "section": "",
    "text": "Implement a steady-state PWM output to control “intensity” over a finite dynamic range.\nImplement a time-series-modulated PWM output.",
    "crumbs": [
      "Labs",
      "Pulse Width Modulation (PWM) Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-pwm-lab.html#git-best-practices",
    "href": "labs/zephyr-pwm-lab.html#git-best-practices",
    "title": "Pulse Width Modulation (PWM) Lab",
    "section": "Git Best Practices",
    "text": "Git Best Practices\n\nUse best practices for version control (branching, commit messages, etc.).\nDo all development on a dedicated branch that is merged into main once it is functional.\nCommits should be very specific to the changes/additions you are making to your code. This will help you and others understand what you did and why you did it.\n\nOn a given development branch, try to implement one small piece of functionality at a time, commit it, and then move on to the next piece of functionality.\n\n\n\n\n\n\n\nImportant\n\n\n\nYou do not want one, monolithic git commit right before you submit your project.",
    "crumbs": [
      "Labs",
      "Pulse Width Modulation (PWM) Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-pwm-lab.html#firmware-expectations",
    "href": "labs/zephyr-pwm-lab.html#firmware-expectations",
    "title": "Pulse Width Modulation (PWM) Lab",
    "section": "Firmware Expectations",
    "text": "Firmware Expectations\n\nAll firmware should be written using the State Machine Framework.\nChoose your states for each part as a firmware engineer would, using what you have learned so far this semester.\nTimers, work queues, callbacks, and interrupts should be used as appropriate.\nAll good coding practices developed this semester should be followed.\nUse logging to display state information and other relevant information, warnings, and errors. Debugging log messages can remain in the code, but the logging level should be submitted at the INF level.\nInclude a state diagram in your repository (state_diagram.png) using UML (state_diagram.puml) or some equivalent.\n\n\n\n\n\n\n\nTip\n\n\n\nDo all development for this lab on section-specific development branches.",
    "crumbs": [
      "Labs",
      "Pulse Width Modulation (PWM) Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-pwm-lab.html#steady-state-pwm-output",
    "href": "labs/zephyr-pwm-lab.html#steady-state-pwm-output",
    "title": "Pulse Width Modulation (PWM) Lab",
    "section": "Steady-State PWM Output",
    "text": "Steady-State PWM Output\nDo this section on a development branch called pwm-steady-state.\n\nFirmware Functional Specifications\n\n\n\n\n\n\nNote\n\n\n\nSelectively keep ADC lab functionality to help complete the tasks below, but you do not have to keep any ADC lab functionality that isn’t necessary for this lab.\n\n\n\nUsing the ADC lab functionality to read a DC voltage on AIN0, map this read DC voltage to scale the maximum brightness of LED2 using a PWM output.\n\n\n\n\n\n\n\nExample\n\n\n\n\nIf AIN0 = 0 V, then LED2 should be off (0% duty cycle).\n\nIf AIN0 = 1.5 V, then LED2 should be at 50% brightness (50% duty cycle).\nIf AIN0 = 3 V, then LED2 should be at maximum brightness (100% duty cycle).\n\n\n\n\n\nUpdate your state diagram to include the new functionality.\n\n\n\nTesting\n\nQuantify the linearity of the maximum brightness of LED2 as a function of AIN0 voltage ranging from 0-3 V.\nPresent your data and analysis in the technical report Jupyter notebook called testing/testing_pwm.ipynb.\n\n\n\n\n\n\n\nDo Things Looks Inverted?\n\n\n\nRemember that LEDs on the DK are ACTIVE_LOW.\n\n\n\n\nCommit-n-Merge Steady-State PWM\n\nMerge your completed pwm-steady-state branch into your main branch using a Merge Request on Gitlab.\nCreate an annotated tag of your main branch with all part of this lab merged in called v3.0.0.",
    "crumbs": [
      "Labs",
      "Pulse Width Modulation (PWM) Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-pwm-lab.html#sinusoidal-modulation-of-pwm-output",
    "href": "labs/zephyr-pwm-lab.html#sinusoidal-modulation-of-pwm-output",
    "title": "Pulse Width Modulation (PWM) Lab",
    "section": "Sinusoidal Modulation of PWM Output",
    "text": "Sinusoidal Modulation of PWM Output\n\n\n\n\n\n\nTip\n\n\n\nDo this section on a development branch called pwm-sinusoid, branched off of main after pwm-steady-state was merged.\n\n\n\nFirmware Functional Specifications\n\nModulate the brighness of LED3 to match sampling a 2-second, 10 Hz differential sinusoidal voltage on AIN1 and AIN2 after pressing BUTTON2.\nLED3 should have its brightness modulated with as little latency as possible with respect to the input voltage. In other words, the brightness of LED3 should follow the input sinusoid as closely as possible in time.\n\n\n\n\n\n\n\nImportant\n\n\n\nThe blocking nature of a syncronous buffered acquisition scheme is not ameable to realtime modulation of the PWM output. Consider using the aynchronous ADC sampling approach with a callback to update the PWM duty cycle after each sampling event or a timer-based, single-sample acqusition approach.\n\n\n\n\n\n\n\n\nTip\n\n\n\n\nBe cognizant of your sampling rate, PWM on-time period update rate and the PWM clock period relative to your input signal.\nThere are several ways to implement the 2-second sampling period, including using a monostable timer or counting the number of samples taken at a known sampling rate. Make a purposeful decision in how you implement this functionality.\n\n\n\n\nSet the minumum and maximum sinusoidal brightnesses to be PWM duty cycles of 0 and 100%, respectively.\nUpdate your state diagram to include the new functionality.\n\n\n\nTesting\n\nUsing the oscilloscope, concurrently measure your input sinusoidal signal (what is differentially input to AIN1 and AIN2) and the output PWM signal on LED3.\n\n\n\n\n\n\n\nTip\n\n\n\nYou will need to low pass filter your modulated PWM output to see a smooth sinusoidal output. You can do this using the LPF Math mode on the oscilloscope with an appropriate cutoff frequency (relative to the frequency of the input sinusoid) and sampling window (capturing multiple cycles of the sinusoid). Remember to also adjust the offset to match the offset of the PWM signal.\n\n\n\nOn the oscilloscope, measure:\n\nThe frequency of your low-pass-filtered PWM signal, and\nThe phase difference between the PWM sinusoid and your input signal.\nCapture a screen shot of the oscilloscope showing both signals and these two measured quantities.\n\nPresent your data and analysis in your Jupyter notebook.\nDiscuss the accuracy of your PWM frequency and the latency (phase lag) of your system and how you could improve it in the future.\n\n\n\n\n\n\n\nTip\n\n\n\nRemember that your PWM signal is inverted from the input signal when interpreting your phase lag measurement.\n\n\n\n\nCommit-n-Merge Modulated PWM\n\nMerge your completed pwm-sinusoid branch into your main branch using a Merge Request on Gitlab.\nCreate an annotated tag of your main branch with all part of this lab merged in called v3.1.0.\nCreate an Issue for your TA to review this PWM lab, assigning it the Review label.",
    "crumbs": [
      "Labs",
      "Pulse Width Modulation (PWM) Lab"
    ]
  },
  {
    "objectID": "labs/zephyr-pwm-lab.html#how-to-ask-for-help",
    "href": "labs/zephyr-pwm-lab.html#how-to-ask-for-help",
    "title": "Pulse Width Modulation (PWM) Lab",
    "section": "How to Ask for Help",
    "text": "How to Ask for Help\n\nIf you have a general / non-coding question, you should ask your TAs / Dr. Palmeri on Ed to allow any of them to respond in a timely manner.\nPush you code to your GitLab repository, ideally with your active development on a non-main branch.\nCreate an Issue in your repository.\n\nAdd as much detail as possible as to your problem, and add links to specific lines / section of code when possible.\nAssign the label “Bug” or “Question”, as appropriate.\nBe sure to specify what branch you are working on.\nAssign the Issue to one of the TAs.\nIf your TA cannot solve your Issue, they can escalate the Issue to Dr. Palmeri.\n\nYou will get a response to your Issue, and maybe a new branch of code will be pushed to help you with some example syntax that you can use git diff to visualize.",
    "crumbs": [
      "Labs",
      "Pulse Width Modulation (PWM) Lab"
    ]
  },
  {
    "objectID": "faq.html",
    "href": "faq.html",
    "title": "Frequently Asked Questions",
    "section": "",
    "text": "The MacOS can try to mount your development kit as a storage device, and this can (a) interfere with flashing the device, (b) prevent you from seeing VCOM port output, and (c) annoyingly pop up a warning dialog window saying that your storage device was not unmounted properly. To avoid this, you can do the following: https://docs.zephyrproject.org/latest/develop/flash_debug/nordic_segger.html#disabling-the-mass-storage-device-functionality\n\n\n\nWhen attempting to run nrfutil self-upgrade or other subsequent commands detailed for nrfutil, on macOS, if you encounter permission denied, navigate to the directory where you saved the nrfutil binary (via terminal) and run chmod u+x nrfutil to adjust its permissions. You can verify the effect of this by running ls -l before and after.\n\n\n\nThe nRF Command Line Tools are in the process of converting from using a legacy nrfjprog tool to nrfutil. Some of the latest versions of the command line tools on the MacOS have bugs that prevent you from running the legacy tools without root privileges. If you run into this issue, you can try downgrading your nRF Command Line Tools to an earlier version (specifically, v10.24.0).",
    "crumbs": [
      "Course Information",
      "FAQ"
    ]
  },
  {
    "objectID": "faq.html#macos-troubleshooting",
    "href": "faq.html#macos-troubleshooting",
    "title": "Frequently Asked Questions",
    "section": "",
    "text": "The MacOS can try to mount your development kit as a storage device, and this can (a) interfere with flashing the device, (b) prevent you from seeing VCOM port output, and (c) annoyingly pop up a warning dialog window saying that your storage device was not unmounted properly. To avoid this, you can do the following: https://docs.zephyrproject.org/latest/develop/flash_debug/nordic_segger.html#disabling-the-mass-storage-device-functionality\n\n\n\nWhen attempting to run nrfutil self-upgrade or other subsequent commands detailed for nrfutil, on macOS, if you encounter permission denied, navigate to the directory where you saved the nrfutil binary (via terminal) and run chmod u+x nrfutil to adjust its permissions. You can verify the effect of this by running ls -l before and after.\n\n\n\nThe nRF Command Line Tools are in the process of converting from using a legacy nrfjprog tool to nrfutil. Some of the latest versions of the command line tools on the MacOS have bugs that prevent you from running the legacy tools without root privileges. If you run into this issue, you can try downgrading your nRF Command Line Tools to an earlier version (specifically, v10.24.0).",
    "crumbs": [
      "Course Information",
      "FAQ"
    ]
  },
  {
    "objectID": "resources/technical_report.html",
    "href": "resources/technical_report.html",
    "title": "Technical Report Preparation",
    "section": "",
    "text": "Each lab exercise will have an associated technical report submitted. These reports will be prepared and submitted using Python-based Jupyter notebooks that will be included as part of your assignment git repositories.\nYou will need to be able to perform the following tasks in your Jupyter notebooks:\n\nRead CSV text data saved from an oscilloscope.\nPerform signal processing (e.g., FFT, filtering, etc.) on the data.\nPerform simple statistics (e.g., mean, standard deviation, 95% CI) on the data.\nGenerate plots\n\n\n\n\n\n\n\nTip\n\n\n\nAn example technical report can be found here.",
    "crumbs": [
      "Resources",
      "Technical Report Guidelines"
    ]
  },
  {
    "objectID": "resources/technical_report.html#technical-report-preparation",
    "href": "resources/technical_report.html#technical-report-preparation",
    "title": "Technical Report Preparation",
    "section": "",
    "text": "Each lab exercise will have an associated technical report submitted. These reports will be prepared and submitted using Python-based Jupyter notebooks that will be included as part of your assignment git repositories.\nYou will need to be able to perform the following tasks in your Jupyter notebooks:\n\nRead CSV text data saved from an oscilloscope.\nPerform signal processing (e.g., FFT, filtering, etc.) on the data.\nPerform simple statistics (e.g., mean, standard deviation, 95% CI) on the data.\nGenerate plots\n\n\n\n\n\n\n\nTip\n\n\n\nAn example technical report can be found here.",
    "crumbs": [
      "Resources",
      "Technical Report Guidelines"
    ]
  },
  {
    "objectID": "resources/technical_report.html#python-virtual-environment",
    "href": "resources/technical_report.html#python-virtual-environment",
    "title": "Technical Report Preparation",
    "section": "Python Virtual Environment",
    "text": "Python Virtual Environment\nPreparing your technical reports will require either:\n\nUsing a cloud-based Jupyter notebook platform (e.g., Google CoLab), or\nUse a local Python virtual environment on your laptop with the necessary packages installed.\n\nIf you need to install a Python environment on your laptop, then this is a good starting point: Getting Started with Python in VS Code.\nThis is a good tutorial on getting started with Jupyter notebooks in VS Code: Jupyter Notebooks in Visual Studio Code.",
    "crumbs": [
      "Resources",
      "Technical Report Guidelines"
    ]
  },
  {
    "objectID": "resources/teaching_assistant_expectations.html",
    "href": "resources/teaching_assistant_expectations.html",
    "title": "Teaching Assistant Expectations",
    "section": "",
    "text": "A teaching assistant for this class is expected to:\n\nCheck Ed Discussion for questions at least once daily.\nTriage student GitLab Issues at least once daily.\nStaff 3 lab hours each week, communicating these hours via Ed Discusison and Canvas announcements.\nHelp provide timely assignment feedback via GitLab Merge Request code reviews and Gradescope.\n\nThese responsibilities are expected to take up to 10 hours / week.\nDr. Palmeri will have a group Teams chat for “realtime” communication with all TAs and the department lab staff. A Todoist project for the course will also be shared with the teaching team to track pending tasks.\nStudents who are paid hourly must submit timecards by 5 PM on Mondays when timecards are due so that Dr. Palmeri can approve your hours in a timely manner.",
    "crumbs": [
      "Resources",
      "Teaching Assistant Expectations"
    ]
  },
  {
    "objectID": "resources/state_diagram.html",
    "href": "resources/state_diagram.html",
    "title": "State Diagrams",
    "section": "",
    "text": "We will be generating state diagrams all semester, which can be done with a variety of different software packages:\n\nPlantUML\n\nText-based diagramming tool that can be integrated into VS Code\nA bit outdated, and a tad clunky in default layouts without some “nudging”\nWhat will be used in lecture and lab assignments\n\n\n\n\n\n\n\n\nTip\n\n\n\nPlantUML uses Java, which may require you to install a Java Runtime Environment (JRE) on your laptop if you do not already have one. If you would like to avoid installing that, you can use the PlantUML Server option in the PlantUML VS Code extension settings.\n\n\n\nMermaid Markdown\n\nMarkdown-based diagramming tool that can be integrated into VS Code\nMore modern and easier to use than PlantUML\nNot as feature-rich as PlantUML\n\ndraw.io\n\nWeb-based diagramming tool that can be integrated into VS Code (Draw.io Integration)\nVery feature-rich and easy to use\nNot text-based\n\nLucidchart\n\nWeb-based diagramming tool\nVery feature-rich and easy to use\nNot text-based (less VCS friendly)\n\n\nYou can use whatever software package you prefer for this class this semester, though PlantUML will be the only software supported by Dr. Palmeri and the teaching team.",
    "crumbs": [
      "Resources",
      "State Diagram Preparation Tools"
    ]
  },
  {
    "objectID": "resources/state_diagram.html#state-diagram-software",
    "href": "resources/state_diagram.html#state-diagram-software",
    "title": "State Diagrams",
    "section": "",
    "text": "We will be generating state diagrams all semester, which can be done with a variety of different software packages:\n\nPlantUML\n\nText-based diagramming tool that can be integrated into VS Code\nA bit outdated, and a tad clunky in default layouts without some “nudging”\nWhat will be used in lecture and lab assignments\n\n\n\n\n\n\n\n\nTip\n\n\n\nPlantUML uses Java, which may require you to install a Java Runtime Environment (JRE) on your laptop if you do not already have one. If you would like to avoid installing that, you can use the PlantUML Server option in the PlantUML VS Code extension settings.\n\n\n\nMermaid Markdown\n\nMarkdown-based diagramming tool that can be integrated into VS Code\nMore modern and easier to use than PlantUML\nNot as feature-rich as PlantUML\n\ndraw.io\n\nWeb-based diagramming tool that can be integrated into VS Code (Draw.io Integration)\nVery feature-rich and easy to use\nNot text-based\n\nLucidchart\n\nWeb-based diagramming tool\nVery feature-rich and easy to use\nNot text-based (less VCS friendly)\n\n\nYou can use whatever software package you prefer for this class this semester, though PlantUML will be the only software supported by Dr. Palmeri and the teaching team.",
    "crumbs": [
      "Resources",
      "State Diagram Preparation Tools"
    ]
  },
  {
    "objectID": "slides/zephyr-vbus-slides.html#what-is-vbus",
    "href": "slides/zephyr-vbus-slides.html#what-is-vbus",
    "title": "Zephyr: VBUS Detection",
    "section": "What is VBUS?",
    "text": "What is VBUS?"
  },
  {
    "objectID": "slides/zephyr-vbus-slides.html#nrf52833-product-specification",
    "href": "slides/zephyr-vbus-slides.html#nrf52833-product-specification",
    "title": "Zephyr: VBUS Detection",
    "section": "nRF52833 Product Specification",
    "text": "nRF52833 Product Specification"
  },
  {
    "objectID": "slides/zephyr-vbus-slides.html#vbus-detection",
    "href": "slides/zephyr-vbus-slides.html#vbus-detection",
    "title": "Zephyr: VBUS Detection",
    "section": "VBUS Detection",
    "text": "VBUS Detection"
  },
  {
    "objectID": "slides/zephyr-vbus-slides.html#why-is-this-important",
    "href": "slides/zephyr-vbus-slides.html#why-is-this-important",
    "title": "Zephyr: VBUS Detection",
    "section": "Why is this important?",
    "text": "Why is this important?\n\nSafety! Shock risk\nUSB charging / power provides a physical connection to a power source.\nIEC60601 has very different safety testing requirements for “wall” powered vs. battery-powered devices."
  },
  {
    "objectID": "slides/zephyr-vbus-slides.html#firmware-implementation",
    "href": "slides/zephyr-vbus-slides.html#firmware-implementation",
    "title": "Zephyr: VBUS Detection",
    "section": "Firmware Implementation",
    "text": "Firmware Implementation\n#include &lt;nrfx_power.h&gt; // NOTE: This is not a Zephyr library!!  It is a Nordic NRFX library.\n\nbool usbregstatus = nrf_power_usbregstatus_vbusdet_get(NRF_POWER);\nif (usbregstatus) {\n    // VBUS detected\n} else {\n    // VBUS not detected\n}\n\nIf you have a battery-powered device that cannot be used while charging, could change to “charging” state that would block operation."
  },
  {
    "objectID": "slides/zephyr-vbus-slides.html#drawbacks",
    "href": "slides/zephyr-vbus-slides.html#drawbacks",
    "title": "Zephyr: VBUS Detection",
    "section": "Drawbacks",
    "text": "Drawbacks\n\nNot ideal; this is now chip-specific code.\nThis breaks the Zephyr abstraction layer; now firmware code is hardware-specific. :(\nBut… Zephyr usbc_vbus API is not implemented for the nRF52833."
  },
  {
    "objectID": "slides/zephyr-vbus-slides.html#how-to-test",
    "href": "slides/zephyr-vbus-slides.html#how-to-test",
    "title": "Zephyr: VBUS Detection",
    "section": "How to Test",
    "text": "How to Test\nYou can use the second USB port (nRF USB) on the nRF52833 DK to test this. The second USB port is connected directly to the VBUS pin on the nRF52833."
  },
  {
    "objectID": "slides/zephyr-vbus-slides.html#resources",
    "href": "slides/zephyr-vbus-slides.html#resources",
    "title": "Zephyr: VBUS Detection",
    "section": "Resources",
    "text": "Resources\n\nZephyr: USB-C VBUS"
  },
  {
    "objectID": "slides/zephyr-vbus.html#nrf52833-product-specification",
    "href": "slides/zephyr-vbus.html#nrf52833-product-specification",
    "title": "Zephyr: VBUS Detection",
    "section": "nRF52833 Product Specification",
    "text": "nRF52833 Product Specification",
    "crumbs": [
      "Learning Modules",
      "VBUS"
    ]
  },
  {
    "objectID": "slides/zephyr-vbus.html#vbus-detection",
    "href": "slides/zephyr-vbus.html#vbus-detection",
    "title": "Zephyr: VBUS Detection",
    "section": "VBUS Detection",
    "text": "VBUS Detection",
    "crumbs": [
      "Learning Modules",
      "VBUS"
    ]
  },
  {
    "objectID": "slides/zephyr-vbus.html#why-is-this-important",
    "href": "slides/zephyr-vbus.html#why-is-this-important",
    "title": "Zephyr: VBUS Detection",
    "section": "Why is this important?",
    "text": "Why is this important?\n\nSafety! Shock risk\nUSB charging / power provides a physical connection to a power source.\nIEC60601 has very different safety testing requirements for “wall” powered vs. battery-powered devices.",
    "crumbs": [
      "Learning Modules",
      "VBUS"
    ]
  },
  {
    "objectID": "slides/zephyr-vbus.html#firmware-implementation",
    "href": "slides/zephyr-vbus.html#firmware-implementation",
    "title": "Zephyr: VBUS Detection",
    "section": "Firmware Implementation",
    "text": "Firmware Implementation\n#include &lt;nrfx_power.h&gt; // NOTE: This is not a Zephyr library!!  It is a Nordic NRFX library.\n\nbool usbregstatus = nrf_power_usbregstatus_vbusdet_get(NRF_POWER);\nif (usbregstatus) {\n    // VBUS detected\n} else {\n    // VBUS not detected\n}\n\nIf you have a battery-powered device that cannot be used while charging, could change to “charging” state that would block operation.",
    "crumbs": [
      "Learning Modules",
      "VBUS"
    ]
  },
  {
    "objectID": "slides/zephyr-vbus.html#drawbacks",
    "href": "slides/zephyr-vbus.html#drawbacks",
    "title": "Zephyr: VBUS Detection",
    "section": "Drawbacks",
    "text": "Drawbacks\n\nNot ideal; this is now chip-specific code.\nThis breaks the Zephyr abstraction layer; now firmware code is hardware-specific. :(\nBut… Zephyr usbc_vbus API is not implemented for the nRF52833.",
    "crumbs": [
      "Learning Modules",
      "VBUS"
    ]
  },
  {
    "objectID": "slides/zephyr-vbus.html#how-to-test",
    "href": "slides/zephyr-vbus.html#how-to-test",
    "title": "Zephyr: VBUS Detection",
    "section": "How to Test",
    "text": "How to Test\nYou can use the second USB port (nRF USB) on the nRF52833 DK to test this. The second USB port is connected directly to the VBUS pin on the nRF52833.",
    "crumbs": [
      "Learning Modules",
      "VBUS"
    ]
  },
  {
    "objectID": "slides/zephyr-vbus.html#resources",
    "href": "slides/zephyr-vbus.html#resources",
    "title": "Zephyr: VBUS Detection",
    "section": "Resources",
    "text": "Resources\n\nZephyr: USB-C VBUS",
    "crumbs": [
      "Learning Modules",
      "VBUS"
    ]
  },
  {
    "objectID": "slides/zephyr-pwm-slides.html#overview",
    "href": "slides/zephyr-pwm-slides.html#overview",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Overview",
    "text": "Overview\n\nMost microcontrollers and SoCs do not have a native DAC.\nMuch easier to output digital HIGH or LOW signals.\nTiming and duty cycle (pulse width) of HIGH and LOW signals can be used to approximate an analog voltage.\nLPF to smooth out the PWM signal.\n\n\nsine-from-pwm"
  },
  {
    "objectID": "slides/zephyr-pwm-slides.html#pwm-signal-generation",
    "href": "slides/zephyr-pwm-slides.html#pwm-signal-generation",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "PWM Signal Generation",
    "text": "PWM Signal Generation\n\nNordic DevAcademy: PWM"
  },
  {
    "objectID": "slides/zephyr-pwm-slides.html#block-diagram",
    "href": "slides/zephyr-pwm-slides.html#block-diagram",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Block Diagram",
    "text": "Block Diagram\n\nsine-from-pwm-block-diagram"
  },
  {
    "objectID": "slides/zephyr-pwm-slides.html#common-uses",
    "href": "slides/zephyr-pwm-slides.html#common-uses",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Common Uses",
    "text": "Common Uses\n\nAdjust LED brightness\nControl motor speed\nControl servo motor direction\nAnalog output\nData encoding"
  },
  {
    "objectID": "slides/zephyr-pwm-slides.html#project-setup",
    "href": "slides/zephyr-pwm-slides.html#project-setup",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Project Setup",
    "text": "Project Setup"
  },
  {
    "objectID": "slides/zephyr-pwm-slides.html#prj.conf",
    "href": "slides/zephyr-pwm-slides.html#prj.conf",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "prj.conf",
    "text": "prj.conf\nCONFIG_PWM=y"
  },
  {
    "objectID": "slides/zephyr-pwm-slides.html#devicetree",
    "href": "slides/zephyr-pwm-slides.html#devicetree",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Devicetree",
    "text": "Devicetree\n\nThere are multiple PWM timers (controllers) on the nRF52833.\nEach PWM timer has multiple channels.\nZephyr has a “compatibility” label called pwm-leds.\n\naliases = {\n    pwm1 = &pwmch1;\n    pwm2 = &pwmch2;\n};\npwm {\n    compatible = \"pwm-leds\";\n    pwmch1: pwm_1 {\n        pwms = &lt; &pwm0 0 PWM_MSEC(1) PWM_POLARITY_NORMAL&gt;;  // 0 - channel\n        label = \"PWM_CH1\";\n    };\n    pwmch2: pwm_2 {\n        pwms = &lt; &pwm0 1 PWM_MSEC(1) PWM_POLARITY_NORMAL&gt;; // 1 - channel\n        label = \"PWM_CH2\";\n    };\n};"
  },
  {
    "objectID": "slides/zephyr-pwm-slides.html#configure-the-controllers",
    "href": "slides/zephyr-pwm-slides.html#configure-the-controllers",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Configure the controller(s)",
    "text": "Configure the controller(s)\n&pwm0 {\n    compatible = \"nordic,nrf-pwm\";\n    reg = &lt;0x4001c000 0x1000&gt;;\n    interrupts = &lt;28 NRF_DEFAULT_IRQ_PRIORITY&gt;;\n    status = \"okay\";\n    #pwm-cells = &lt;3&gt;;\n    pinctrl-0 = &lt;&pwm0_default&gt;;\n    pinctrl-1 = &lt;&pwm0_sleep&gt;;\n    pinctrl-names = \"default\", \"sleep\";\n};"
  },
  {
    "objectID": "slides/zephyr-pwm-slides.html#use-pinctrl-to-configure-io-behavior-for-non-gpio-pins.",
    "href": "slides/zephyr-pwm-slides.html#use-pinctrl-to-configure-io-behavior-for-non-gpio-pins.",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Use pinctrl to configure IO behavior for non-GPIO pins.",
    "text": "Use pinctrl to configure IO behavior for non-GPIO pins.\n&pinctrl {\n    compatible = \"nordic,nrf-pinctrl\";\n    status = \"okay\";\n    pwm0_default: pwm0_default {\n        group1 {\n            psels = &lt;NRF_PSEL(PWM_OUT0, 0, 28)&gt;, // P0.28, channel 0\n                    &lt;NRF_PSEL(PWM_OUT1, 0, 30)&gt;; // P0.30, channel 1\n            nordic,invert;\n        };\n    };\n    pwm0_sleep: pwm0_sleep {\n        group1 {\n            psels = &lt;NRF_PSEL(PWM_OUT0, 0, 28)&gt;, // P0.28, channel 0\n                    &lt;NRF_PSEL(PWM_OUT1, 0, 30)&gt;; // P0.30, channel 1\n            low-power-enable;\n        };\n    };\n};"
  },
  {
    "objectID": "slides/zephyr-pwm-slides.html#main-code",
    "href": "slides/zephyr-pwm-slides.html#main-code",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Main Code",
    "text": "Main Code\n// load in the Zephyr library\n#include &lt;zephyr/drivers/pwm.h&gt;\n\n// define structs based on DT aliases\nstatic const struct pwm_dt_spec pwm1 = PWM_DT_SPEC_GET(DT_ALIAS(pwm1));\nstatic const struct pwm_dt_spec pwm2 = PWM_DT_SPEC_GET(DT_ALIAS(pwm2));\n\n// check that the PWM controller is ready\nif (!device_is_ready(pwm1.dev))  {\n    LOG_ERR(\"PWM device %s is not ready.\", pwm1.dev-&gt;name);\n    return -1;\n}\n\n// set the PWM duty cycle (pulse length)\nerr = pwm_set_pulse_dt(&pwm1, pwm1.period/2); // 50% duty cycle (be careful with integer division)\nif (err) {\n    LOG_ERR(\"Could not set pwm1 driver.\");\n    // maybe change to an ERROR state\n}"
  },
  {
    "objectID": "slides/zephyr-pwm-slides.html#changing-pwm-duty-cycle",
    "href": "slides/zephyr-pwm-slides.html#changing-pwm-duty-cycle",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Changing PWM Duty Cycle",
    "text": "Changing PWM Duty Cycle\n\nThe pulse length (duty cycle) can be changed “on the fly”, but only changes at the next period.\nCan be done with a timer or triggered by an event or poll signal."
  },
  {
    "objectID": "slides/zephyr-pwm-slides.html#how-to-sinusoidally-module-led-brightness-using-a-pwm",
    "href": "slides/zephyr-pwm-slides.html#how-to-sinusoidally-module-led-brightness-using-a-pwm",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "How to Sinusoidally Module LED Brightness Using a PWM",
    "text": "How to Sinusoidally Module LED Brightness Using a PWM\n\nChange the duty cycle of the PWM signal at a known timing interval. Can be done with a timer, callback function run at a set interval (e.g., ADC async), etc.\nNeed to consider how often to update based on frequency content of the desired output signal.\nPWM clock frequency should be much higher than the output signal frequency.\nLPF to smooth out PWM clock frequency-based transitions."
  },
  {
    "objectID": "slides/zephyr-pwm-slides.html#lower-level-nrf-pwm-control",
    "href": "slides/zephyr-pwm-slides.html#lower-level-nrf-pwm-control",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Lower-Level nRF PWM Control",
    "text": "Lower-Level nRF PWM Control\nhttps://docs.nordicsemi.com/bundle/ps_nrf52833/page/pwm.html\n\nPWM Module"
  },
  {
    "objectID": "slides/zephyr-pwm-slides.html#resources",
    "href": "slides/zephyr-pwm-slides.html#resources",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Resources",
    "text": "Resources\n\nZephry: PWM\nPulse Width Modulation\nZephyr: Blinky Sample\nSine Wave Generation\nNordic Semiconductor: PinCtrl\nNordic DevAcademy: PWM"
  },
  {
    "objectID": "slides/zephyr-pwm.html",
    "href": "slides/zephyr-pwm.html",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "",
    "text": "Most microcontrollers and SoCs do not have a native DAC.\nMuch easier to output digital HIGH or LOW signals.\nTiming and duty cycle (pulse width) of HIGH and LOW signals can be used to approximate an analog voltage.\nLPF to smooth out the PWM signal.\n\n\n\n\nsine-from-pwm",
    "crumbs": [
      "Learning Modules",
      "Pulse Width Modulation (PWM)"
    ]
  },
  {
    "objectID": "slides/zephyr-pwm.html#overview",
    "href": "slides/zephyr-pwm.html#overview",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "",
    "text": "Most microcontrollers and SoCs do not have a native DAC.\nMuch easier to output digital HIGH or LOW signals.\nTiming and duty cycle (pulse width) of HIGH and LOW signals can be used to approximate an analog voltage.\nLPF to smooth out the PWM signal.\n\n\n\n\nsine-from-pwm",
    "crumbs": [
      "Learning Modules",
      "Pulse Width Modulation (PWM)"
    ]
  },
  {
    "objectID": "slides/zephyr-pwm.html#pwm-signal-generation",
    "href": "slides/zephyr-pwm.html#pwm-signal-generation",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "PWM Signal Generation",
    "text": "PWM Signal Generation\n\nNordic DevAcademy: PWM",
    "crumbs": [
      "Learning Modules",
      "Pulse Width Modulation (PWM)"
    ]
  },
  {
    "objectID": "slides/zephyr-pwm.html#block-diagram",
    "href": "slides/zephyr-pwm.html#block-diagram",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Block Diagram",
    "text": "Block Diagram\n\n\n\nsine-from-pwm-block-diagram",
    "crumbs": [
      "Learning Modules",
      "Pulse Width Modulation (PWM)"
    ]
  },
  {
    "objectID": "slides/zephyr-pwm.html#common-uses",
    "href": "slides/zephyr-pwm.html#common-uses",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Common Uses",
    "text": "Common Uses\n\nAdjust LED brightness\nControl motor speed\nControl servo motor direction\nAnalog output\nData encoding",
    "crumbs": [
      "Learning Modules",
      "Pulse Width Modulation (PWM)"
    ]
  },
  {
    "objectID": "slides/zephyr-pwm.html#project-setup",
    "href": "slides/zephyr-pwm.html#project-setup",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Project Setup",
    "text": "Project Setup",
    "crumbs": [
      "Learning Modules",
      "Pulse Width Modulation (PWM)"
    ]
  },
  {
    "objectID": "slides/zephyr-pwm.html#prj.conf",
    "href": "slides/zephyr-pwm.html#prj.conf",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "prj.conf",
    "text": "prj.conf\nCONFIG_PWM=y",
    "crumbs": [
      "Learning Modules",
      "Pulse Width Modulation (PWM)"
    ]
  },
  {
    "objectID": "slides/zephyr-pwm.html#devicetree",
    "href": "slides/zephyr-pwm.html#devicetree",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Devicetree",
    "text": "Devicetree\n\nThere are multiple PWM timers (controllers) on the nRF52833.\nEach PWM timer has multiple channels.\nZephyr has a “compatibility” label called pwm-leds.\n\naliases = {\n    pwm1 = &pwmch1;\n    pwm2 = &pwmch2;\n};\npwm {\n    compatible = \"pwm-leds\";\n    pwmch1: pwm_1 {\n        pwms = &lt; &pwm0 0 PWM_MSEC(1) PWM_POLARITY_NORMAL&gt;;  // 0 - channel\n        label = \"PWM_CH1\";\n    };\n    pwmch2: pwm_2 {\n        pwms = &lt; &pwm0 1 PWM_MSEC(1) PWM_POLARITY_NORMAL&gt;; // 1 - channel\n        label = \"PWM_CH2\";\n    };\n};",
    "crumbs": [
      "Learning Modules",
      "Pulse Width Modulation (PWM)"
    ]
  },
  {
    "objectID": "slides/zephyr-pwm.html#configure-the-controllers",
    "href": "slides/zephyr-pwm.html#configure-the-controllers",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Configure the controller(s)",
    "text": "Configure the controller(s)\n&pwm0 {\n    compatible = \"nordic,nrf-pwm\";\n    reg = &lt;0x4001c000 0x1000&gt;;\n    interrupts = &lt;28 NRF_DEFAULT_IRQ_PRIORITY&gt;;\n    status = \"okay\";\n    #pwm-cells = &lt;3&gt;;\n    pinctrl-0 = &lt;&pwm0_default&gt;;\n    pinctrl-1 = &lt;&pwm0_sleep&gt;;\n    pinctrl-names = \"default\", \"sleep\";\n};",
    "crumbs": [
      "Learning Modules",
      "Pulse Width Modulation (PWM)"
    ]
  },
  {
    "objectID": "slides/zephyr-pwm.html#use-pinctrl-to-configure-io-behavior-for-non-gpio-pins.",
    "href": "slides/zephyr-pwm.html#use-pinctrl-to-configure-io-behavior-for-non-gpio-pins.",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Use pinctrl to configure IO behavior for non-GPIO pins.",
    "text": "Use pinctrl to configure IO behavior for non-GPIO pins.\n&pinctrl {\n    compatible = \"nordic,nrf-pinctrl\";\n    status = \"okay\";\n    pwm0_default: pwm0_default {\n        group1 {\n            psels = &lt;NRF_PSEL(PWM_OUT0, 0, 28)&gt;, // P0.28, channel 0\n                    &lt;NRF_PSEL(PWM_OUT1, 0, 30)&gt;; // P0.30, channel 1\n            nordic,invert;\n        };\n    };\n    pwm0_sleep: pwm0_sleep {\n        group1 {\n            psels = &lt;NRF_PSEL(PWM_OUT0, 0, 28)&gt;, // P0.28, channel 0\n                    &lt;NRF_PSEL(PWM_OUT1, 0, 30)&gt;; // P0.30, channel 1\n            low-power-enable;\n        };\n    };\n};",
    "crumbs": [
      "Learning Modules",
      "Pulse Width Modulation (PWM)"
    ]
  },
  {
    "objectID": "slides/zephyr-pwm.html#main-code",
    "href": "slides/zephyr-pwm.html#main-code",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Main Code",
    "text": "Main Code\n// load in the Zephyr library\n#include &lt;zephyr/drivers/pwm.h&gt;\n\n// define structs based on DT aliases\nstatic const struct pwm_dt_spec pwm1 = PWM_DT_SPEC_GET(DT_ALIAS(pwm1));\nstatic const struct pwm_dt_spec pwm2 = PWM_DT_SPEC_GET(DT_ALIAS(pwm2));\n\n// check that the PWM controller is ready\nif (!device_is_ready(pwm1.dev))  {\n    LOG_ERR(\"PWM device %s is not ready.\", pwm1.dev-&gt;name);\n    return -1;\n}\n\n// set the PWM duty cycle (pulse length)\nerr = pwm_set_pulse_dt(&pwm1, pwm1.period/2); // 50% duty cycle (be careful with integer division)\nif (err) {\n    LOG_ERR(\"Could not set pwm1 driver.\");\n    // maybe change to an ERROR state\n}",
    "crumbs": [
      "Learning Modules",
      "Pulse Width Modulation (PWM)"
    ]
  },
  {
    "objectID": "slides/zephyr-pwm.html#changing-pwm-duty-cycle",
    "href": "slides/zephyr-pwm.html#changing-pwm-duty-cycle",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Changing PWM Duty Cycle",
    "text": "Changing PWM Duty Cycle\n\nThe pulse length (duty cycle) can be changed “on the fly”, but only changes at the next period.\nCan be done with a timer or triggered by an event or poll signal.",
    "crumbs": [
      "Learning Modules",
      "Pulse Width Modulation (PWM)"
    ]
  },
  {
    "objectID": "slides/zephyr-pwm.html#how-to-sinusoidally-module-led-brightness-using-a-pwm",
    "href": "slides/zephyr-pwm.html#how-to-sinusoidally-module-led-brightness-using-a-pwm",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "How to Sinusoidally Module LED Brightness Using a PWM",
    "text": "How to Sinusoidally Module LED Brightness Using a PWM\n\nChange the duty cycle of the PWM signal at a known timing interval. Can be done with a timer, callback function run at a set interval (e.g., ADC async), etc.\nNeed to consider how often to update based on frequency content of the desired output signal.\nPWM clock frequency should be much higher than the output signal frequency.\nLPF to smooth out PWM clock frequency-based transitions.",
    "crumbs": [
      "Learning Modules",
      "Pulse Width Modulation (PWM)"
    ]
  },
  {
    "objectID": "slides/zephyr-pwm.html#lower-level-nrf-pwm-control",
    "href": "slides/zephyr-pwm.html#lower-level-nrf-pwm-control",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Lower-Level nRF PWM Control",
    "text": "Lower-Level nRF PWM Control\nhttps://docs.nordicsemi.com/bundle/ps_nrf52833/page/pwm.html\n\n\n\nPWM Module",
    "crumbs": [
      "Learning Modules",
      "Pulse Width Modulation (PWM)"
    ]
  },
  {
    "objectID": "slides/zephyr-pwm.html#resources",
    "href": "slides/zephyr-pwm.html#resources",
    "title": "Zephyr: Pulse Width Modulation",
    "section": "Resources",
    "text": "Resources\n\nZephry: PWM\nPulse Width Modulation\nZephyr: Blinky Sample\nSine Wave Generation\nNordic Semiconductor: PinCtrl\nNordic DevAcademy: PWM",
    "crumbs": [
      "Learning Modules",
      "Pulse Width Modulation (PWM)"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#why-version-control",
    "href": "slides/git-fundamentals-slides.html#why-version-control",
    "title": "Git (Version Control) Fundamentals",
    "section": "Why Version Control?",
    "text": "Why Version Control?\n\nMaintain history of software development changes.\nMaintain multiple versions of software that are released.\nTool for code review.\nAudit trail for compliance.\nRequired for IEC 62304 (Medical Software), FDA V&V (510k clearance).\nCollaboration between multiple developers.\nGreat skill to have on a resume."
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#why-git",
    "href": "slides/git-fundamentals-slides.html#why-git",
    "title": "Git (Version Control) Fundamentals",
    "section": "Why git?",
    "text": "Why git?\n\nMost popular distributed version control system\nReplaces centralized, single-point systems (e.g., subversion)\nOpen-source\nLightweight"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#why-not-git",
    "href": "slides/git-fundamentals-slides.html#why-not-git",
    "title": "Git (Version Control) Fundamentals",
    "section": "Why not git?",
    "text": "Why not git?\n\nLearning curve non-trivial, especially for advanced usage\nDoesn’t work well with binary (non-text) data\nDoesn’t work well with large files (e.g., audio, video)"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#remotes",
    "href": "slides/git-fundamentals-slides.html#remotes",
    "title": "Git (Version Control) Fundamentals",
    "section": "Remotes",
    "text": "Remotes"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#git-collaboration",
    "href": "slides/git-fundamentals-slides.html#git-collaboration",
    "title": "Git (Version Control) Fundamentals",
    "section": "Git Collaboration",
    "text": "Git Collaboration\n\nLocal version control is very powerful, and if you are the only developer of a project and using a single computer exclusively, all that is necessary.\nBut what if you want to collaborate with others / yourself on another system? Git Remotes!"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#git-remotes",
    "href": "slides/git-fundamentals-slides.html#git-remotes",
    "title": "Git (Version Control) Fundamentals",
    "section": "Git Remotes",
    "text": "Git Remotes\n\nA remote is another location where your git repository history exists.\nRemotes can be:\n\nOn your local computer\nOn a networked computer (e.g., server)\nOn a cloud-based service (e.g., GitHub, GitLab, BitBucket)\n\nWhen starting a new git repository that will be shared (i.e., will have at least one remote), you have a few ways to start things:\n\n\nCreate a local git repository and then add a remote.\nCreate a remote git repository and then clone it to your local computer.\n:balloon: For this class, all of your assignment repositories will need to be shared via GitLab, so I will recommend you create them on GitLab first, and then clone them to your local computer."
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#creating-a-new-repository-on-gitlab",
    "href": "slides/git-fundamentals-slides.html#creating-a-new-repository-on-gitlab",
    "title": "Git (Version Control) Fundamentals",
    "section": "Creating a new repository on GitLab",
    "text": "Creating a new repository on GitLab\n\n:white_check_mark: Create a new repository on GitLab, named my_first_git_repo.\n\n:warning: Spaces are not allowed in repository names and create problems when working on the commandline, so use underscores or dashes instead.\n\n+ icon in the upper left :arrow_right: New project/repository"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#clone-a-repository",
    "href": "slides/git-fundamentals-slides.html#clone-a-repository",
    "title": "Git (Version Control) Fundamentals",
    "section": "Clone a Repository",
    "text": "Clone a Repository\n\nCloning a repository is only done the first time you want to get a copy of your remote repository on your local computer. (Future interactions with the remote repository will be done via push and pull commands.)\nYou can clone directly using the Git tools in VS Code, but I recommend you do it on the commandline so you can see what is happening.\nBelow are the steps to clone a repository.\n\nFor all of this example code, do not replicate the $; that indicates that this is a command you would enter in your Terminal or Git Bash session.\n\nPlease CHANGE THE THINGS IN ALL CAPS.\n\n\n$ cd DIRECTORY_WHERE_YOU_WANT_TO_CLONE\n$ git clone git@gitlab.oit.duke.edu:YOUR_NET_ID/my_first_git_repo.git"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#success-will-look-like",
    "href": "slides/git-fundamentals-slides.html#success-will-look-like",
    "title": "Git (Version Control) Fundamentals",
    "section": "Success will look like:",
    "text": "Success will look like:\nCloning into 'my_first_git_repo'...\nwarning: You appear to have cloned an empty repository.\n\nYou will not see that warning if you chose to have GitLab create a README.md file when you created the repository."
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#git-remotelocal-workflow",
    "href": "slides/git-fundamentals-slides.html#git-remotelocal-workflow",
    "title": "Git (Version Control) Fundamentals",
    "section": "Git Remote/Local Workflow",
    "text": "Git Remote/Local Workflow"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#initialize-a-project-directory-not-already-on-a-remote",
    "href": "slides/git-fundamentals-slides.html#initialize-a-project-directory-not-already-on-a-remote",
    "title": "Git (Version Control) Fundamentals",
    "section": "Initialize a Project Directory (not already on a remote)",
    "text": "Initialize a Project Directory (not already on a remote)\n\nMake sure you are at the root level of your desired project directory (the “main” folder of the project).\n\n$ git init\n\nA .git/ directory will be created that stores all version history\nSuccess will look like:\n\nInitialized empty Git repository in YOURPROJECTDIR/.git/"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#local-workflow",
    "href": "slides/git-fundamentals-slides.html#local-workflow",
    "title": "Git (Version Control) Fundamentals",
    "section": "Local Workflow",
    "text": "Local Workflow\nOnce you have a local git repository, either through cloning or initializing one, you can start working on your project. All of the following commands are valid when you are “inside” your project directory (root level or deeper). You can also execute all of these commands natively within VS Code (and more elegantly with GitLens within VS Code)."
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#git-status",
    "href": "slides/git-fundamentals-slides.html#git-status",
    "title": "Git (Version Control) Fundamentals",
    "section": "Git Status",
    "text": "Git Status\n$ git status \n\nFiles that are not tracked (“untracked”).\nTracked files that have been modified since last committed.\nFiles that are staged (explicitly added / removed) to be committed.\nRun git status frequently to keep track of what you are doing. VS Code will show you the status “live” in the bottom left corner of the window."
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#what-does-git-track",
    "href": "slides/git-fundamentals-slides.html#what-does-git-track",
    "title": "Git (Version Control) Fundamentals",
    "section": "What does git track?",
    "text": "What does git track?\n\ngit will only track files that you explicitly tell it to track.\nDirectories are only tracked if they contain tracked files.\nUntracked files can be added to a queue (staged) to be committed to a git history (in a separate step) using:\n\n$ git add FILENAME(S) \n\nAdding a file stages it for commit.\ngit stage is a direct alias for git add. VS Code’s GitLens will use the term “stage” instead of “add”."
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#committing-staged-files",
    "href": "slides/git-fundamentals-slides.html#committing-staged-files",
    "title": "Git (Version Control) Fundamentals",
    "section": "Committing Staged Files",
    "text": "Committing Staged Files\n\nThe following command will commit your staged files. A commit message is required, which can be entered in the editor that opens when you execute the command, or you can use the -m option to enter a one-line commit message on the commandline.\n\n$ git commit -m 'one line commit message goes between the quotes'\n\nCommitting is the process of capturing the specific state of files in the version history."
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#commit-messages",
    "href": "slides/git-fundamentals-slides.html#commit-messages",
    "title": "Git (Version Control) Fundamentals",
    "section": "Commit Messages",
    "text": "Commit Messages\n\nNeed to include a commit message that describes why you are making these changes.\nYou do not need to describe what has changed; that is done automatically by:\n\n$ git diff FILE_NAME"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#git-addcommit-shortcut",
    "href": "slides/git-fundamentals-slides.html#git-addcommit-shortcut",
    "title": "Git (Version Control) Fundamentals",
    "section": "Git Add/Commit Shortcut",
    "text": "Git Add/Commit Shortcut\n\nA common operation is editing files that are already under version control and wanting to commit all of those changed files.\nThere is a shortcut to do this quickly:\n\n$ git commit -am 'commit message'"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#git-log",
    "href": "slides/git-fundamentals-slides.html#git-log",
    "title": "Git (Version Control) Fundamentals",
    "section": "Git Log",
    "text": "Git Log\n\nYou can view a history of your commits:\n\n$ git log\n\nNote that the first line of your commit message will be displayed in the log output.\nIncludes your name and email address, as configured in .gitconfig.\nIf you setup my lg alias, you will see a “prettier” version of the output using git lg."
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#can-certain-filesdirectories-be-ignored",
    "href": "slides/git-fundamentals-slides.html#can-certain-filesdirectories-be-ignored",
    "title": "Git (Version Control) Fundamentals",
    "section": "Can certain files/directories be “ignored”?",
    "text": "Can certain files/directories be “ignored”?\n\nSometimes we will have files that we never want git to manage\nThese will always show up as Untracked if they are never added.\nWe can tell git to ignore these files/directories in a file called .gitignore.\n\nCreate this file at the root of the project.\n\nBe sure to add and commit it!\n\nCan use / at the end of the name to indicate a directory name.\nCan use * as a wildcard to any characters in the name pattern match.\nCertain types of projects will have default templates of files to ignore."
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#example-.gitignore",
    "href": "slides/git-fundamentals-slides.html#example-.gitignore",
    "title": "Git (Version Control) Fundamentals",
    "section": "Example .gitignore:",
    "text": "Example .gitignore:\n$ cat .gitignore \nbuild/*\n.idea\n.cache\n.ipynb_checkpoints\n.DS_Store\nenv/\nvenv/\n.venv/"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#live-demo",
    "href": "slides/git-fundamentals-slides.html#live-demo",
    "title": "Git (Version Control) Fundamentals",
    "section": "Live Demo",
    "text": "Live Demo\nLive demo time!"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#more-git-basics",
    "href": "slides/git-fundamentals-slides.html#more-git-basics",
    "title": "Git (Version Control) Fundamentals",
    "section": "More Git Basics",
    "text": "More Git Basics"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#how-do-a-undo-changes-to-a-file",
    "href": "slides/git-fundamentals-slides.html#how-do-a-undo-changes-to-a-file",
    "title": "Git (Version Control) Fundamentals",
    "section": "How do a undo changes to a file?",
    "text": "How do a undo changes to a file?\n\nIf you have modified a file that was already tracked and want to restore it to the previously-committed version:\n\ngit restore [file] \n\nYou can also revert to previously-committed versions older than the latest commit… but that is a more advanced topic."
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#pushingpulling-git-commits",
    "href": "slides/git-fundamentals-slides.html#pushingpulling-git-commits",
    "title": "Git (Version Control) Fundamentals",
    "section": "Pushing/Pulling Git Commits",
    "text": "Pushing/Pulling Git Commits\n\nOnce a local repository is connected to a remote, you can:\n\nPush local commits to the remote (git push)\nPull commits from the remote (git pull)\n\n\n\n\n\n\n\n\nImportant\n\n\nYou will always need to pull the latest commits from a repository before you push anything new."
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#more-advanced-git-workflows",
    "href": "slides/git-fundamentals-slides.html#more-advanced-git-workflows",
    "title": "Git (Version Control) Fundamentals",
    "section": "More Advanced Git Workflows",
    "text": "More Advanced Git Workflows"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#branching",
    "href": "slides/git-fundamentals-slides.html#branching",
    "title": "Git (Version Control) Fundamentals",
    "section": "Branching",
    "text": "Branching\n\nBy default, your project is working on a branch called main.\n\n\n\n\n\n\n\nNote\n\n\nSome older versions of git used a default name of master, but that has been deprecated.* If your configuration is still using master, please consider changing the default branch name.\n\n\n\n\nBranches allow you to add/modify files, potentially with multiple commits, but without changing the files as they exist in main.\nCommitted changes on your branch can be merged into main (or another branch) when they are “ready”."
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#steps-to-create-and-use-a-development-branch",
    "href": "slides/git-fundamentals-slides.html#steps-to-create-and-use-a-development-branch",
    "title": "Git (Version Control) Fundamentals",
    "section": "Steps to Create and Use a Development Branch",
    "text": "Steps to Create and Use a Development Branch\n$ git branch BRANCHNAME  # this creates a new branch\n$ git checkout BRANCHNAME  # this switches to the branch\n\nIf a branch already exists, you can just switch to it using git checkout.\ngit switch achieves the same behavior when swiching between branches.\n\n\n\n\n\n\n\nTip\n\n\nYou can create and checkout a branch using:\n$ git checkout -b BRANCHNAME\n \nOR\n\n$ git switch -c BRANCHNAME"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#naming-branches",
    "href": "slides/git-fundamentals-slides.html#naming-branches",
    "title": "Git (Version Control) Fundamentals",
    "section": "Naming Branches",
    "text": "Naming Branches\n\nIt is important to use good branch names! This will be helpful for you when breaking up your tasks, and knowing what you should focus on developing in the specified branch.\nThere isn’t a best practice for naming branches, but consider using the template: functionality-in-my-project.\nFor example, if you are developing a library to calculate heart rate from an ECG signal, a good branch name would be dev-calc-ecg-hr."
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#branches-on-remotes",
    "href": "slides/git-fundamentals-slides.html#branches-on-remotes",
    "title": "Git (Version Control) Fundamentals",
    "section": "Branches on Remotes",
    "text": "Branches on Remotes\n\nYou can push a branch to your remote just like you would main.\nGit may prompt you to have to create the branch on origin with the same name as the local branch:\n\n$ git push --set-upstream origin BRANCHNAME\n\nIf you want to avoid having to manually set the upstream branch, you can set a configuration option to always do that for you. You probably set this up in the first week of class in your .gitconfig file, but if not:\n\n$ git config --global push.autoSetupRemote true"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#merging-a-branch",
    "href": "slides/git-fundamentals-slides.html#merging-a-branch",
    "title": "Git (Version Control) Fundamentals",
    "section": "Merging a Branch",
    "text": "Merging a Branch\n\nOnce you are “done” developing on a branch, you can merge your changes back into your main branch (or another branch).\nMerging is also the way that you can incorporate another developer’s code into your branches.\n\n$ git checkout main  # switch to the branch you want to merge into\n$ git merge BRANCHNAME  # merge the branch into the current branch"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#merging-approaches",
    "href": "slides/git-fundamentals-slides.html#merging-approaches",
    "title": "Git (Version Control) Fundamentals",
    "section": "Merging Approaches",
    "text": "Merging Approaches\n\nMerge: Creates a commit reflecting the merged content, in addition to the individual commits on the branch being merged.\nSquash: Create a single merge commit, “squashing” all of the commits of the feature branch into one commit.\nRebase: Integrate the commits of the feature branch into your target branch by “replaying” them into the history.\n\nThis can be the trickiest approach to use and can cause major headaches if you have already pushed commits to a remote.\n\nProbably best to avoid as you get familiar with merging."
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#pullmerge-requests",
    "href": "slides/git-fundamentals-slides.html#pullmerge-requests",
    "title": "Git (Version Control) Fundamentals",
    "section": "Pull/Merge Requests",
    "text": "Pull/Merge Requests\n\nYou can also use the UI of GitHub/GitLab to merge one branch into another.\nThese “requests” can allow you to:\n\nReview the differences between the branches.\nProvide feedback to developers before merging."
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#annotated-tags",
    "href": "slides/git-fundamentals-slides.html#annotated-tags",
    "title": "Git (Version Control) Fundamentals",
    "section": "[Annotated] Tags",
    "text": "[Annotated] Tags\n\nTags are simply meaningful “names” to associate with specific git commits.\nTypically associated with some milestone / release.\nAnnotated tags are usually used to tags a semantic version number–along with a message–to a specific commit.\nExample syntax to create a tag for the current commit checked out:\n\n$ git tag -a 'v1.0.0' -m 'version of code for submission'\n\nExample syntax to create a tag for a specified commit:\n\n$ git tag -a 'v1.0.0' -m 'version of code for submission' COMMIT_HASH"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#issues",
    "href": "slides/git-fundamentals-slides.html#issues",
    "title": "Git (Version Control) Fundamentals",
    "section": "Issues",
    "text": "Issues\n\nIssues are used via the web UI to report bugs, request features, ask questions, etc.\nWe will use Issues as the primary way to ask the TAs / Dr. Palmeri questions (you will need to add collaborators explicitly to your Private projects).\nCommits related to issues can automatically trigger action (e.g., closing, fixing) using certain commit message keywords."
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#miscellaneous-topics",
    "href": "slides/git-fundamentals-slides.html#miscellaneous-topics",
    "title": "Git (Version Control) Fundamentals",
    "section": "Miscellaneous Topics",
    "text": "Miscellaneous Topics"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#add-a-remote",
    "href": "slides/git-fundamentals-slides.html#add-a-remote",
    "title": "Git (Version Control) Fundamentals",
    "section": "Add a Remote",
    "text": "Add a Remote\n\nYou can add a remote using the following syntax:\n\n$ git remote add origin git@gitlab.oit.duke.edu:YOUR_NET_ID/YOUR_PROJECT_NAME.git\n\nYou can access the URL for a remote repository after you create it online.\nThe default remote name is origin. That name is arbitrary, but widely used.\nYou can have multiple remotes associated with a repository.\nURLs that start with git@ use SSH keys to authenticate you.\nYou can see the remotes associated with your local git repository as follows:\n\n$ git remote -v\norigin  git@gitlab.oit.duke.edu:YOUR_NET_ID/YOUR_PROJECT_NAME.git (fetch)\norigin  git@gitlab.oit.duke.edu:YOUR_NET_ID/YOUR_PROJECT_NAME.git (push)"
  },
  {
    "objectID": "slides/git-fundamentals-slides.html#mac-users",
    "href": "slides/git-fundamentals-slides.html#mac-users",
    "title": "Git (Version Control) Fundamentals",
    "section": "Mac Users",
    "text": "Mac Users\nIf your Mac terminal doesn’t have tab autocompletion enabled when typing out your long branch name you created among other git commands, follow the steps from this link.\nThis will only work in your Mac terminal. If you’d like to enable this in VS Code as well, open up your preferences with Cmd + ,, and then navigate through this:\n\nUser -&gt; Extensions -&gt; Git.\nScroll down to the setting labeled Terminal Git Editor and check this box.\nYou will need to restart your existing terminal inside of VS Code if one is already open."
  },
  {
    "objectID": "slides/git-fundamentals-notes.html",
    "href": "slides/git-fundamentals-notes.html",
    "title": "Git (Version Control) Fundamentals",
    "section": "",
    "text": "Maintain history of software development changes.\nMaintain multiple versions of software that are released.\nTool for code review.\nAudit trail for compliance.\nRequired for IEC 62304 (Medical Software), FDA V&V (510k clearance).\nCollaboration between multiple developers.\nGreat skill to have on a resume.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#why-version-control",
    "href": "slides/git-fundamentals-notes.html#why-version-control",
    "title": "Git (Version Control) Fundamentals",
    "section": "",
    "text": "Maintain history of software development changes.\nMaintain multiple versions of software that are released.\nTool for code review.\nAudit trail for compliance.\nRequired for IEC 62304 (Medical Software), FDA V&V (510k clearance).\nCollaboration between multiple developers.\nGreat skill to have on a resume.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#why-git",
    "href": "slides/git-fundamentals-notes.html#why-git",
    "title": "Git (Version Control) Fundamentals",
    "section": "Why git?",
    "text": "Why git?\n\nMost popular distributed version control system\nReplaces centralized, single-point systems (e.g., subversion)\nOpen-source\nLightweight",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#why-not-git",
    "href": "slides/git-fundamentals-notes.html#why-not-git",
    "title": "Git (Version Control) Fundamentals",
    "section": "Why not git?",
    "text": "Why not git?\n\nLearning curve non-trivial, especially for advanced usage\nDoesn’t work well with binary (non-text) data\nDoesn’t work well with large files (e.g., audio, video)",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#remotes",
    "href": "slides/git-fundamentals-notes.html#remotes",
    "title": "Git (Version Control) Fundamentals",
    "section": "Remotes",
    "text": "Remotes",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#git-collaboration",
    "href": "slides/git-fundamentals-notes.html#git-collaboration",
    "title": "Git (Version Control) Fundamentals",
    "section": "Git Collaboration",
    "text": "Git Collaboration\n\nLocal version control is very powerful, and if you are the only developer of a project and using a single computer exclusively, all that is necessary.\nBut what if you want to collaborate with others / yourself on another system? Git Remotes!",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#git-remotes",
    "href": "slides/git-fundamentals-notes.html#git-remotes",
    "title": "Git (Version Control) Fundamentals",
    "section": "Git Remotes",
    "text": "Git Remotes\n\nA remote is another location where your git repository history exists.\nRemotes can be:\n\nOn your local computer\nOn a networked computer (e.g., server)\nOn a cloud-based service (e.g., GitHub, GitLab, BitBucket)\n\nWhen starting a new git repository that will be shared (i.e., will have at least one remote), you have a few ways to start things:\n\n\nCreate a local git repository and then add a remote.\nCreate a remote git repository and then clone it to your local computer.\n:balloon: For this class, all of your assignment repositories will need to be shared via GitLab, so I will recommend you create them on GitLab first, and then clone them to your local computer.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#creating-a-new-repository-on-gitlab",
    "href": "slides/git-fundamentals-notes.html#creating-a-new-repository-on-gitlab",
    "title": "Git (Version Control) Fundamentals",
    "section": "Creating a new repository on GitLab",
    "text": "Creating a new repository on GitLab\n\n:white_check_mark: Create a new repository on GitLab, named my_first_git_repo.\n\n:warning: Spaces are not allowed in repository names and create problems when working on the commandline, so use underscores or dashes instead.\n\n+ icon in the upper left :arrow_right: New project/repository\n\n\n\n\nChoose: Create Blank Project\nChoose Project Name: my_first_git_repo\n\n\n\n\n\n\n\nWarning\n\n\n\nIf this is a new repository that doesn’t already exist locally on your laptop, then you can choose to have GitLab create a README.md file; otherwise, deselect that default option.\n\n\n\n\nChoose: Create Project",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#clone-a-repository",
    "href": "slides/git-fundamentals-notes.html#clone-a-repository",
    "title": "Git (Version Control) Fundamentals",
    "section": "Clone a Repository",
    "text": "Clone a Repository\n\nCloning a repository is only done the first time you want to get a copy of your remote repository on your local computer. (Future interactions with the remote repository will be done via push and pull commands.)\nYou can clone directly using the Git tools in VS Code, but I recommend you do it on the commandline so you can see what is happening.\nBelow are the steps to clone a repository.\n\nFor all of this example code, do not replicate the $; that indicates that this is a command you would enter in your Terminal or Git Bash session.\n\nPlease CHANGE THE THINGS IN ALL CAPS.\n\n\n$ cd DIRECTORY_WHERE_YOU_WANT_TO_CLONE\n$ git clone git@gitlab.oit.duke.edu:YOUR_NET_ID/my_first_git_repo.git",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#success-will-look-like",
    "href": "slides/git-fundamentals-notes.html#success-will-look-like",
    "title": "Git (Version Control) Fundamentals",
    "section": "Success will look like:",
    "text": "Success will look like:\nCloning into 'my_first_git_repo'...\nwarning: You appear to have cloned an empty repository.\n\nYou will not see that warning if you chose to have GitLab create a README.md file when you created the repository.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#git-remotelocal-workflow",
    "href": "slides/git-fundamentals-notes.html#git-remotelocal-workflow",
    "title": "Git (Version Control) Fundamentals",
    "section": "Git Remote/Local Workflow",
    "text": "Git Remote/Local Workflow",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#initialize-a-project-directory-not-already-on-a-remote",
    "href": "slides/git-fundamentals-notes.html#initialize-a-project-directory-not-already-on-a-remote",
    "title": "Git (Version Control) Fundamentals",
    "section": "Initialize a Project Directory (not already on a remote)",
    "text": "Initialize a Project Directory (not already on a remote)\n\nMake sure you are at the root level of your desired project directory (the “main” folder of the project).\n\n$ git init\n\nA .git/ directory will be created that stores all version history\nSuccess will look like:\n\nInitialized empty Git repository in YOURPROJECTDIR/.git/",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#local-workflow",
    "href": "slides/git-fundamentals-notes.html#local-workflow",
    "title": "Git (Version Control) Fundamentals",
    "section": "Local Workflow",
    "text": "Local Workflow\nOnce you have a local git repository, either through cloning or initializing one, you can start working on your project. All of the following commands are valid when you are “inside” your project directory (root level or deeper). You can also execute all of these commands natively within VS Code (and more elegantly with GitLens within VS Code).",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#git-status",
    "href": "slides/git-fundamentals-notes.html#git-status",
    "title": "Git (Version Control) Fundamentals",
    "section": "Git Status",
    "text": "Git Status\n$ git status \n\nFiles that are not tracked (“untracked”).\nTracked files that have been modified since last committed.\nFiles that are staged (explicitly added / removed) to be committed.\nRun git status frequently to keep track of what you are doing. VS Code will show you the status “live” in the bottom left corner of the window.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#what-does-git-track",
    "href": "slides/git-fundamentals-notes.html#what-does-git-track",
    "title": "Git (Version Control) Fundamentals",
    "section": "What does git track?",
    "text": "What does git track?\n\ngit will only track files that you explicitly tell it to track.\nDirectories are only tracked if they contain tracked files.\nUntracked files can be added to a queue (staged) to be committed to a git history (in a separate step) using:\n\n$ git add FILENAME(S) \n\nAdding a file stages it for commit.\ngit stage is a direct alias for git add. VS Code’s GitLens will use the term “stage” instead of “add”.\n\n\n\nChanges made to tracked files must be explicitly added to the commit queue too.\nMultiple files can be staged together to create a commit that logically should be bundled together.\n\n\n\n\n\n\n\nWarning\n\n\n\nWhile it is valid syntax to add an entire directory as git add . or to use wildcards to add mutliple files by a common pattern using git add *_SOME_PATTERN, I recommend you explicitly add files one at a time to avoid accidentally adding files you don’t want to track.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#committing-staged-files",
    "href": "slides/git-fundamentals-notes.html#committing-staged-files",
    "title": "Git (Version Control) Fundamentals",
    "section": "Committing Staged Files",
    "text": "Committing Staged Files\n\nThe following command will commit your staged files. A commit message is required, which can be entered in the editor that opens when you execute the command, or you can use the -m option to enter a one-line commit message on the commandline.\n\n$ git commit -m 'one line commit message goes between the quotes'\n\nCommitting is the process of capturing the specific state of files in the version history.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#commit-messages",
    "href": "slides/git-fundamentals-notes.html#commit-messages",
    "title": "Git (Version Control) Fundamentals",
    "section": "Commit Messages",
    "text": "Commit Messages\n\nNeed to include a commit message that describes why you are making these changes.\nYou do not need to describe what has changed; that is done automatically by:\n\n$ git diff FILE_NAME \n\n\nHere are some examples of what a proper commit message looks like, such that when you perform a git log, you thank your past self for knowing what and when you edited.\n\n\n\n\n\n\n\n\nBad Commit Message\nGood Commit Message\n\n\n\n\nfixed issue\nFixed GND pour on my PCB to ensure DRC checks pass\n\n\nadded function\nedited arduino code to user timers instead of sleep\n\n\nboom\nif you’re right at the deadline, this one is understandable\n\n\nupdated piece\nupdated CAD render for H3 neck to be at 75deg angle",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#git-addcommit-shortcut",
    "href": "slides/git-fundamentals-notes.html#git-addcommit-shortcut",
    "title": "Git (Version Control) Fundamentals",
    "section": "Git Add/Commit Shortcut",
    "text": "Git Add/Commit Shortcut\n\nA common operation is editing files that are already under version control and wanting to commit all of those changed files.\nThere is a shortcut to do this quickly:\n\n$ git commit -am 'commit message'",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#git-log",
    "href": "slides/git-fundamentals-notes.html#git-log",
    "title": "Git (Version Control) Fundamentals",
    "section": "Git Log",
    "text": "Git Log\n\nYou can view a history of your commits:\n\n$ git log\n\nNote that the first line of your commit message will be displayed in the log output.\nIncludes your name and email address, as configured in .gitconfig.\nIf you setup my lg alias, you will see a “prettier” version of the output using git lg.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#can-certain-filesdirectories-be-ignored",
    "href": "slides/git-fundamentals-notes.html#can-certain-filesdirectories-be-ignored",
    "title": "Git (Version Control) Fundamentals",
    "section": "Can certain files/directories be “ignored”?",
    "text": "Can certain files/directories be “ignored”?\n\nSometimes we will have files that we never want git to manage\nThese will always show up as Untracked if they are never added.\nWe can tell git to ignore these files/directories in a file called .gitignore.\n\nCreate this file at the root of the project.\n\nBe sure to add and commit it!\n\nCan use / at the end of the name to indicate a directory name.\nCan use * as a wildcard to any characters in the name pattern match.\nCertain types of projects will have default templates of files to ignore.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#example-.gitignore",
    "href": "slides/git-fundamentals-notes.html#example-.gitignore",
    "title": "Git (Version Control) Fundamentals",
    "section": "Example .gitignore:",
    "text": "Example .gitignore:\n$ cat .gitignore \nbuild/*\n.idea\n.cache\n.ipynb_checkpoints\n.DS_Store\nenv/\nvenv/\n.venv/",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#live-demo",
    "href": "slides/git-fundamentals-notes.html#live-demo",
    "title": "Git (Version Control) Fundamentals",
    "section": "Live Demo",
    "text": "Live Demo\nLive demo time!",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#more-git-basics",
    "href": "slides/git-fundamentals-notes.html#more-git-basics",
    "title": "Git (Version Control) Fundamentals",
    "section": "More Git Basics",
    "text": "More Git Basics",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#how-do-a-undo-changes-to-a-file",
    "href": "slides/git-fundamentals-notes.html#how-do-a-undo-changes-to-a-file",
    "title": "Git (Version Control) Fundamentals",
    "section": "How do a undo changes to a file?",
    "text": "How do a undo changes to a file?\n\nIf you have modified a file that was already tracked and want to restore it to the previously-committed version:\n\ngit restore [file] \n\nYou can also revert to previously-committed versions older than the latest commit… but that is a more advanced topic.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#pushingpulling-git-commits",
    "href": "slides/git-fundamentals-notes.html#pushingpulling-git-commits",
    "title": "Git (Version Control) Fundamentals",
    "section": "Pushing/Pulling Git Commits",
    "text": "Pushing/Pulling Git Commits\n\nOnce a local repository is connected to a remote, you can:\n\nPush local commits to the remote (git push)\nPull commits from the remote (git pull)\n\n\n\n\n\n\n\n\nImportant\n\n\n\nYou will always need to pull the latest commits from a repository before you push anything new.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#more-advanced-git-workflows",
    "href": "slides/git-fundamentals-notes.html#more-advanced-git-workflows",
    "title": "Git (Version Control) Fundamentals",
    "section": "More Advanced Git Workflows",
    "text": "More Advanced Git Workflows",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#branching",
    "href": "slides/git-fundamentals-notes.html#branching",
    "title": "Git (Version Control) Fundamentals",
    "section": "Branching",
    "text": "Branching\n\nBy default, your project is working on a branch called main.\n\n\n\n\n\n\n\nNote\n\n\n\nSome older versions of git used a default name of master, but that has been deprecated.* If your configuration is still using master, please consider changing the default branch name.\n\n\n\nBranches allow you to add/modify files, potentially with multiple commits, but without changing the files as they exist in main.\nCommitted changes on your branch can be merged into main (or another branch) when they are “ready”.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#steps-to-create-and-use-a-development-branch",
    "href": "slides/git-fundamentals-notes.html#steps-to-create-and-use-a-development-branch",
    "title": "Git (Version Control) Fundamentals",
    "section": "Steps to Create and Use a Development Branch",
    "text": "Steps to Create and Use a Development Branch\n$ git branch BRANCHNAME  # this creates a new branch\n$ git checkout BRANCHNAME  # this switches to the branch\n\nIf a branch already exists, you can just switch to it using git checkout.\ngit switch achieves the same behavior when swiching between branches.\n\n\n\n\n\n\n\nTip\n\n\n\nYou can create and checkout a branch using:\n$ git checkout -b BRANCHNAME\n \nOR\n\n$ git switch -c BRANCHNAME",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#naming-branches",
    "href": "slides/git-fundamentals-notes.html#naming-branches",
    "title": "Git (Version Control) Fundamentals",
    "section": "Naming Branches",
    "text": "Naming Branches\n\nIt is important to use good branch names! This will be helpful for you when breaking up your tasks, and knowing what you should focus on developing in the specified branch.\nThere isn’t a best practice for naming branches, but consider using the template: functionality-in-my-project.\nFor example, if you are developing a library to calculate heart rate from an ECG signal, a good branch name would be dev-calc-ecg-hr.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#branches-on-remotes",
    "href": "slides/git-fundamentals-notes.html#branches-on-remotes",
    "title": "Git (Version Control) Fundamentals",
    "section": "Branches on Remotes",
    "text": "Branches on Remotes\n\nYou can push a branch to your remote just like you would main.\nGit may prompt you to have to create the branch on origin with the same name as the local branch:\n\n$ git push --set-upstream origin BRANCHNAME\n\nIf you want to avoid having to manually set the upstream branch, you can set a configuration option to always do that for you. You probably set this up in the first week of class in your .gitconfig file, but if not:\n\n$ git config --global push.autoSetupRemote true",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#merging-a-branch",
    "href": "slides/git-fundamentals-notes.html#merging-a-branch",
    "title": "Git (Version Control) Fundamentals",
    "section": "Merging a Branch",
    "text": "Merging a Branch\n\nOnce you are “done” developing on a branch, you can merge your changes back into your main branch (or another branch).\nMerging is also the way that you can incorporate another developer’s code into your branches.\n\n$ git checkout main  # switch to the branch you want to merge into\n$ git merge BRANCHNAME  # merge the branch into the current branch",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#merging-approaches",
    "href": "slides/git-fundamentals-notes.html#merging-approaches",
    "title": "Git (Version Control) Fundamentals",
    "section": "Merging Approaches",
    "text": "Merging Approaches\n\nMerge: Creates a commit reflecting the merged content, in addition to the individual commits on the branch being merged.\nSquash: Create a single merge commit, “squashing” all of the commits of the feature branch into one commit.\nRebase: Integrate the commits of the feature branch into your target branch by “replaying” them into the history.\n\nThis can be the trickiest approach to use and can cause major headaches if you have already pushed commits to a remote.\n\nProbably best to avoid as you get familiar with merging.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#pullmerge-requests",
    "href": "slides/git-fundamentals-notes.html#pullmerge-requests",
    "title": "Git (Version Control) Fundamentals",
    "section": "Pull/Merge Requests",
    "text": "Pull/Merge Requests\n\nYou can also use the UI of GitHub/GitLab to merge one branch into another.\nThese “requests” can allow you to:\n\nReview the differences between the branches.\nProvide feedback to developers before merging.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#annotated-tags",
    "href": "slides/git-fundamentals-notes.html#annotated-tags",
    "title": "Git (Version Control) Fundamentals",
    "section": "[Annotated] Tags",
    "text": "[Annotated] Tags\n\nTags are simply meaningful “names” to associate with specific git commits.\nTypically associated with some milestone / release.\nAnnotated tags are usually used to tags a semantic version number–along with a message–to a specific commit.\nExample syntax to create a tag for the current commit checked out:\n\n$ git tag -a 'v1.0.0' -m 'version of code for submission'\n\nExample syntax to create a tag for a specified commit:\n\n$ git tag -a 'v1.0.0' -m 'version of code for submission' COMMIT_HASH\n\n\nLocally-created tags have to be specifically pushed to remotes using:\n\n$ git push --tags\n\nYou can see what tags exist locally using:\n\n$ git tag --list\n\nTags are available via the GitLab/GitHub web UI (and can be used to create Releases).",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#issues",
    "href": "slides/git-fundamentals-notes.html#issues",
    "title": "Git (Version Control) Fundamentals",
    "section": "Issues",
    "text": "Issues\n\nIssues are used via the web UI to report bugs, request features, ask questions, etc.\nWe will use Issues as the primary way to ask the TAs / Dr. Palmeri questions (you will need to add collaborators explicitly to your Private projects).\nCommits related to issues can automatically trigger action (e.g., closing, fixing) using certain commit message keywords.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#miscellaneous-topics",
    "href": "slides/git-fundamentals-notes.html#miscellaneous-topics",
    "title": "Git (Version Control) Fundamentals",
    "section": "Miscellaneous Topics",
    "text": "Miscellaneous Topics",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#add-a-remote",
    "href": "slides/git-fundamentals-notes.html#add-a-remote",
    "title": "Git (Version Control) Fundamentals",
    "section": "Add a Remote",
    "text": "Add a Remote\n\nYou can add a remote using the following syntax:\n\n$ git remote add origin git@gitlab.oit.duke.edu:YOUR_NET_ID/YOUR_PROJECT_NAME.git\n\nYou can access the URL for a remote repository after you create it online.\nThe default remote name is origin. That name is arbitrary, but widely used.\nYou can have multiple remotes associated with a repository.\nURLs that start with git@ use SSH keys to authenticate you.\nYou can see the remotes associated with your local git repository as follows:\n\n$ git remote -v\norigin  git@gitlab.oit.duke.edu:YOUR_NET_ID/YOUR_PROJECT_NAME.git (fetch)\norigin  git@gitlab.oit.duke.edu:YOUR_NET_ID/YOUR_PROJECT_NAME.git (push)",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/git-fundamentals-notes.html#mac-users",
    "href": "slides/git-fundamentals-notes.html#mac-users",
    "title": "Git (Version Control) Fundamentals",
    "section": "Mac Users",
    "text": "Mac Users\nIf your Mac terminal doesn’t have tab autocompletion enabled when typing out your long branch name you created among other git commands, follow the steps from this link.\nThis will only work in your Mac terminal. If you’d like to enable this in VS Code as well, open up your preferences with Cmd + ,, and then navigate through this:\n\nUser -&gt; Extensions -&gt; Git.\nScroll down to the setting labeled Terminal Git Editor and check this box.\nYou will need to restart your existing terminal inside of VS Code if one is already open.",
    "crumbs": [
      "Learning Modules",
      "Git Fundamentals"
    ]
  },
  {
    "objectID": "slides/zephyr-ble-slides.html#what-is-bluetooth",
    "href": "slides/zephyr-ble-slides.html#what-is-bluetooth",
    "title": "Bluetooth Low Energy",
    "section": "What is Bluetooth?",
    "text": "What is Bluetooth?\n\nBluetooth Low Energy (BLE) is a wireless serial communication protocol.\nPart of BT 4.0 core; very distinct from previous version of BT.\nStandardized via the BT Special Interest Group (SIG)\n“Only” ubiquitous communication protocol between device:OS (iOS, Android, OS X, Windows, Linux)\nDesigned for technology in smart homes, health, sport and fitness.\n“Low energy” - months/years of power on single battery (e.g., CR2032)\nSmall size & low cost"
  },
  {
    "objectID": "slides/zephyr-ble-slides.html#generic-access-profile-gap",
    "href": "slides/zephyr-ble-slides.html#generic-access-profile-gap",
    "title": "Bluetooth Low Energy",
    "section": "Generic Access Profile (GAP)",
    "text": "Generic Access Profile (GAP)\n\nPeripheral Device: more resource-constrained (power, size, horsepower) device\nCentral Device: more resource-equipped device that will do most processing and data storage"
  },
  {
    "objectID": "slides/zephyr-ble-slides.html#device-advertising",
    "href": "slides/zephyr-ble-slides.html#device-advertising",
    "title": "Bluetooth Low Energy",
    "section": "Device Advertising",
    "text": "Device Advertising\n\n31 bytes of data\nCan configure advertising interval (frequency proportional to energy consumption)\nOptional: Scan Response Request\n\n\n\nOnce a connection is established, advertising ceases and GATT operations take over."
  },
  {
    "objectID": "slides/zephyr-ble-slides.html#broadcast-topology",
    "href": "slides/zephyr-ble-slides.html#broadcast-topology",
    "title": "Bluetooth Low Energy",
    "section": "Broadcast Topology",
    "text": "Broadcast Topology"
  },
  {
    "objectID": "slides/zephyr-ble-slides.html#mesh-profiles",
    "href": "slides/zephyr-ble-slides.html#mesh-profiles",
    "title": "Bluetooth Low Energy",
    "section": "Mesh Profiles",
    "text": "Mesh Profiles\n\nBLE peripherals can communicate with one another to pass information to other devices (that might otherwise be out of range).\nCommon example: lights in a building\nZephyr has its own standard protocol: https://launchstudio.bluetooth.com/ListingDetails/95153"
  },
  {
    "objectID": "slides/zephyr-ble-slides.html#generic-attribute-gatt-profiles",
    "href": "slides/zephyr-ble-slides.html#generic-attribute-gatt-profiles",
    "title": "Bluetooth Low Energy",
    "section": "Generic Attribute (GATT) Profiles",
    "text": "Generic Attribute (GATT) Profiles\n\nAPI used by all BLE devices.\nClient: initiates GATT commands/requests & accepts responses (e.g., smartphone)\nServer: receives GATT commands/requests & returns responses (e.g., wearable sensor)\nCharacteristic: Data value communicated between client/server\nService: Collection of related characteristics (similar to a structure or class/object)\nDescriptor: optional characteristic metadata (e.g., value units)"
  },
  {
    "objectID": "slides/zephyr-ble-slides.html#gatt-profiles",
    "href": "slides/zephyr-ble-slides.html#gatt-profiles",
    "title": "Bluetooth Low Energy",
    "section": "GATT Profiles",
    "text": "GATT Profiles"
  },
  {
    "objectID": "slides/zephyr-ble-slides.html#universally-unique-identifier-uuid",
    "href": "slides/zephyr-ble-slides.html#universally-unique-identifier-uuid",
    "title": "Bluetooth Low Energy",
    "section": "Universally Unique Identifier (UUID)",
    "text": "Universally Unique Identifier (UUID)\n\nIdentifiers are used to identify all attributes.\n\nServices\nCharacteristics\nDescriptors\n\nUUIDs are specified by the BT SIG. They are 128-bits, but 16- or 32- bits represent the unique information.\nCan be used to encode information, such as manufacturer, project ID, firmware revision, etc."
  },
  {
    "objectID": "slides/zephyr-ble-slides.html#generating-uuids",
    "href": "slides/zephyr-ble-slides.html#generating-uuids",
    "title": "Bluetooth Low Energy",
    "section": "Generating UUIDs",
    "text": "Generating UUIDs\nOnline generators exist to create valid UUIDs: https://www.uuidgenerator.net/\n\nExample: b562bf0c-0039-418e-9756-8b271b33d5be\nThe “base” UUID can be set for a device and then incremented for custom services not in the standard GATT."
  },
  {
    "objectID": "slides/zephyr-ble-slides.html#gatt-workflow",
    "href": "slides/zephyr-ble-slides.html#gatt-workflow",
    "title": "Bluetooth Low Energy",
    "section": "GATT Workflow",
    "text": "GATT Workflow\n\nUUIDs can be discovered or explicitly found.\nService characteristics can be discovered.\nData can be read (server -&gt; client) using either a UUID or handle (similar to an “alias”).\nData can be written to the server using the handle (with or without response).\nData streams are limited / dictated by the Maximum Transfer Unit (MTU), which can be extended, but with tradeoffs."
  },
  {
    "objectID": "slides/zephyr-ble-slides.html#notifications",
    "href": "slides/zephyr-ble-slides.html#notifications",
    "title": "Bluetooth Low Energy",
    "section": "Notifications",
    "text": "Notifications\n\nA notification can be sent by the server when a characteristic is available for the client (e.g., data stored in the characteristic has been updated). The client is responsible for then reading the characteristic.\nNotifications avoid the client having to periodically read a characteristic to determine if a value has been updated or is available.\nNotifications are similar to an ISR for the client to know to send a read request to the server.\nAn indication is a notification that requires a response from the client."
  },
  {
    "objectID": "slides/zephyr-ble-slides.html#firmware-implementation",
    "href": "slides/zephyr-ble-slides.html#firmware-implementation",
    "title": "Bluetooth Low Energy",
    "section": "Firmware Implementation",
    "text": "Firmware Implementation\nThe following library is used as a skeleton for BLE communication in your final project:\n\n\nble-lib.h\nble-lib.c"
  },
  {
    "objectID": "slides/zephyr-ble-slides.html#resources",
    "href": "slides/zephyr-ble-slides.html#resources",
    "title": "Bluetooth Low Energy",
    "section": "Resources",
    "text": "Resources\n\nAdafruit: introduction to Bluetooth Low Energy\nWikipedia: BLE\nBLE: Mesh Networking\nZephyr: Battery Service (BAS)\nNordic DevAcademy BLE Fundamentals"
  },
  {
    "objectID": "slides/zephyr-ble.html",
    "href": "slides/zephyr-ble.html",
    "title": "Bluetooth Low Energy",
    "section": "",
    "text": "Bluetooth Low Energy (BLE) is a wireless serial communication protocol.\nPart of BT 4.0 core; very distinct from previous version of BT.\nStandardized via the BT Special Interest Group (SIG)\n“Only” ubiquitous communication protocol between device:OS (iOS, Android, OS X, Windows, Linux)\nDesigned for technology in smart homes, health, sport and fitness.\n“Low energy” - months/years of power on single battery (e.g., CR2032)\nSmall size & low cost",
    "crumbs": [
      "Learning Modules",
      "Bluetooth Low Energy (BLE)"
    ]
  },
  {
    "objectID": "slides/zephyr-ble.html#what-is-bluetooth",
    "href": "slides/zephyr-ble.html#what-is-bluetooth",
    "title": "Bluetooth Low Energy",
    "section": "",
    "text": "Bluetooth Low Energy (BLE) is a wireless serial communication protocol.\nPart of BT 4.0 core; very distinct from previous version of BT.\nStandardized via the BT Special Interest Group (SIG)\n“Only” ubiquitous communication protocol between device:OS (iOS, Android, OS X, Windows, Linux)\nDesigned for technology in smart homes, health, sport and fitness.\n“Low energy” - months/years of power on single battery (e.g., CR2032)\nSmall size & low cost",
    "crumbs": [
      "Learning Modules",
      "Bluetooth Low Energy (BLE)"
    ]
  },
  {
    "objectID": "slides/zephyr-ble.html#generic-access-profile-gap",
    "href": "slides/zephyr-ble.html#generic-access-profile-gap",
    "title": "Bluetooth Low Energy",
    "section": "Generic Access Profile (GAP)",
    "text": "Generic Access Profile (GAP)\n\nPeripheral Device: more resource-constrained (power, size, horsepower) device\nCentral Device: more resource-equipped device that will do most processing and data storage",
    "crumbs": [
      "Learning Modules",
      "Bluetooth Low Energy (BLE)"
    ]
  },
  {
    "objectID": "slides/zephyr-ble.html#device-advertising",
    "href": "slides/zephyr-ble.html#device-advertising",
    "title": "Bluetooth Low Energy",
    "section": "Device Advertising",
    "text": "Device Advertising\n\n31 bytes of data\nCan configure advertising interval (frequency proportional to energy consumption)\nOptional: Scan Response Request\n\n\n\nOnce a connection is established, advertising ceases and GATT operations take over.",
    "crumbs": [
      "Learning Modules",
      "Bluetooth Low Energy (BLE)"
    ]
  },
  {
    "objectID": "slides/zephyr-ble.html#broadcast-topology",
    "href": "slides/zephyr-ble.html#broadcast-topology",
    "title": "Bluetooth Low Energy",
    "section": "Broadcast Topology",
    "text": "Broadcast Topology",
    "crumbs": [
      "Learning Modules",
      "Bluetooth Low Energy (BLE)"
    ]
  },
  {
    "objectID": "slides/zephyr-ble.html#mesh-profiles",
    "href": "slides/zephyr-ble.html#mesh-profiles",
    "title": "Bluetooth Low Energy",
    "section": "Mesh Profiles",
    "text": "Mesh Profiles\n\nBLE peripherals can communicate with one another to pass information to other devices (that might otherwise be out of range).\nCommon example: lights in a building\nZephyr has its own standard protocol: https://launchstudio.bluetooth.com/ListingDetails/95153",
    "crumbs": [
      "Learning Modules",
      "Bluetooth Low Energy (BLE)"
    ]
  },
  {
    "objectID": "slides/zephyr-ble.html#generic-attribute-gatt-profiles",
    "href": "slides/zephyr-ble.html#generic-attribute-gatt-profiles",
    "title": "Bluetooth Low Energy",
    "section": "Generic Attribute (GATT) Profiles",
    "text": "Generic Attribute (GATT) Profiles\n\nAPI used by all BLE devices.\nClient: initiates GATT commands/requests & accepts responses (e.g., smartphone)\nServer: receives GATT commands/requests & returns responses (e.g., wearable sensor)\nCharacteristic: Data value communicated between client/server\nService: Collection of related characteristics (similar to a structure or class/object)\nDescriptor: optional characteristic metadata (e.g., value units)",
    "crumbs": [
      "Learning Modules",
      "Bluetooth Low Energy (BLE)"
    ]
  },
  {
    "objectID": "slides/zephyr-ble.html#gatt-profiles",
    "href": "slides/zephyr-ble.html#gatt-profiles",
    "title": "Bluetooth Low Energy",
    "section": "GATT Profiles",
    "text": "GATT Profiles",
    "crumbs": [
      "Learning Modules",
      "Bluetooth Low Energy (BLE)"
    ]
  },
  {
    "objectID": "slides/zephyr-ble.html#universally-unique-identifier-uuid",
    "href": "slides/zephyr-ble.html#universally-unique-identifier-uuid",
    "title": "Bluetooth Low Energy",
    "section": "Universally Unique Identifier (UUID)",
    "text": "Universally Unique Identifier (UUID)\n\nIdentifiers are used to identify all attributes.\n\nServices\nCharacteristics\nDescriptors\n\nUUIDs are specified by the BT SIG. They are 128-bits, but 16- or 32- bits represent the unique information.\nCan be used to encode information, such as manufacturer, project ID, firmware revision, etc.",
    "crumbs": [
      "Learning Modules",
      "Bluetooth Low Energy (BLE)"
    ]
  },
  {
    "objectID": "slides/zephyr-ble.html#generating-uuids",
    "href": "slides/zephyr-ble.html#generating-uuids",
    "title": "Bluetooth Low Energy",
    "section": "Generating UUIDs",
    "text": "Generating UUIDs\nOnline generators exist to create valid UUIDs: https://www.uuidgenerator.net/\n\nExample: b562bf0c-0039-418e-9756-8b271b33d5be\nThe “base” UUID can be set for a device and then incremented for custom services not in the standard GATT.",
    "crumbs": [
      "Learning Modules",
      "Bluetooth Low Energy (BLE)"
    ]
  },
  {
    "objectID": "slides/zephyr-ble.html#gatt-workflow",
    "href": "slides/zephyr-ble.html#gatt-workflow",
    "title": "Bluetooth Low Energy",
    "section": "GATT Workflow",
    "text": "GATT Workflow\n\nUUIDs can be discovered or explicitly found.\nService characteristics can be discovered.\nData can be read (server -&gt; client) using either a UUID or handle (similar to an “alias”).\nData can be written to the server using the handle (with or without response).\nData streams are limited / dictated by the Maximum Transfer Unit (MTU), which can be extended, but with tradeoffs.",
    "crumbs": [
      "Learning Modules",
      "Bluetooth Low Energy (BLE)"
    ]
  },
  {
    "objectID": "slides/zephyr-ble.html#notifications",
    "href": "slides/zephyr-ble.html#notifications",
    "title": "Bluetooth Low Energy",
    "section": "Notifications",
    "text": "Notifications\n\nA notification can be sent by the server when a characteristic is available for the client (e.g., data stored in the characteristic has been updated). The client is responsible for then reading the characteristic.\nNotifications avoid the client having to periodically read a characteristic to determine if a value has been updated or is available.\nNotifications are similar to an ISR for the client to know to send a read request to the server.\nAn indication is a notification that requires a response from the client.",
    "crumbs": [
      "Learning Modules",
      "Bluetooth Low Energy (BLE)"
    ]
  },
  {
    "objectID": "slides/zephyr-ble.html#firmware-implementation",
    "href": "slides/zephyr-ble.html#firmware-implementation",
    "title": "Bluetooth Low Energy",
    "section": "Firmware Implementation",
    "text": "Firmware Implementation\nThe following library is used as a skeleton for BLE communication in your final project:\n\n\nble-lib.h\nble-lib.c",
    "crumbs": [
      "Learning Modules",
      "Bluetooth Low Energy (BLE)"
    ]
  },
  {
    "objectID": "slides/zephyr-ble.html#resources",
    "href": "slides/zephyr-ble.html#resources",
    "title": "Bluetooth Low Energy",
    "section": "Resources",
    "text": "Resources\n\nAdafruit: introduction to Bluetooth Low Energy\nWikipedia: BLE\nBLE: Mesh Networking\nZephyr: Battery Service (BAS)\nNordic DevAcademy BLE Fundamentals",
    "crumbs": [
      "Learning Modules",
      "Bluetooth Low Energy (BLE)"
    ]
  },
  {
    "objectID": "slides/zephyr-smf-slides.html#state-machine-framework",
    "href": "slides/zephyr-smf-slides.html#state-machine-framework",
    "title": "Zephyr: State Machine Framework",
    "section": "State Machine Framework",
    "text": "State Machine Framework\n\nNested conditional logic main loops are hard to read and maintain.\nState machines are a common way to implement complex logic.\nStates have transitions that are triggered by events or conditions.\n\nStates can have entry / exit routines that are executed when the state is entered / exited.\nThe “run” status of a state is commonly referred to as the “state machine tick” and recurrently loops.\n\nState diagrams are used to visualize state machines.\nState structures are used to capture variables associated with describing the state."
  },
  {
    "objectID": "slides/zephyr-smf-slides.html#switch-case",
    "href": "slides/zephyr-smf-slides.html#switch-case",
    "title": "Zephyr: State Machine Framework",
    "section": "Switch-Case",
    "text": "Switch-Case\n\nThe simplest implementation of a state machine is a switch-case statement.\nThe switch statement is used to select the current state.\nThe case statements are used to implement the logic for each state.\n\nCases can be nested to implement sub-states.\nEnumerations can be used to give states verbose names instead of numbers.\n\nThe break statement is used to exit the switch statement.\nThe default statement is used to handle unexpected states."
  },
  {
    "objectID": "slides/zephyr-smf-slides.html#use-the-state-to-dictate-function",
    "href": "slides/zephyr-smf-slides.html#use-the-state-to-dictate-function",
    "title": "Zephyr: State Machine Framework",
    "section": "Use the State to Dictate Function",
    "text": "Use the State to Dictate Function\n\nAvoid testing for a condition in a state to figure out what to do; let being in the state dictate the function (i.e., you shouldn’t have to test for the state you are in to know what to do).\nUse entry and exit routines to handle state transitions; do not test for first or last iteration of that state.\n“Run” states can iterate in a loop until a condition is met to change the state, or can wait for an event.\nIf you find you need to timeout an event wait to allow other stuff to happen, consider using k_event_test()."
  },
  {
    "objectID": "slides/zephyr-smf-slides.html#pseudo-code",
    "href": "slides/zephyr-smf-slides.html#pseudo-code",
    "title": "Zephyr: State Machine Framework",
    "section": "Pseudo-Code",
    "text": "Pseudo-Code\nenum device_states { init, run, error_entry, error_run, error_exit };\n\nint device_state = init; // initialize state\n\n/* structure to bookkeep state variables */\nstruct device_state_vars {\n    int var1;\n    int var2;\n};\n\nwhile (1) {\n    switch (device_state) {\n        case init:\n            /* do stuff to initialize device */\n            device_state = run; // change the state\n            break;\n        case run:\n            /* run device */\n            if (condition) {\n                device_state = error;\n            }\n            break;\n        case error_entry:\n            illuminate_error_led();\n            break;\n        case error_run:\n            if (condition_to_leave_error) {\n                device_state = error_exit;\n            }\n            break\n        case error_entry:\n            turn_off_error_led();\n            device_state = run;\n            break;\n        default:\n            /* handle unexpected state */\n            break;\n    }\n}\nThe switch-case approach loses some of its elegance when there are many states and many transitions and states have entry / exit routines."
  },
  {
    "objectID": "slides/zephyr-smf-slides.html#state-machine-framework-1",
    "href": "slides/zephyr-smf-slides.html#state-machine-framework-1",
    "title": "Zephyr: State Machine Framework",
    "section": "State Machine Framework",
    "text": "State Machine Framework\nState machine implementations are so common that Zephyr provides a state machine framework."
  },
  {
    "objectID": "slides/zephyr-smf-slides.html#prj.conf",
    "href": "slides/zephyr-smf-slides.html#prj.conf",
    "title": "Zephyr: State Machine Framework",
    "section": "prj.conf",
    "text": "prj.conf\nCONFIG_SMF=y"
  },
  {
    "objectID": "slides/zephyr-smf-slides.html#main.c",
    "href": "slides/zephyr-smf-slides.html#main.c",
    "title": "Zephyr: State Machine Framework",
    "section": "main.c",
    "text": "main.c\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n#include &lt;zephyr/smf.h&gt;\n\n#define SW0_NODE        DT_ALIAS(sw0)\n\n/* List of events */\nK_EVENT_DEFINE(button_events);\n#define FREQ_UP_BTN_PRESS BIT(0)\n#define FREQ_DOWN_BTN_PRESS BIT(1)\n#define SLEEP_BTN_PRESS BIT(2)\n#define RESET_BTN_PRESS BIT(3)\n\nstatic const struct gpio_dt_spec button =\n        GPIO_DT_SPEC_GET_OR(SW0_NODE, gpios, {0});\n\nstatic struct gpio_callback button_cb_data;\n\n/* Forward declaration of state table */\nstatic const struct smf_state demo_states[];\n\n/* List of demo states */\nenum demo_state { INIT, S0, S1 };"
  },
  {
    "objectID": "slides/zephyr-smf-slides.html#smf-context-struct",
    "href": "slides/zephyr-smf-slides.html#smf-context-struct",
    "title": "Zephyr: State Machine Framework",
    "section": "SMF Context Struct",
    "text": "SMF Context Struct\n/* User defined object */\nstruct s_object {\n        /* This must be first */\n        struct smf_ctx ctx;\n\n        /* Other state specific data add here */\n} s_obj;\n\nStruct that stores information about the previous and current state.\nStores state termination value.\n\nZephyr Docs: SMF Context Struct"
  },
  {
    "objectID": "slides/zephyr-smf-slides.html#heirarchical-state-machine-example",
    "href": "slides/zephyr-smf-slides.html#heirarchical-state-machine-example",
    "title": "Zephyr: State Machine Framework",
    "section": "Heirarchical State Machine Example",
    "text": "Heirarchical State Machine Example\nIf multiple states share the same entry / exit routines, they can be grouped into a “superstate”.\nhttps://docs.zephyrproject.org/latest/services/smf/index.html#hierarchical-state-machine-example"
  },
  {
    "objectID": "slides/zephyr-smf-slides.html#when-to-use-threads-vs.-states",
    "href": "slides/zephyr-smf-slides.html#when-to-use-threads-vs.-states",
    "title": "Zephyr: State Machine Framework",
    "section": "When to Use Threads vs. States",
    "text": "When to Use Threads vs. States\n\nThe state machine is the foundation of describing the behavior of a system.\nThreads as a tool to help implement a function of the state machine that is not readily captured by an exclusive state.\nThreads add overhead and complexity to the system, making debugging more difficult.\nThreads are not readily captured in a state diagram, but are more commonly described using a sequence diagram."
  },
  {
    "objectID": "slides/zephyr-smf-slides.html#avoiding-global-variables-with-s_object-struct",
    "href": "slides/zephyr-smf-slides.html#avoiding-global-variables-with-s_object-struct",
    "title": "Zephyr: State Machine Framework",
    "section": "Avoiding Global Variables with s_object Struct",
    "text": "Avoiding Global Variables with s_object Struct\nAs you implement functionality within the SMF, you may wonder how to make a variable available in two different states — which is a good question, because a natural instinct might be to utilize a global variable, which we want to avoid.\nGenerally, you can leverage the fact that the s_object struct we create for smf_ctx (ie, state machine context) is passed to all states as a pointer and populate it with members for your own purpose. You can declare an s_object struct template in the global scope that contains anything you need to access between states. Something like:\nstruct s_object {\n    struct smf_ctx ctx; // must be first element\n    struct struct_type my_struct;\n    int16_t my_variable;\n    int16_t my_array[ARR_LENGTH];\n};\nTo be clear, this is merely defining a struct type and does not constitute creating a variable. Then, within main(), you can create an instance of this struct (that will be local to main) and populate the members with initial values — here, this example shows how to do this with a helper function:\n#define S_OBJ_SUCCESS         0\n#define S_OBJ_ERR_NULL_PTR   -1\n#define S_OBJ_ERR_BAD_CONFIG -2 // define your own error codes\n\nint8_t init_s_object(struct s_object *s) {\n    if (s == NULL) {\n        return S_OBJ_ERR_NULL_PTR;  // invalid pointer\n    }\n    s-&gt;my_variable = 0; // initial value\n    s-&gt;my_struct.member = &s-&gt;my_variable; // assign member of my_struct pointer to my_variable \n    s-&gt;my_struct.array_size = sizeof(s-&gt;my_array[0])*ARR_LENGTH;\n    if (s-&gt;my_struct.member == NULL) {\n        return S_OBJ_ERR_BAD_CONFIG;\n    }\n    return S_OBJ_SUCCESS;\n}\nAs always, utilize function returns for error handling using exit codes.\nint main(void){\n    static struct s_object s_obj; // create an instance of s_object called s_obj\n    int ret = init_s_object(&s_obj); // initialize s_obj using helper function\n    if (ret != 0) {\n        LOG_ERR(\"could not initialize s_object stuct (%d)\", ret);\n        break;\n    }\n    smf_set_initial(SMF_CTX(&s_obj), &fsm_states[INIT]);\n    for (;;) {\n        ret = smf_run_state(SMF_CTX(&s_obj));\n        if (ret != 0) {\n            LOG_ERR(\"terminating state machine (%d)\", ret);\n            break;\n        }\n    }\n    return 0;\n}\nThen, within a state:\n static void state_run(void *o){\n    struct s_object *s = (struct s_object *)o; // cast explicitly for compiler\n    (void)my_function(&s-&gt;my_variable); // pass pointer to my_variable to my_function\n    // remainder of state code\n}\nBecause the default argument for states is a generic pointer (void *o), you will need to cast the input to a pointer for the s_object struct to safely access its members. If you’re unfamiliar with the arrow operator (-&gt;), this allows you to access members of a struct via a pointer. This syntax is equivalent to (*s).member , where the . is how we would typically access a member directly (ie, not as a pointer)."
  },
  {
    "objectID": "slides/zephyr-smf-slides.html#passing-state-object-data-to-timer-handlers",
    "href": "slides/zephyr-smf-slides.html#passing-state-object-data-to-timer-handlers",
    "title": "Zephyr: State Machine Framework",
    "section": "Passing State Object Data to Timer Handlers",
    "text": "Passing State Object Data to Timer Handlers\nIn main():\nk_timer_user_data_set(&my_timer, &s_obj); // make *s_obj available to my_timer\nDocs for k_timer_user_data_set()\nWithin the timer handler:\nvoid timer_handler(struct k_timer *my_timer){\n    struct s_object *s = k_timer_user_data_get(my_timer);\n    // use s-&gt;member as needed\n}\nSo, we can make *s_obj available inside a timer handler."
  },
  {
    "objectID": "slides/zephyr-smf-slides.html#passing-state-object-data-to-work-queue-handlers",
    "href": "slides/zephyr-smf-slides.html#passing-state-object-data-to-work-queue-handlers",
    "title": "Zephyr: State Machine Framework",
    "section": "Passing State Object Data to Work Queue Handlers",
    "text": "Passing State Object Data to Work Queue Handlers\nNow, what if we want to pass the same pointer to a work queue thread and what if we want to do so from inside the above timer handler? (in the context where the timer submits work to be done).\nOne way to do this is to create a struct wrapped around struct k_work work and declare a placeholder pointer as a secondary member:\nstruct my_work {\n    struct k_work work;\n    void *s_obj_ptr;\n}; \nNote here that this just a template for a struct of this type (my_work) and does not constitute creating an instance of such a struct. We can create an instance of this wrapper struct from inside timer_handler() (or elsewhere, as needed):\nvoid timer_handler(struct k_timer *my_timer){\n    struct s_object *s = k_timer_user_data_get(my_timer); // from before\n    static struct my_work mw; // create a static instance of wrapper struct\n    mw.s_obj_ptr = s; // assign desired pointer to placeholder\n    k_work_init(&mw.work, my_work_handler); // use wrapper to init work\n    k_work_submit(&mw.work); // use wrapper to submit work\n}\nNow, within my_work_handler():\nvoid my_work_handler(struct k_work *work){\n    struct my_work *mw = CONTAINER_OF(work, struct my_work, work);\n    struct s_object *s = mw-&gt;s_obj_ptr;\n    // use s-&gt; member as needed\n}\nHere, we make use of the CONTAINER_OF macro (documentation)to obtain a pointer to the structure containing the element work, in this case my_work, the wrapper struct. From this, we can then recover a pointer to our s_object instance, s_obj, and use it as needed thereafter.\nMore generically, how can we pass a pointer to a user created thread?\nvoid my_thread(void *p1, void *p2, void *p3); // forward declaration\n\nK_THREAD_STACK_DEFINE(thread_stack, 1024);\nstruct k_thread thread_id;\nThen from main():\nint main(void){\n    static struct s_object s_obj; // create an instance of s_object called s_obj\n    int ret = init_s_object(&s_obj); // initialize s_obj using helper function\n    if (ret != 0) {\n        LOG_ERR(\"could not initialize s_object stuct (%d)\", ret);\n    }\n    k_thread_create(&thread_id, thread_stack, 1024, my_thread, \n                    &s_obj, NULL, NULL, // p1, p2, p3\n                    5, 0, K_NO_WAIT);\n    k_timer_user_data_set(&my_timer, &s_obj); // make *s_obj available to my_timer\n    smf_set_initial(SMF_CTX(&s_obj), &fsm_states[INIT]);\n    for (;;) {\n        ret = smf_run_state(SMF_CTX(&s_obj));\n        if (ret != 0) {\n            LOG_ERR(\"terminating state machine (%d)\", ret);\n        }\n    }\n    return 0;\n}\nIn the call to k_thread_create() the 5th through 7th arguments are the pointers *p1, *p2, *p3 that appear as arguments to the thread itself:\nvoid my_thread(void *p1, void *p2, void *p3) {\n    struct s_object *s = (struct s_object *)p1; // type cast generic pointer\n    while (1) {\n        // access s-&gt;members\n        // do things in thread\n    }\n}"
  },
  {
    "objectID": "slides/zephyr-smf-slides.html#resources",
    "href": "slides/zephyr-smf-slides.html#resources",
    "title": "Zephyr: State Machine Framework",
    "section": "Resources",
    "text": "Resources\n\nZephyr Docs: State Machine Framework (SMF)\nZephyr Docs: Events"
  },
  {
    "objectID": "slides/zephyr-smf.html",
    "href": "slides/zephyr-smf.html",
    "title": "Zephyr: State Machine Framework",
    "section": "",
    "text": "Nested conditional logic main loops are hard to read and maintain.\nState machines are a common way to implement complex logic.\nStates have transitions that are triggered by events or conditions.\n\nStates can have entry / exit routines that are executed when the state is entered / exited.\nThe “run” status of a state is commonly referred to as the “state machine tick” and recurrently loops.\n\nState diagrams are used to visualize state machines.\nState structures are used to capture variables associated with describing the state.",
    "crumbs": [
      "Learning Modules",
      "State Machine Framework (SMF)"
    ]
  },
  {
    "objectID": "slides/zephyr-smf.html#state-machine-framework",
    "href": "slides/zephyr-smf.html#state-machine-framework",
    "title": "Zephyr: State Machine Framework",
    "section": "",
    "text": "Nested conditional logic main loops are hard to read and maintain.\nState machines are a common way to implement complex logic.\nStates have transitions that are triggered by events or conditions.\n\nStates can have entry / exit routines that are executed when the state is entered / exited.\nThe “run” status of a state is commonly referred to as the “state machine tick” and recurrently loops.\n\nState diagrams are used to visualize state machines.\nState structures are used to capture variables associated with describing the state.",
    "crumbs": [
      "Learning Modules",
      "State Machine Framework (SMF)"
    ]
  },
  {
    "objectID": "slides/zephyr-smf.html#switch-case",
    "href": "slides/zephyr-smf.html#switch-case",
    "title": "Zephyr: State Machine Framework",
    "section": "Switch-Case",
    "text": "Switch-Case\n\nThe simplest implementation of a state machine is a switch-case statement.\nThe switch statement is used to select the current state.\nThe case statements are used to implement the logic for each state.\n\nCases can be nested to implement sub-states.\nEnumerations can be used to give states verbose names instead of numbers.\n\nThe break statement is used to exit the switch statement.\nThe default statement is used to handle unexpected states.",
    "crumbs": [
      "Learning Modules",
      "State Machine Framework (SMF)"
    ]
  },
  {
    "objectID": "slides/zephyr-smf.html#use-the-state-to-dictate-function",
    "href": "slides/zephyr-smf.html#use-the-state-to-dictate-function",
    "title": "Zephyr: State Machine Framework",
    "section": "Use the State to Dictate Function",
    "text": "Use the State to Dictate Function\n\nAvoid testing for a condition in a state to figure out what to do; let being in the state dictate the function (i.e., you shouldn’t have to test for the state you are in to know what to do).\nUse entry and exit routines to handle state transitions; do not test for first or last iteration of that state.\n“Run” states can iterate in a loop until a condition is met to change the state, or can wait for an event.\nIf you find you need to timeout an event wait to allow other stuff to happen, consider using k_event_test().",
    "crumbs": [
      "Learning Modules",
      "State Machine Framework (SMF)"
    ]
  },
  {
    "objectID": "slides/zephyr-smf.html#pseudo-code",
    "href": "slides/zephyr-smf.html#pseudo-code",
    "title": "Zephyr: State Machine Framework",
    "section": "Pseudo-Code",
    "text": "Pseudo-Code\nenum device_states { init, run, error_entry, error_run, error_exit };\n\nint device_state = init; // initialize state\n\n/* structure to bookkeep state variables */\nstruct device_state_vars {\n    int var1;\n    int var2;\n};\n\nwhile (1) {\n    switch (device_state) {\n        case init:\n            /* do stuff to initialize device */\n            device_state = run; // change the state\n            break;\n        case run:\n            /* run device */\n            if (condition) {\n                device_state = error;\n            }\n            break;\n        case error_entry:\n            illuminate_error_led();\n            break;\n        case error_run:\n            if (condition_to_leave_error) {\n                device_state = error_exit;\n            }\n            break\n        case error_entry:\n            turn_off_error_led();\n            device_state = run;\n            break;\n        default:\n            /* handle unexpected state */\n            break;\n    }\n}\nThe switch-case approach loses some of its elegance when there are many states and many transitions and states have entry / exit routines.",
    "crumbs": [
      "Learning Modules",
      "State Machine Framework (SMF)"
    ]
  },
  {
    "objectID": "slides/zephyr-smf.html#state-machine-framework-1",
    "href": "slides/zephyr-smf.html#state-machine-framework-1",
    "title": "Zephyr: State Machine Framework",
    "section": "State Machine Framework",
    "text": "State Machine Framework\nState machine implementations are so common that Zephyr provides a state machine framework.",
    "crumbs": [
      "Learning Modules",
      "State Machine Framework (SMF)"
    ]
  },
  {
    "objectID": "slides/zephyr-smf.html#prj.conf",
    "href": "slides/zephyr-smf.html#prj.conf",
    "title": "Zephyr: State Machine Framework",
    "section": "prj.conf",
    "text": "prj.conf\nCONFIG_SMF=y",
    "crumbs": [
      "Learning Modules",
      "State Machine Framework (SMF)"
    ]
  },
  {
    "objectID": "slides/zephyr-smf.html#main.c",
    "href": "slides/zephyr-smf.html#main.c",
    "title": "Zephyr: State Machine Framework",
    "section": "main.c",
    "text": "main.c\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n#include &lt;zephyr/smf.h&gt;\n\n#define SW0_NODE        DT_ALIAS(sw0)\n\n/* List of events */\nK_EVENT_DEFINE(button_events);\n#define FREQ_UP_BTN_PRESS BIT(0)\n#define FREQ_DOWN_BTN_PRESS BIT(1)\n#define SLEEP_BTN_PRESS BIT(2)\n#define RESET_BTN_PRESS BIT(3)\n\nstatic const struct gpio_dt_spec button =\n        GPIO_DT_SPEC_GET_OR(SW0_NODE, gpios, {0});\n\nstatic struct gpio_callback button_cb_data;\n\n/* Forward declaration of state table */\nstatic const struct smf_state demo_states[];\n\n/* List of demo states */\nenum demo_state { INIT, S0, S1 };",
    "crumbs": [
      "Learning Modules",
      "State Machine Framework (SMF)"
    ]
  },
  {
    "objectID": "slides/zephyr-smf.html#smf-context-struct",
    "href": "slides/zephyr-smf.html#smf-context-struct",
    "title": "Zephyr: State Machine Framework",
    "section": "SMF Context Struct",
    "text": "SMF Context Struct\n/* User defined object */\nstruct s_object {\n        /* This must be first */\n        struct smf_ctx ctx;\n\n        /* Other state specific data add here */\n} s_obj;\n\nStruct that stores information about the previous and current state.\nStores state termination value.\n\nZephyr Docs: SMF Context Struct\n\nstatic void init_run(void *o)\n{\n    int ret;\n\n    if (!gpio_is_ready_dt(&button)) {\n            printk(\"Error: button device %s is not ready\\n\",\n                    button.port-&gt;name);\n            return;\n    }\n\n    ret = gpio_pin_configure_dt(&button, GPIO_INPUT);\n    if (ret != 0) {\n            printk(\"Error %d: failed to configure %s pin %d\\n\",\n                    ret, button.port-&gt;name, button.pin);\n            return;\n    }\n\n    ret = gpio_pin_interrupt_configure_dt(&button,\n            GPIO_INT_EDGE_TO_ACTIVE);\n    if (ret != 0) {\n            printk(\"Error %d: failed to configure interrupt on %s pin %d\\n\",\n                    ret, button.port-&gt;name, button.pin);\n            return;\n    }\n\n    gpio_init_callback(&button_cb_data, button_pressed, BIT(button.pin));\n    gpio_add_callback(button.port, &button_cb_data);\n\n    smf_set_state(SMF_CTX(&s_obj), &demo_states[S0]);\n\n}\n\n/* State S0 */\nstatic void s0_entry(void *o)\n{\n        printk(\"STATE0\\n\");\n}\n\nstatic void s0_run(void *o)\n{\n        /* Change states on Button Press Event */\n        int32_t events = k_event_wait(&button_events, FREQ_UP_BTN_PRESS, true, K_FOREVER);\n        if (events & FREQ_UP_BTN_PRESS) {\n                smf_set_state(SMF_CTX(&s_obj), &demo_states[S1]);\n        }\n}\n\n/* State S1 */\nstatic void s1_entry(void *o)\n{\n        printk(\"STATE1\\n\");\n}\n\nstatic void s1_run(void *o)\n{\n        /* Change states on Button Press Event */\n        int32_t events = k_event_wait(&button_events, FREQ_DOWN_BTN_PRESS, true, K_FOREVER);\n        if (events & FREQ_DOWN_BTN_PRESS) {\n                smf_set_state(SMF_CTX(&s_obj), &demo_states[S0]);\n        }\n}\n\n/* Populate state table */\nstatic const struct smf_state demo_states[] = {\n        [INIT] = SMF_CREATE_STATE(NULL, init_run, NULL, NULL, NULL),\n        [S0] = SMF_CREATE_STATE(s0_entry, s0_run, NULL, NULL, NULL),\n        [S1] = SMF_CREATE_STATE(s1_entry, s1_run, NULL, NULL, NULL),\n};\n\nvoid button_pressed(const struct device *dev, struct gpio_callback *cb, uint32_t pins) {\n        /* Generate Button Press Event */\n        k_event_post(&button_events, FREQ_UP_BTN_PRESS);\n}\n\nint main(void)\n{\n    /* Set initial state */\n    smf_set_initial(SMF_CTX(&s_obj), &demo_states[INIT]);\n\n    /* Run the state machine */\n    while(1) {\n        /* Block until an event is detected */\n        int events = k_event_wait(button_events, EVENT_BTN_PRESS, true, K_FOREVER);\n\n        /* State machine terminates if a non-zero value is returned */\n        ret = smf_run_state(SMF_CTX(&s_obj));\n        if (ret) {\n            /* handle return code and terminate state machine */\n            smf_set_terminate(SMF_CTX(&s_obj), ret);\n            break;\n        }\n    }\n}",
    "crumbs": [
      "Learning Modules",
      "State Machine Framework (SMF)"
    ]
  },
  {
    "objectID": "slides/zephyr-smf.html#heirarchical-state-machine-example",
    "href": "slides/zephyr-smf.html#heirarchical-state-machine-example",
    "title": "Zephyr: State Machine Framework",
    "section": "Heirarchical State Machine Example",
    "text": "Heirarchical State Machine Example\nIf multiple states share the same entry / exit routines, they can be grouped into a “superstate”.\nhttps://docs.zephyrproject.org/latest/services/smf/index.html#hierarchical-state-machine-example",
    "crumbs": [
      "Learning Modules",
      "State Machine Framework (SMF)"
    ]
  },
  {
    "objectID": "slides/zephyr-smf.html#when-to-use-threads-vs.-states",
    "href": "slides/zephyr-smf.html#when-to-use-threads-vs.-states",
    "title": "Zephyr: State Machine Framework",
    "section": "When to Use Threads vs. States",
    "text": "When to Use Threads vs. States\n\nThe state machine is the foundation of describing the behavior of a system.\nThreads as a tool to help implement a function of the state machine that is not readily captured by an exclusive state.\nThreads add overhead and complexity to the system, making debugging more difficult.\nThreads are not readily captured in a state diagram, but are more commonly described using a sequence diagram.",
    "crumbs": [
      "Learning Modules",
      "State Machine Framework (SMF)"
    ]
  },
  {
    "objectID": "slides/zephyr-smf.html#avoiding-global-variables-with-s_object-struct",
    "href": "slides/zephyr-smf.html#avoiding-global-variables-with-s_object-struct",
    "title": "Zephyr: State Machine Framework",
    "section": "Avoiding Global Variables with s_object Struct",
    "text": "Avoiding Global Variables with s_object Struct\nAs you implement functionality within the SMF, you may wonder how to make a variable available in two different states — which is a good question, because a natural instinct might be to utilize a global variable, which we want to avoid.\nGenerally, you can leverage the fact that the s_object struct we create for smf_ctx (ie, state machine context) is passed to all states as a pointer and populate it with members for your own purpose. You can declare an s_object struct template in the global scope that contains anything you need to access between states. Something like:\nstruct s_object {\n    struct smf_ctx ctx; // must be first element\n    struct struct_type my_struct;\n    int16_t my_variable;\n    int16_t my_array[ARR_LENGTH];\n};\nTo be clear, this is merely defining a struct type and does not constitute creating a variable. Then, within main(), you can create an instance of this struct (that will be local to main) and populate the members with initial values — here, this example shows how to do this with a helper function:\n#define S_OBJ_SUCCESS         0\n#define S_OBJ_ERR_NULL_PTR   -1\n#define S_OBJ_ERR_BAD_CONFIG -2 // define your own error codes\n\nint8_t init_s_object(struct s_object *s) {\n    if (s == NULL) {\n        return S_OBJ_ERR_NULL_PTR;  // invalid pointer\n    }\n    s-&gt;my_variable = 0; // initial value\n    s-&gt;my_struct.member = &s-&gt;my_variable; // assign member of my_struct pointer to my_variable \n    s-&gt;my_struct.array_size = sizeof(s-&gt;my_array[0])*ARR_LENGTH;\n    if (s-&gt;my_struct.member == NULL) {\n        return S_OBJ_ERR_BAD_CONFIG;\n    }\n    return S_OBJ_SUCCESS;\n}\nAs always, utilize function returns for error handling using exit codes.\nint main(void){\n    static struct s_object s_obj; // create an instance of s_object called s_obj\n    int ret = init_s_object(&s_obj); // initialize s_obj using helper function\n    if (ret != 0) {\n        LOG_ERR(\"could not initialize s_object stuct (%d)\", ret);\n        break;\n    }\n    smf_set_initial(SMF_CTX(&s_obj), &fsm_states[INIT]);\n    for (;;) {\n        ret = smf_run_state(SMF_CTX(&s_obj));\n        if (ret != 0) {\n            LOG_ERR(\"terminating state machine (%d)\", ret);\n            break;\n        }\n    }\n    return 0;\n}\nThen, within a state:\n static void state_run(void *o){\n    struct s_object *s = (struct s_object *)o; // cast explicitly for compiler\n    (void)my_function(&s-&gt;my_variable); // pass pointer to my_variable to my_function\n    // remainder of state code\n}\nBecause the default argument for states is a generic pointer (void *o), you will need to cast the input to a pointer for the s_object struct to safely access its members. If you’re unfamiliar with the arrow operator (-&gt;), this allows you to access members of a struct via a pointer. This syntax is equivalent to (*s).member , where the . is how we would typically access a member directly (ie, not as a pointer).",
    "crumbs": [
      "Learning Modules",
      "State Machine Framework (SMF)"
    ]
  },
  {
    "objectID": "slides/zephyr-smf.html#passing-state-object-data-to-timer-handlers",
    "href": "slides/zephyr-smf.html#passing-state-object-data-to-timer-handlers",
    "title": "Zephyr: State Machine Framework",
    "section": "Passing State Object Data to Timer Handlers",
    "text": "Passing State Object Data to Timer Handlers\nIn main():\nk_timer_user_data_set(&my_timer, &s_obj); // make *s_obj available to my_timer\nDocs for k_timer_user_data_set()\nWithin the timer handler:\nvoid timer_handler(struct k_timer *my_timer){\n    struct s_object *s = k_timer_user_data_get(my_timer);\n    // use s-&gt;member as needed\n}\nSo, we can make *s_obj available inside a timer handler.",
    "crumbs": [
      "Learning Modules",
      "State Machine Framework (SMF)"
    ]
  },
  {
    "objectID": "slides/zephyr-smf.html#passing-state-object-data-to-work-queue-handlers",
    "href": "slides/zephyr-smf.html#passing-state-object-data-to-work-queue-handlers",
    "title": "Zephyr: State Machine Framework",
    "section": "Passing State Object Data to Work Queue Handlers",
    "text": "Passing State Object Data to Work Queue Handlers\nNow, what if we want to pass the same pointer to a work queue thread and what if we want to do so from inside the above timer handler? (in the context where the timer submits work to be done).\nOne way to do this is to create a struct wrapped around struct k_work work and declare a placeholder pointer as a secondary member:\nstruct my_work {\n    struct k_work work;\n    void *s_obj_ptr;\n}; \nNote here that this just a template for a struct of this type (my_work) and does not constitute creating an instance of such a struct. We can create an instance of this wrapper struct from inside timer_handler() (or elsewhere, as needed):\nvoid timer_handler(struct k_timer *my_timer){\n    struct s_object *s = k_timer_user_data_get(my_timer); // from before\n    static struct my_work mw; // create a static instance of wrapper struct\n    mw.s_obj_ptr = s; // assign desired pointer to placeholder\n    k_work_init(&mw.work, my_work_handler); // use wrapper to init work\n    k_work_submit(&mw.work); // use wrapper to submit work\n}\nNow, within my_work_handler():\nvoid my_work_handler(struct k_work *work){\n    struct my_work *mw = CONTAINER_OF(work, struct my_work, work);\n    struct s_object *s = mw-&gt;s_obj_ptr;\n    // use s-&gt; member as needed\n}\nHere, we make use of the CONTAINER_OF macro (documentation)to obtain a pointer to the structure containing the element work, in this case my_work, the wrapper struct. From this, we can then recover a pointer to our s_object instance, s_obj, and use it as needed thereafter.\nMore generically, how can we pass a pointer to a user created thread?\nvoid my_thread(void *p1, void *p2, void *p3); // forward declaration\n\nK_THREAD_STACK_DEFINE(thread_stack, 1024);\nstruct k_thread thread_id;\nThen from main():\nint main(void){\n    static struct s_object s_obj; // create an instance of s_object called s_obj\n    int ret = init_s_object(&s_obj); // initialize s_obj using helper function\n    if (ret != 0) {\n        LOG_ERR(\"could not initialize s_object stuct (%d)\", ret);\n    }\n    k_thread_create(&thread_id, thread_stack, 1024, my_thread, \n                    &s_obj, NULL, NULL, // p1, p2, p3\n                    5, 0, K_NO_WAIT);\n    k_timer_user_data_set(&my_timer, &s_obj); // make *s_obj available to my_timer\n    smf_set_initial(SMF_CTX(&s_obj), &fsm_states[INIT]);\n    for (;;) {\n        ret = smf_run_state(SMF_CTX(&s_obj));\n        if (ret != 0) {\n            LOG_ERR(\"terminating state machine (%d)\", ret);\n        }\n    }\n    return 0;\n}\nIn the call to k_thread_create() the 5th through 7th arguments are the pointers *p1, *p2, *p3 that appear as arguments to the thread itself:\nvoid my_thread(void *p1, void *p2, void *p3) {\n    struct s_object *s = (struct s_object *)p1; // type cast generic pointer\n    while (1) {\n        // access s-&gt;members\n        // do things in thread\n    }\n}",
    "crumbs": [
      "Learning Modules",
      "State Machine Framework (SMF)"
    ]
  },
  {
    "objectID": "slides/zephyr-smf.html#resources",
    "href": "slides/zephyr-smf.html#resources",
    "title": "Zephyr: State Machine Framework",
    "section": "Resources",
    "text": "Resources\n\nZephyr Docs: State Machine Framework (SMF)\nZephyr Docs: Events",
    "crumbs": [
      "Learning Modules",
      "State Machine Framework (SMF)"
    ]
  },
  {
    "objectID": "slides/zephyr-nrf52833dk-intro-slides.html#firmware-isnt-software",
    "href": "slides/zephyr-nrf52833dk-intro-slides.html#firmware-isnt-software",
    "title": "Introduction to Zephyr & Nordic SoC",
    "section": "Firmware isn’t “software”…",
    "text": "Firmware isn’t “software”…\n\nFirmware is a special kind of software that is designed to interact with hardware.\nFirmware is often written in C, but can be written in other languages.\nFirmware is highly resource constrained\nSoftware is often written in Python, Java, C++, etc.\nSoftware is often written to be run on a general-purpose computer (laptop, desktop, server, etc.), that typically is not resource constrained.\n\nUser Interface\nWeb Server\nDatabase\nData Processing / Analytics"
  },
  {
    "objectID": "slides/zephyr-nrf52833dk-intro-slides.html#what-is-zephyr",
    "href": "slides/zephyr-nrf52833dk-intro-slides.html#what-is-zephyr",
    "title": "Introduction to Zephyr & Nordic SoC",
    "section": "What is Zephyr?",
    "text": "What is Zephyr?\n\nhttps://www.zephyrproject.org/"
  },
  {
    "objectID": "slides/zephyr-nrf52833dk-intro-slides.html#why-zephyr",
    "href": "slides/zephyr-nrf52833dk-intro-slides.html#why-zephyr",
    "title": "Introduction to Zephyr & Nordic SoC",
    "section": "Why Zephyr?",
    "text": "Why Zephyr?\n\nCompletely open-source RTOS supported by the Linux Foundation\nQuickly becoming the default RTOS for many embedded device companies (e.g., Nordic Semiconductor)\n100% C-based language; CMake build system; Python-based framework (west)\nOnline community growing fast"
  },
  {
    "objectID": "slides/zephyr-nrf52833dk-intro-slides.html#c-programming-language",
    "href": "slides/zephyr-nrf52833dk-intro-slides.html#c-programming-language",
    "title": "Introduction to Zephyr & Nordic SoC",
    "section": "C Programming Language",
    "text": "C Programming Language\n\nZephyr is written in C\nCMake build system\nWest CLI tools\nWe will use an incredibly powerful Visual Studio Code IDE extension pack, nRF Connect developed by Nordic Semiconductor."
  },
  {
    "objectID": "slides/zephyr-nrf52833dk-intro-slides.html#bare-metal-vs.-rtos",
    "href": "slides/zephyr-nrf52833dk-intro-slides.html#bare-metal-vs.-rtos",
    "title": "Introduction to Zephyr & Nordic SoC",
    "section": "Bare Metal vs. RTOS",
    "text": "Bare Metal vs. RTOS\n\nBare-metal super-loop implementations\nRealtime Operating System (RTOS)\nInterupt Service Routines (ISR) / Callbacks"
  },
  {
    "objectID": "slides/zephyr-nrf52833dk-intro-slides.html#what-is-a-system-on-a-chip-soc",
    "href": "slides/zephyr-nrf52833dk-intro-slides.html#what-is-a-system-on-a-chip-soc",
    "title": "Introduction to Zephyr & Nordic SoC",
    "section": "What is a System on a Chip (SoC)?",
    "text": "What is a System on a Chip (SoC)?\n\nCPU\nMemory (RAM) - quite limited\nI/O\nStorage (non-volatile)\nRF / Communication Protocols\n\nUniversal Asynchronous Receiver-Transmitter (UART)\nInter-Integrated Circuit (I2C)\nSerial Peripheral Interface (SPI)\nBluetooth Low Energy (BLE)\n\n\nThis is in contrast to a motherboard-based personal computer, which uses additional discrete components or expansion / peripheral cards."
  },
  {
    "objectID": "slides/zephyr-nrf52833dk-intro-slides.html#nordic-nrf52833-development-kit-dk",
    "href": "slides/zephyr-nrf52833dk-intro-slides.html#nordic-nrf52833-development-kit-dk",
    "title": "Introduction to Zephyr & Nordic SoC",
    "section": "Nordic nRF52833 Development Kit (DK)",
    "text": "Nordic nRF52833 Development Kit (DK)\n\nhttps://youtu.be/KOWo9P1qdfk"
  },
  {
    "objectID": "slides/zephyr-nrf52833dk-intro.html",
    "href": "slides/zephyr-nrf52833dk-intro.html",
    "title": "Introduction to Zephyr & Nordic SoC",
    "section": "",
    "text": "Firmware is a special kind of software that is designed to interact with hardware.\nFirmware is often written in C, but can be written in other languages.\nFirmware is highly resource constrained\nSoftware is often written in Python, Java, C++, etc.\nSoftware is often written to be run on a general-purpose computer (laptop, desktop, server, etc.), that typically is not resource constrained.\n\nUser Interface\nWeb Server\nDatabase\nData Processing / Analytics",
    "crumbs": [
      "Learning Modules",
      "Introduction to Zephyr & Nordic SoCs"
    ]
  },
  {
    "objectID": "slides/zephyr-nrf52833dk-intro.html#firmware-isnt-software",
    "href": "slides/zephyr-nrf52833dk-intro.html#firmware-isnt-software",
    "title": "Introduction to Zephyr & Nordic SoC",
    "section": "",
    "text": "Firmware is a special kind of software that is designed to interact with hardware.\nFirmware is often written in C, but can be written in other languages.\nFirmware is highly resource constrained\nSoftware is often written in Python, Java, C++, etc.\nSoftware is often written to be run on a general-purpose computer (laptop, desktop, server, etc.), that typically is not resource constrained.\n\nUser Interface\nWeb Server\nDatabase\nData Processing / Analytics",
    "crumbs": [
      "Learning Modules",
      "Introduction to Zephyr & Nordic SoCs"
    ]
  },
  {
    "objectID": "slides/zephyr-nrf52833dk-intro.html#what-is-zephyr",
    "href": "slides/zephyr-nrf52833dk-intro.html#what-is-zephyr",
    "title": "Introduction to Zephyr & Nordic SoC",
    "section": "What is Zephyr?",
    "text": "What is Zephyr?\n\n\n\n\n\nhttps://www.zephyrproject.org/",
    "crumbs": [
      "Learning Modules",
      "Introduction to Zephyr & Nordic SoCs"
    ]
  },
  {
    "objectID": "slides/zephyr-nrf52833dk-intro.html#why-zephyr",
    "href": "slides/zephyr-nrf52833dk-intro.html#why-zephyr",
    "title": "Introduction to Zephyr & Nordic SoC",
    "section": "Why Zephyr?",
    "text": "Why Zephyr?\n\nCompletely open-source RTOS supported by the Linux Foundation\nQuickly becoming the default RTOS for many embedded device companies (e.g., Nordic Semiconductor)\n100% C-based language; CMake build system; Python-based framework (west)\nOnline community growing fast",
    "crumbs": [
      "Learning Modules",
      "Introduction to Zephyr & Nordic SoCs"
    ]
  },
  {
    "objectID": "slides/zephyr-nrf52833dk-intro.html#c-programming-language",
    "href": "slides/zephyr-nrf52833dk-intro.html#c-programming-language",
    "title": "Introduction to Zephyr & Nordic SoC",
    "section": "C Programming Language",
    "text": "C Programming Language\n\nZephyr is written in C\nCMake build system\nWest CLI tools\nWe will use an incredibly powerful Visual Studio Code IDE extension pack, nRF Connect developed by Nordic Semiconductor.",
    "crumbs": [
      "Learning Modules",
      "Introduction to Zephyr & Nordic SoCs"
    ]
  },
  {
    "objectID": "slides/zephyr-nrf52833dk-intro.html#bare-metal-vs.-rtos",
    "href": "slides/zephyr-nrf52833dk-intro.html#bare-metal-vs.-rtos",
    "title": "Introduction to Zephyr & Nordic SoC",
    "section": "Bare Metal vs. RTOS",
    "text": "Bare Metal vs. RTOS\n\nBare-metal super-loop implementations\nRealtime Operating System (RTOS)\nInterupt Service Routines (ISR) / Callbacks",
    "crumbs": [
      "Learning Modules",
      "Introduction to Zephyr & Nordic SoCs"
    ]
  },
  {
    "objectID": "slides/zephyr-nrf52833dk-intro.html#what-is-a-system-on-a-chip-soc",
    "href": "slides/zephyr-nrf52833dk-intro.html#what-is-a-system-on-a-chip-soc",
    "title": "Introduction to Zephyr & Nordic SoC",
    "section": "What is a System on a Chip (SoC)?",
    "text": "What is a System on a Chip (SoC)?\n\nCPU\nMemory (RAM) - quite limited\nI/O\nStorage (non-volatile)\nRF / Communication Protocols\n\nUniversal Asynchronous Receiver-Transmitter (UART)\nInter-Integrated Circuit (I2C)\nSerial Peripheral Interface (SPI)\nBluetooth Low Energy (BLE)\n\n\nThis is in contrast to a motherboard-based personal computer, which uses additional discrete components or expansion / peripheral cards.",
    "crumbs": [
      "Learning Modules",
      "Introduction to Zephyr & Nordic SoCs"
    ]
  },
  {
    "objectID": "slides/zephyr-nrf52833dk-intro.html#nordic-nrf52833-development-kit-dk",
    "href": "slides/zephyr-nrf52833dk-intro.html#nordic-nrf52833-development-kit-dk",
    "title": "Introduction to Zephyr & Nordic SoC",
    "section": "Nordic nRF52833 Development Kit (DK)",
    "text": "Nordic nRF52833 Development Kit (DK)\n\nhttps://youtu.be/KOWo9P1qdfk",
    "crumbs": [
      "Learning Modules",
      "Introduction to Zephyr & Nordic SoCs"
    ]
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#what-are-the-challenges-with-sleep-delay-statements",
    "href": "slides/zephyr-timers-slides.html#what-are-the-challenges-with-sleep-delay-statements",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "What are the challenges with sleep / delay statements?",
    "text": "What are the challenges with sleep / delay statements?\n\nOverall timing of the main loop hard to estimate with multiple ”tasks”.\nAdding / removing features can disrupt all of the timing."
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#what-are-the-challenges-with-super-loops",
    "href": "slides/zephyr-timers-slides.html#what-are-the-challenges-with-super-loops",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "What are the challenges with super-loops?",
    "text": "What are the challenges with super-loops?\n\nNested conditional statements testing for timing of events can make the code difficult to read and maintain.\nLeads to “code spaghetti” and “spaghetti timing”."
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#threads",
    "href": "slides/zephyr-timers-slides.html#threads",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Threads",
    "text": "Threads"
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#system-vs.-user-threads",
    "href": "slides/zephyr-timers-slides.html#system-vs.-user-threads",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "System vs. User Threads",
    "text": "System vs. User Threads\n\nZephyr’s kernel starts a system thread and a user-space thread by default.\nUser can add tasks to the system thread and/or create user threads."
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#thread-priority",
    "href": "slides/zephyr-timers-slides.html#thread-priority",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Thread Priority",
    "text": "Thread Priority"
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#timer-threads",
    "href": "slides/zephyr-timers-slides.html#timer-threads",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Timer Threads",
    "text": "Timer Threads\nIn addition to ISR priority and thread priority yielding, the system also has timers for high temporal accuracy tasks (one-time or repeated).\n\nTimers are managed by the kernel (system).\nTimers are always available (i.e., no need to include libraries or enable kernel configurations)\nLike ISR callback functions, timer handler functions should not consume significant resources / take much time to execute.\n\nA handler function at the end of a timer interval (duration / period) must be defined.\nA handler function at the end of a timer stop can optionally be defined.\n\nThe kernel gives timing events relatively high priority."
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#defining-the-timer-and-associated-handler-functions",
    "href": "slides/zephyr-timers-slides.html#defining-the-timer-and-associated-handler-functions",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Defining the Timer and Associated Handler Functions",
    "text": "Defining the Timer and Associated Handler Functions\n/* Declare timer start[/stop] handler functions */\nvoid timer_interval_expiry_handler(struct k_timer *name_of_timer);\nvoid timer_stop_handler(struct k_timer *name_of_timer); // optional \n\nK_TIMER_DEFINE(name_of_timer, timer_interval_expiry_handler, timer_stop_handler);\n\n// if the timer will run indefinitely or doesn't need an explicit action upon stopping\n// K_TIMER_DEFINE(name_of_timer, func_to_exec_on_timer_start, NULL);\n\n/* Define the timer handler functions */\nvoid timer_interval_expiry_handler(struct k_timer *name_of_timer)\n{\n    gpio_pin_toggle_dt(&somepin);\n    // in future assignments, could also post an event here\n}"
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#handler-functions-should-not-test-for-state",
    "href": "slides/zephyr-timers-slides.html#handler-functions-should-not-test-for-state",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Handler Functions Should Not Test for State",
    "text": "Handler Functions Should Not Test for State\nvoid timer_interval_expiry_handler(struct k_timer *name_of_timer)\n{\n    if (state == AWAKE) {\n        gpio_pin_toggle_dt(&somepin);\n    } else (state == SLEEP) {\n        gpio_pin_set_dt(&somepin, 0);\n    }\n}\n\nInstead, use a different timer/handler function for each state:\n\nStop one timer in an exit transition state.\nStart the other in an entry transition state."
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#starting-a-repeating-timer",
    "href": "slides/zephyr-timers-slides.html#starting-a-repeating-timer",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Starting a Repeating Timer",
    "text": "Starting a Repeating Timer\nk_timer_start(&name_of_timer, K_MSEC(DURATION_OF_FIRST_INTERVAL), K_MSEC(DURATION_OF_REPEATED_INTERVALS));\n\nK_MSEC is a macro that converts a time, specified in ms (DURATION_OF_FIRST_EVENT) to whatever time unit the function requires.\nOther useful macros include K_SECONDS, K_MINUTES, K_HOURS, etc.\nTimer functions are executed at the end of each interval (duration / period).\nhttps://docs.zephyrproject.org/latest/kernel/services/timing/clocks.html"
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#stopping-a-timer",
    "href": "slides/zephyr-timers-slides.html#stopping-a-timer",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Stopping a Timer",
    "text": "Stopping a Timer\nk_timer_stop(&name_of_timer);\nThis will call timer_stop_handler() that you associated with the timer using the K_TIMER_DEFINE macro."
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#timer-example",
    "href": "slides/zephyr-timers-slides.html#timer-example",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Timer Example",
    "text": "Timer Example\n\nThis timer toggles the LED state every 500 ms.\n\nNote that the timer handler is executed at the end of each timer interval.\n\nThe stop handler function turns off the LED."
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#starting-a-one-shot-timer",
    "href": "slides/zephyr-timers-slides.html#starting-a-one-shot-timer",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Starting a One-Shot Timer",
    "text": "Starting a One-Shot Timer\nIf you want to do something once for a specified duration (one-shot behavior).\nk_timer_start(&name_of_timer, K_MSEC(DURATION_OF_FIRST_INTERVAL), K_NO_WAIT);"
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#one-shot-timer-example",
    "href": "slides/zephyr-timers-slides.html#one-shot-timer-example",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "One-Shot Timer Example",
    "text": "One-Shot Timer Example\n\nIn the example below, you can use the one-shot timer to toggle the LED state after 1 second. Note that the LED is turned on seaprate from the timer and the timer handler is executed at the end of the timer interval to turn it off.\n\ngpio_pin_toggle_dt(&led);\nk_timer_start(&name_of_timer, K_MSEC(4000), K_NO_WAIT);\n\n\nThere is no need to stop the timer; it terminates after the specified interval."
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#restarting-timers",
    "href": "slides/zephyr-timers-slides.html#restarting-timers",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Restarting Timers",
    "text": "Restarting Timers\n\nYou do not need to stop a timer that is already running to reset the timing interval.\nJust execute k_timer_start() again.\nNote that the timer will not be set to the new interval until it completes the interval it currently is ”in”."
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#notes",
    "href": "slides/zephyr-timers-slides.html#notes",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Notes",
    "text": "Notes\n\n\n\n\n\n\nWarning\n\n\nIf you set a duration / period to 0, the timer will:\n\nExecute as fast as possible, and\nStop without running the optionally associated stop function!\n\n\n\n\n\nThe specified duration / period are the minimum times between executions of the timer function.\n\nOther blocking code may cause the timer function to execute later than the specified duration / period."
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#what-is-a-work-queue",
    "href": "slides/zephyr-timers-slides.html#what-is-a-work-queue",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "What is a Work Queue?",
    "text": "What is a Work Queue?\n\nA work queue is a way to execute a function when the system is not busy.\nWork queues are managed by the kernel (system).\n\nSystem work queue exists by default (no need to include libraries or enable kernel options).\nUser can create additional work queues, but need to be defined and initialized."
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#how-work-queues-help-us",
    "href": "slides/zephyr-timers-slides.html#how-work-queues-help-us",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "How Work Queues Help Us",
    "text": "How Work Queues Help Us\n\nCallbacks and handler functions associated with ISRs and timers should not consume significant resource / take much time to execute.\nPro: Work queues allow us to execute functions that may take longer to execute.\nCon: The specific timing of the execution of the function is not guaranteed.\nNo longer need to test for Boolean variables in the main loop to determine when to execute a function."
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#pseudo-code-1",
    "href": "slides/zephyr-timers-slides.html#pseudo-code-1",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Pseudo-Code",
    "text": "Pseudo-Code\n/* declare work queue handler function */\nvoid blink_timer_work_handler(struct k_work *timer_work);\n\n/* define a work queue to associate with the handler function */\nK_WORK_DEFINE(blink_timer_work, blink_timer_work_handler);\n\n/* in your timer callback function, submit your task to the work queue */\nvoid blink_timer_handler(struct k_timer *blink_timer){\n    k_work_submit(&blink_timer_work);\n    LOG_INF(\"Submitted blinking work to the queue! (%lld)\", k_uptime_get());\n}\n\n/* define the work queue handler function */\nvoid blink_timer_work_handler(struct k_work *timer_work) {\n    LOG_INF(\"Doing blink work! (%lld)\", k_uptime_get());\n    gpio_pin_toggle_dt(&led_blink);\n    k_msleep(WORK_QUEUE_NAP_TIME_MS);\n    LOG_INF(\"Took a nap... just woke up. (%lld)\", k_uptime_get());\n}"
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#example-code",
    "href": "slides/zephyr-timers-slides.html#example-code",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Example Code",
    "text": "Example Code\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n#include &lt;zephyr/logging/log.h&gt;\n\nLOG_MODULE_REGISTER(main, LOG_LEVEL_DBG);\n\n#define MAIN_SLEEP_TIME_MS   100000\n#define BLINK_TIMER_INTERVAL_MS 500\n#define WORK_QUEUE_NAP_TIME_MS 10\n#define ONESHOT_DURATION_MS 10000\n\nstatic const struct gpio_dt_spec led_blink = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);\nstatic const struct gpio_dt_spec led_oneshot = GPIO_DT_SPEC_GET(DT_ALIAS(led1), gpios);\n\nvoid blink_timer_handler(struct k_timer *blink_timer);\nvoid blink_timer_stop(struct k_timer *blink_timer);\nvoid oneshot_timer_handler(struct k_timer *blink_timer);\nvoid blink_timer_work_handler(struct k_work *timer_work);\n\nK_TIMER_DEFINE(blink_timer, blink_timer_handler, blink_timer_stop);\nK_TIMER_DEFINE(oneshot_timer, oneshot_timer_handler, NULL);\nK_WORK_DEFINE(blink_timer_work, blink_timer_work_handler);\n\nint main(void)\n{\n    int ret;\n\n    if (!gpio_is_ready_dt(&led_blink)) {\n        return -1;\n    }\n\n    ret = gpio_pin_configure_dt(&led_blink, GPIO_OUTPUT_ACTIVE);\n    if (ret &lt; 0) {\n        return -1;\n    }\n    ret = gpio_pin_configure_dt(&led_oneshot, GPIO_OUTPUT_ACTIVE);\n    if (ret &lt; 0) {\n        return -1;\n    }\n\n    k_timer_start(&blink_timer, K_MSEC(BLINK_TIMER_INTERVAL_MS), K_MSEC(BLINK_TIMER_INTERVAL_MS));\n    k_timer_start(&oneshot_timer, K_MSEC(ONESHOT_DURATION_MS), K_NO_WAIT);\n\n    while (1) {\n        k_msleep(MAIN_SLEEP_TIME_MS);\n    }\n\n    return 0;\n}\n\nvoid blink_timer_handler(struct k_timer *blink_timer){\n    k_work_submit(&blink_timer_work);\n    LOG_INF(\"Submitted blinking work to the queue! (%lld)\", k_uptime_get());\n}\n\nvoid blink_timer_stop(struct k_timer *blink_timer){\n    LOG_INF(\"Stopping the blinking LED.\");\n    gpio_pin_set_dt(&led_blink, 0);\n}\n\nvoid blink_timer_work_handler(struct k_work *timer_work) {\n    LOG_INF(\"Doing blink work! (%lld)\", k_uptime_get());\n    gpio_pin_toggle_dt(&led_blink);\n    k_msleep(WORK_QUEUE_NAP_TIME_MS);\n    LOG_INF(\"Took a nap... just woke up. (%lld)\", k_uptime_get());\n}\n\nvoid oneshot_timer_handler(struct k_timer *oneshot_timer) {\n    LOG_INF(\"Turn oneshot LED off (%lld)\", k_uptime_get());\n    gpio_pin_set_dt(&led_oneshot, 0);\n}"
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#high-level-flow-chart",
    "href": "slides/zephyr-timers-slides.html#high-level-flow-chart",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "High-level Flow Chart",
    "text": "High-level Flow Chart"
  },
  {
    "objectID": "slides/zephyr-timers-slides.html#resources",
    "href": "slides/zephyr-timers-slides.html#resources",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Resources",
    "text": "Resources\n\nZephyr Docs: Timers\nZephyr Docs: Clocks"
  },
  {
    "objectID": "slides/zephyr-timers.html",
    "href": "slides/zephyr-timers.html",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "",
    "text": "Overall timing of the main loop hard to estimate with multiple ”tasks”.\nAdding / removing features can disrupt all of the timing.",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#what-are-the-challenges-with-sleep-delay-statements",
    "href": "slides/zephyr-timers.html#what-are-the-challenges-with-sleep-delay-statements",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "",
    "text": "Overall timing of the main loop hard to estimate with multiple ”tasks”.\nAdding / removing features can disrupt all of the timing.",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#what-are-the-challenges-with-super-loops",
    "href": "slides/zephyr-timers.html#what-are-the-challenges-with-super-loops",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "What are the challenges with super-loops?",
    "text": "What are the challenges with super-loops?\n\nNested conditional statements testing for timing of events can make the code difficult to read and maintain.\nLeads to “code spaghetti” and “spaghetti timing”.",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#threads",
    "href": "slides/zephyr-timers.html#threads",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Threads",
    "text": "Threads",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#system-vs.-user-threads",
    "href": "slides/zephyr-timers.html#system-vs.-user-threads",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "System vs. User Threads",
    "text": "System vs. User Threads\n\nZephyr’s kernel starts a system thread and a user-space thread by default.\nUser can add tasks to the system thread and/or create user threads.",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#thread-priority",
    "href": "slides/zephyr-timers.html#thread-priority",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Thread Priority",
    "text": "Thread Priority",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#timer-threads",
    "href": "slides/zephyr-timers.html#timer-threads",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Timer Threads",
    "text": "Timer Threads\nIn addition to ISR priority and thread priority yielding, the system also has timers for high temporal accuracy tasks (one-time or repeated).\n\nTimers are managed by the kernel (system).\nTimers are always available (i.e., no need to include libraries or enable kernel configurations)\nLike ISR callback functions, timer handler functions should not consume significant resources / take much time to execute.\n\nA handler function at the end of a timer interval (duration / period) must be defined.\nA handler function at the end of a timer stop can optionally be defined.\n\nThe kernel gives timing events relatively high priority.",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#defining-the-timer-and-associated-handler-functions",
    "href": "slides/zephyr-timers.html#defining-the-timer-and-associated-handler-functions",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Defining the Timer and Associated Handler Functions",
    "text": "Defining the Timer and Associated Handler Functions\n/* Declare timer start[/stop] handler functions */\nvoid timer_interval_expiry_handler(struct k_timer *name_of_timer);\nvoid timer_stop_handler(struct k_timer *name_of_timer); // optional \n\nK_TIMER_DEFINE(name_of_timer, timer_interval_expiry_handler, timer_stop_handler);\n\n// if the timer will run indefinitely or doesn't need an explicit action upon stopping\n// K_TIMER_DEFINE(name_of_timer, func_to_exec_on_timer_start, NULL);\n\n/* Define the timer handler functions */\nvoid timer_interval_expiry_handler(struct k_timer *name_of_timer)\n{\n    gpio_pin_toggle_dt(&somepin);\n    // in future assignments, could also post an event here\n}",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#handler-functions-should-not-test-for-state",
    "href": "slides/zephyr-timers.html#handler-functions-should-not-test-for-state",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Handler Functions Should Not Test for State",
    "text": "Handler Functions Should Not Test for State\nvoid timer_interval_expiry_handler(struct k_timer *name_of_timer)\n{\n    if (state == AWAKE) {\n        gpio_pin_toggle_dt(&somepin);\n    } else (state == SLEEP) {\n        gpio_pin_set_dt(&somepin, 0);\n    }\n}\n\nInstead, use a different timer/handler function for each state:\n\nStop one timer in an exit transition state.\nStart the other in an entry transition state.",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#starting-a-repeating-timer",
    "href": "slides/zephyr-timers.html#starting-a-repeating-timer",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Starting a Repeating Timer",
    "text": "Starting a Repeating Timer\nk_timer_start(&name_of_timer, K_MSEC(DURATION_OF_FIRST_INTERVAL), K_MSEC(DURATION_OF_REPEATED_INTERVALS));\n\nK_MSEC is a macro that converts a time, specified in ms (DURATION_OF_FIRST_EVENT) to whatever time unit the function requires.\nOther useful macros include K_SECONDS, K_MINUTES, K_HOURS, etc.\nTimer functions are executed at the end of each interval (duration / period).\nhttps://docs.zephyrproject.org/latest/kernel/services/timing/clocks.html",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#stopping-a-timer",
    "href": "slides/zephyr-timers.html#stopping-a-timer",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Stopping a Timer",
    "text": "Stopping a Timer\nk_timer_stop(&name_of_timer);\nThis will call timer_stop_handler() that you associated with the timer using the K_TIMER_DEFINE macro.",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#timer-example",
    "href": "slides/zephyr-timers.html#timer-example",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Timer Example",
    "text": "Timer Example\n\nThis timer toggles the LED state every 500 ms.\n\nNote that the timer handler is executed at the end of each timer interval.\n\nThe stop handler function turns off the LED.",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#starting-a-one-shot-timer",
    "href": "slides/zephyr-timers.html#starting-a-one-shot-timer",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Starting a One-Shot Timer",
    "text": "Starting a One-Shot Timer\nIf you want to do something once for a specified duration (one-shot behavior).\nk_timer_start(&name_of_timer, K_MSEC(DURATION_OF_FIRST_INTERVAL), K_NO_WAIT);",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#one-shot-timer-example",
    "href": "slides/zephyr-timers.html#one-shot-timer-example",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "One-Shot Timer Example",
    "text": "One-Shot Timer Example\n\nIn the example below, you can use the one-shot timer to toggle the LED state after 1 second. Note that the LED is turned on seaprate from the timer and the timer handler is executed at the end of the timer interval to turn it off.\n\ngpio_pin_toggle_dt(&led);\nk_timer_start(&name_of_timer, K_MSEC(4000), K_NO_WAIT);\n\n\n\n\n\n\nThere is no need to stop the timer; it terminates after the specified interval.",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#restarting-timers",
    "href": "slides/zephyr-timers.html#restarting-timers",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Restarting Timers",
    "text": "Restarting Timers\n\nYou do not need to stop a timer that is already running to reset the timing interval.\nJust execute k_timer_start() again.\nNote that the timer will not be set to the new interval until it completes the interval it currently is ”in”.",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#notes",
    "href": "slides/zephyr-timers.html#notes",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Notes",
    "text": "Notes\n\n\n\n\n\n\nWarning\n\n\n\nIf you set a duration / period to 0, the timer will:\n\nExecute as fast as possible, and\nStop without running the optionally associated stop function!\n\n\n\n\nThe specified duration / period are the minimum times between executions of the timer function.\n\nOther blocking code may cause the timer function to execute later than the specified duration / period.",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#what-is-a-work-queue",
    "href": "slides/zephyr-timers.html#what-is-a-work-queue",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "What is a Work Queue?",
    "text": "What is a Work Queue?\n\nA work queue is a way to execute a function when the system is not busy.\nWork queues are managed by the kernel (system).\n\nSystem work queue exists by default (no need to include libraries or enable kernel options).\nUser can create additional work queues, but need to be defined and initialized.",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#how-work-queues-help-us",
    "href": "slides/zephyr-timers.html#how-work-queues-help-us",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "How Work Queues Help Us",
    "text": "How Work Queues Help Us\n\nCallbacks and handler functions associated with ISRs and timers should not consume significant resource / take much time to execute.\nPro: Work queues allow us to execute functions that may take longer to execute.\nCon: The specific timing of the execution of the function is not guaranteed.\nNo longer need to test for Boolean variables in the main loop to determine when to execute a function.",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#pseudo-code-1",
    "href": "slides/zephyr-timers.html#pseudo-code-1",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Pseudo-Code",
    "text": "Pseudo-Code\n/* declare work queue handler function */\nvoid blink_timer_work_handler(struct k_work *timer_work);\n\n/* define a work queue to associate with the handler function */\nK_WORK_DEFINE(blink_timer_work, blink_timer_work_handler);\n\n/* in your timer callback function, submit your task to the work queue */\nvoid blink_timer_handler(struct k_timer *blink_timer){\n    k_work_submit(&blink_timer_work);\n    LOG_INF(\"Submitted blinking work to the queue! (%lld)\", k_uptime_get());\n}\n\n/* define the work queue handler function */\nvoid blink_timer_work_handler(struct k_work *timer_work) {\n    LOG_INF(\"Doing blink work! (%lld)\", k_uptime_get());\n    gpio_pin_toggle_dt(&led_blink);\n    k_msleep(WORK_QUEUE_NAP_TIME_MS);\n    LOG_INF(\"Took a nap... just woke up. (%lld)\", k_uptime_get());\n}",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#example-code",
    "href": "slides/zephyr-timers.html#example-code",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Example Code",
    "text": "Example Code\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n#include &lt;zephyr/logging/log.h&gt;\n\nLOG_MODULE_REGISTER(main, LOG_LEVEL_DBG);\n\n#define MAIN_SLEEP_TIME_MS   100000\n#define BLINK_TIMER_INTERVAL_MS 500\n#define WORK_QUEUE_NAP_TIME_MS 10\n#define ONESHOT_DURATION_MS 10000\n\nstatic const struct gpio_dt_spec led_blink = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);\nstatic const struct gpio_dt_spec led_oneshot = GPIO_DT_SPEC_GET(DT_ALIAS(led1), gpios);\n\nvoid blink_timer_handler(struct k_timer *blink_timer);\nvoid blink_timer_stop(struct k_timer *blink_timer);\nvoid oneshot_timer_handler(struct k_timer *blink_timer);\nvoid blink_timer_work_handler(struct k_work *timer_work);\n\nK_TIMER_DEFINE(blink_timer, blink_timer_handler, blink_timer_stop);\nK_TIMER_DEFINE(oneshot_timer, oneshot_timer_handler, NULL);\nK_WORK_DEFINE(blink_timer_work, blink_timer_work_handler);\n\nint main(void)\n{\n    int ret;\n\n    if (!gpio_is_ready_dt(&led_blink)) {\n        return -1;\n    }\n\n    ret = gpio_pin_configure_dt(&led_blink, GPIO_OUTPUT_ACTIVE);\n    if (ret &lt; 0) {\n        return -1;\n    }\n    ret = gpio_pin_configure_dt(&led_oneshot, GPIO_OUTPUT_ACTIVE);\n    if (ret &lt; 0) {\n        return -1;\n    }\n\n    k_timer_start(&blink_timer, K_MSEC(BLINK_TIMER_INTERVAL_MS), K_MSEC(BLINK_TIMER_INTERVAL_MS));\n    k_timer_start(&oneshot_timer, K_MSEC(ONESHOT_DURATION_MS), K_NO_WAIT);\n\n    while (1) {\n        k_msleep(MAIN_SLEEP_TIME_MS);\n    }\n\n    return 0;\n}\n\nvoid blink_timer_handler(struct k_timer *blink_timer){\n    k_work_submit(&blink_timer_work);\n    LOG_INF(\"Submitted blinking work to the queue! (%lld)\", k_uptime_get());\n}\n\nvoid blink_timer_stop(struct k_timer *blink_timer){\n    LOG_INF(\"Stopping the blinking LED.\");\n    gpio_pin_set_dt(&led_blink, 0);\n}\n\nvoid blink_timer_work_handler(struct k_work *timer_work) {\n    LOG_INF(\"Doing blink work! (%lld)\", k_uptime_get());\n    gpio_pin_toggle_dt(&led_blink);\n    k_msleep(WORK_QUEUE_NAP_TIME_MS);\n    LOG_INF(\"Took a nap... just woke up. (%lld)\", k_uptime_get());\n}\n\nvoid oneshot_timer_handler(struct k_timer *oneshot_timer) {\n    LOG_INF(\"Turn oneshot LED off (%lld)\", k_uptime_get());\n    gpio_pin_set_dt(&led_oneshot, 0);\n}",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#high-level-flow-chart",
    "href": "slides/zephyr-timers.html#high-level-flow-chart",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "High-level Flow Chart",
    "text": "High-level Flow Chart",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  },
  {
    "objectID": "slides/zephyr-timers.html#resources",
    "href": "slides/zephyr-timers.html#resources",
    "title": "Zephyr: Timers, Threads, Work Queues & Events",
    "section": "Resources",
    "text": "Resources\n\nZephyr Docs: Timers\nZephyr Docs: Clocks",
    "crumbs": [
      "Learning Modules",
      "Timers"
    ]
  }
]